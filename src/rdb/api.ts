/* tslint:disable */
/* eslint-disable */
/**
 * ALTRepo API
 * altrepo API v1
 *
 * The version of the OpenAPI document: 1.19.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface APIVersion
 */
export interface APIVersion {
    /**
     * API name
     * @type {string}
     * @memberof APIVersion
     */
    'name'?: string;
    /**
     * API version
     * @type {string}
     * @memberof APIVersion
     */
    'version'?: string;
    /**
     * API description
     * @type {string}
     * @memberof APIVersion
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AclByPackagesElementModel
 */
export interface AclByPackagesElementModel {
    /**
     * package name
     * @type {string}
     * @memberof AclByPackagesElementModel
     */
    'name'?: string;
    /**
     * last ACL update date
     * @type {string}
     * @memberof AclByPackagesElementModel
     */
    'updated'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AclByPackagesElementModel
     */
    'members'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AclByPackagesModel
 */
export interface AclByPackagesModel {
    /**
     * packages\' branch
     * @type {string}
     * @memberof AclByPackagesModel
     */
    'branch'?: string;
    /**
     * packages with its ACL members
     * @type {Array<AclByPackagesElementModel>}
     * @memberof AclByPackagesModel
     */
    'packages'?: Array<AclByPackagesElementModel>;
}
/**
 * 
 * @export
 * @interface AclGroupsElementModel
 */
export interface AclGroupsElementModel {
    /**
     * ACL group name
     * @type {string}
     * @memberof AclGroupsElementModel
     */
    'group'?: string;
    /**
     * ACL group last updated
     * @type {string}
     * @memberof AclGroupsElementModel
     */
    'date'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AclGroupsElementModel
     */
    'maintainers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AclGroupsModel
 */
export interface AclGroupsModel {
    /**
     * request arguments
     * @type {object}
     * @memberof AclGroupsModel
     */
    'request_args'?: object;
    /**
     * number of ACL groups found
     * @type {number}
     * @memberof AclGroupsModel
     */
    'length'?: number;
    /**
     * ACL groups list
     * @type {Array<AclGroupsElementModel>}
     * @memberof AclGroupsModel
     */
    'groups'?: Array<AclGroupsElementModel>;
}
/**
 * 
 * @export
 * @interface AclMaintainerGroupsElementModel
 */
export interface AclMaintainerGroupsElementModel {
    /**
     * branch name
     * @type {string}
     * @memberof AclMaintainerGroupsElementModel
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AclMaintainerGroupsElementModel
     */
    'groups'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AclMaintainerGroupsModel
 */
export interface AclMaintainerGroupsModel {
    /**
     * maintainer\'s nickname
     * @type {string}
     * @memberof AclMaintainerGroupsModel
     */
    'nickname'?: string;
    /**
     * branches with maintainer and groups
     * @type {Array<AclMaintainerGroupsElementModel>}
     * @memberof AclMaintainerGroupsModel
     */
    'branches'?: Array<AclMaintainerGroupsElementModel>;
}
/**
 * 
 * @export
 * @interface ActiveImagesElementModel
 */
export interface ActiveImagesElementModel {
    /**
     * ISO image edition
     * @type {string}
     * @memberof ActiveImagesElementModel
     */
    'edition'?: string;
    /**
     * active tags list
     * @type {Array<string>}
     * @memberof ActiveImagesElementModel
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ActiveImagesModel
 */
export interface ActiveImagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof ActiveImagesModel
     */
    'request_args'?: object;
    /**
     * number of images found
     * @type {number}
     * @memberof ActiveImagesModel
     */
    'length'?: number;
    /**
     * active images list
     * @type {Array<ActiveImagesElementModel>}
     * @memberof ActiveImagesModel
     */
    'images'?: Array<ActiveImagesElementModel>;
}
/**
 * 
 * @export
 * @interface AllMaintainersElementModel
 */
export interface AllMaintainersElementModel {
    /**
     * Maintainer\'s name
     * @type {string}
     * @memberof AllMaintainersElementModel
     */
    'packager_name'?: string;
    /**
     * Maintainer\'s nickname
     * @type {string}
     * @memberof AllMaintainersElementModel
     */
    'packager_nickname'?: string;
    /**
     * Number of source packages
     * @type {number}
     * @memberof AllMaintainersElementModel
     */
    'count_source_pkg'?: number;
}
/**
 * 
 * @export
 * @interface AllMaintainersModel
 */
export interface AllMaintainersModel {
    /**
     * request arguments
     * @type {object}
     * @memberof AllMaintainersModel
     */
    'request_args'?: object;
    /**
     * number of maintainers found
     * @type {number}
     * @memberof AllMaintainersModel
     */
    'length'?: number;
    /**
     * maintainers info
     * @type {Array<AllMaintainersElementModel>}
     * @memberof AllMaintainersModel
     */
    'maintainers'?: Array<AllMaintainersElementModel>;
}
/**
 * 
 * @export
 * @interface AllTasksBranchesModel
 */
export interface AllTasksBranchesModel {
    /**
     * number of packagesets found
     * @type {number}
     * @memberof AllTasksBranchesModel
     */
    'length'?: number;
    /**
     * list of packagesets
     * @type {Array<string>}
     * @memberof AllTasksBranchesModel
     */
    'branches'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BackportHelperBinaryDepthElementModel
 */
export interface BackportHelperBinaryDepthElementModel {
    /**
     * dependency depth
     * @type {number}
     * @memberof BackportHelperBinaryDepthElementModel
     */
    'depth'?: number;
    /**
     * packages dependencies list
     * @type {Array<BackportHelperBinaryElementModel>}
     * @memberof BackportHelperBinaryDepthElementModel
     */
    'packages'?: Array<BackportHelperBinaryElementModel>;
}
/**
 * 
 * @export
 * @interface BackportHelperBinaryElementModel
 */
export interface BackportHelperBinaryElementModel {
    /**
     * package srpm
     * @type {string}
     * @memberof BackportHelperBinaryElementModel
     */
    'srpm'?: string;
    /**
     * package name
     * @type {string}
     * @memberof BackportHelperBinaryElementModel
     */
    'name'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof BackportHelperBinaryElementModel
     */
    'epoch'?: number;
    /**
     * package version
     * @type {string}
     * @memberof BackportHelperBinaryElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof BackportHelperBinaryElementModel
     */
    'release'?: string;
    /**
     * packages arch
     * @type {string}
     * @memberof BackportHelperBinaryElementModel
     */
    'arch'?: string;
}
/**
 * 
 * @export
 * @interface BackportHelperModel
 */
export interface BackportHelperModel {
    /**
     * request arguments
     * @type {object}
     * @memberof BackportHelperModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof BackportHelperModel
     */
    'count'?: number;
    /**
     * maxium depth reached
     * @type {number}
     * @memberof BackportHelperModel
     */
    'maxdepth'?: number;
    /**
     * packages dependencies list by depth
     * @type {Array<BackportHelperBinaryDepthElementModel>}
     * @memberof BackportHelperModel
     */
    'dependencies'?: Array<BackportHelperBinaryDepthElementModel>;
}
/**
 * 
 * @export
 * @interface BinPackageLogElementModel
 */
export interface BinPackageLogElementModel {
    /**
     * binary package hash
     * @type {string}
     * @memberof BinPackageLogElementModel
     */
    'pkg_hash'?: string;
    /**
     * task id
     * @type {number}
     * @memberof BinPackageLogElementModel
     */
    'task_id'?: number;
    /**
     * subtask id
     * @type {number}
     * @memberof BinPackageLogElementModel
     */
    'subtask_id'?: number;
    /**
     * package architecture
     * @type {string}
     * @memberof BinPackageLogElementModel
     */
    'subtask_arch'?: string;
    /**
     * hash of the log
     * @type {string}
     * @memberof BinPackageLogElementModel
     */
    'buildlog_hash'?: string;
    /**
     * link to the binary package build log
     * @type {string}
     * @memberof BinPackageLogElementModel
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface BranchTreeBranchCommitModel
 */
export interface BranchTreeBranchCommitModel {
    /**
     * branch name
     * @type {string}
     * @memberof BranchTreeBranchCommitModel
     */
    'name'?: string;
    /**
     * branch commit date
     * @type {string}
     * @memberof BranchTreeBranchCommitModel
     */
    'date'?: string;
    /**
     * task ID
     * @type {number}
     * @memberof BranchTreeBranchCommitModel
     */
    'task'?: number;
}
/**
 * 
 * @export
 * @interface BranchTreeBranchPointModel
 */
export interface BranchTreeBranchPointModel {
    /**
     * branch name
     * @type {string}
     * @memberof BranchTreeBranchPointModel
     */
    'branch'?: string;
    /**
     * first branch\' task
     * @type {BranchTreeTaskModel}
     * @memberof BranchTreeBranchPointModel
     */
    'task'?: BranchTreeTaskModel;
    /**
     * task from parent branch
     * @type {BranchTreeTaskModel}
     * @memberof BranchTreeBranchPointModel
     */
    'from_task'?: BranchTreeTaskModel;
}
/**
 * 
 * @export
 * @interface BranchTreeModel
 */
export interface BranchTreeModel {
    /**
     * list of branches
     * @type {Array<string>}
     * @memberof BranchTreeModel
     */
    'branches'?: Array<string>;
    /**
     * branches tasks list
     * @type {Array<BranchTreeTaskModel>}
     * @memberof BranchTreeModel
     */
    'tasks'?: Array<BranchTreeTaskModel>;
    /**
     * branches commits list
     * @type {Array<BranchTreeBranchCommitModel>}
     * @memberof BranchTreeModel
     */
    'branch_commits'?: Array<BranchTreeBranchCommitModel>;
    /**
     * branch points list
     * @type {Array<BranchTreeBranchPointModel>}
     * @memberof BranchTreeModel
     */
    'branch_points'?: Array<BranchTreeBranchPointModel>;
}
/**
 * 
 * @export
 * @interface BranchTreeTaskModel
 */
export interface BranchTreeTaskModel {
    /**
     * task ID
     * @type {number}
     * @memberof BranchTreeTaskModel
     */
    'id'?: number;
    /**
     * previous task ID
     * @type {number}
     * @memberof BranchTreeTaskModel
     */
    'prev'?: number;
    /**
     * task branch name
     * @type {string}
     * @memberof BranchTreeTaskModel
     */
    'branch'?: string;
    /**
     * task build time
     * @type {string}
     * @memberof BranchTreeTaskModel
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface BugzillaInfoElementModel
 */
export interface BugzillaInfoElementModel {
    /**
     * bug id
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'id'?: string;
    /**
     * bug status
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'status'?: string;
    /**
     * bug resolution
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'resolution'?: string;
    /**
     * bug severity
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'severity'?: string;
    /**
     * product name
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'product'?: string;
    /**
     * version
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'version'?: string;
    /**
     * platform name
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'platform'?: string;
    /**
     * component name
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'component'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'source_package_name'?: string;
    /**
     * binary package name
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'binary_package_name'?: string;
    /**
     * bug assigned to
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'assignee'?: string;
    /**
     * bug registered by
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'reporter'?: string;
    /**
     * bug summary
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'summary'?: string;
    /**
     * bug record last changed
     * @type {string}
     * @memberof BugzillaInfoElementModel
     */
    'last_changed'?: string;
}
/**
 * 
 * @export
 * @interface BugzillaInfoModel
 */
export interface BugzillaInfoModel {
    /**
     * request arguments
     * @type {object}
     * @memberof BugzillaInfoModel
     */
    'request_args'?: object;
    /**
     * number of bugs found
     * @type {number}
     * @memberof BugzillaInfoModel
     */
    'length'?: number;
    /**
     * bugzilla info
     * @type {Array<BugzillaInfoElementModel>}
     * @memberof BugzillaInfoModel
     */
    'bugs'?: Array<BugzillaInfoElementModel>;
}
/**
 * 
 * @export
 * @interface BuildDependencySetAmbiguousProvidesElementModel
 */
export interface BuildDependencySetAmbiguousProvidesElementModel {
    /**
     * package require dependency name
     * @type {string}
     * @memberof BuildDependencySetAmbiguousProvidesElementModel
     */
    'requires'?: string;
    /**
     * ambiguous provides packaages count
     * @type {number}
     * @memberof BuildDependencySetAmbiguousProvidesElementModel
     */
    'provides_count'?: number;
    /**
     * list of packages that provides required dependency
     * @type {Array<BuildDependencySetAmbiguousProvidesPackageModel>}
     * @memberof BuildDependencySetAmbiguousProvidesElementModel
     */
    'provides'?: Array<BuildDependencySetAmbiguousProvidesPackageModel>;
}
/**
 * 
 * @export
 * @interface BuildDependencySetAmbiguousProvidesModel
 */
export interface BuildDependencySetAmbiguousProvidesModel {
    /**
     * package name
     * @type {string}
     * @memberof BuildDependencySetAmbiguousProvidesModel
     */
    'package'?: string;
    /**
     * list of found and resolved ambiguous provides
     * @type {Array<BuildDependencySetAmbiguousProvidesElementModel>}
     * @memberof BuildDependencySetAmbiguousProvidesModel
     */
    'ambiguous_provides'?: Array<BuildDependencySetAmbiguousProvidesElementModel>;
}
/**
 * 
 * @export
 * @interface BuildDependencySetAmbiguousProvidesPackageModel
 */
export interface BuildDependencySetAmbiguousProvidesPackageModel {
    /**
     * package name
     * @type {string}
     * @memberof BuildDependencySetAmbiguousProvidesPackageModel
     */
    'name'?: string;
    /**
     * package used as provide dependency
     * @type {boolean}
     * @memberof BuildDependencySetAmbiguousProvidesPackageModel
     */
    'used'?: boolean;
}
/**
 * 
 * @export
 * @interface BuildDependencySetModel
 */
export interface BuildDependencySetModel {
    /**
     * request arguments
     * @type {object}
     * @memberof BuildDependencySetModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof BuildDependencySetModel
     */
    'length'?: number;
    /**
     * build requirements packages information
     * @type {Array<BuildDependencySetPackagesModel>}
     * @memberof BuildDependencySetModel
     */
    'packages'?: Array<BuildDependencySetPackagesModel>;
    /**
     * list of found and resolved ambiguous dependencies
     * @type {Array<BuildDependencySetAmbiguousProvidesModel>}
     * @memberof BuildDependencySetModel
     */
    'ambiguous_dependencies'?: Array<BuildDependencySetAmbiguousProvidesModel>;
}
/**
 * 
 * @export
 * @interface BuildDependencySetPackageModel
 */
export interface BuildDependencySetPackageModel {
    /**
     * package name
     * @type {string}
     * @memberof BuildDependencySetPackageModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof BuildDependencySetPackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof BuildDependencySetPackageModel
     */
    'release'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof BuildDependencySetPackageModel
     */
    'epoch'?: number;
    /**
     * binary packages archs
     * @type {Array<string>}
     * @memberof BuildDependencySetPackageModel
     */
    'archs'?: Array<string>;
    /**
     * binary packages require dependencies
     * @type {Array<string>}
     * @memberof BuildDependencySetPackageModel
     */
    'requires'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BuildDependencySetPackagesModel
 */
export interface BuildDependencySetPackagesModel {
    /**
     * source package name
     * @type {string}
     * @memberof BuildDependencySetPackagesModel
     */
    'package'?: string;
    /**
     * number of dependency packages found
     * @type {number}
     * @memberof BuildDependencySetPackagesModel
     */
    'length'?: number;
    /**
     * build requirements packages information
     * @type {Array<BuildDependencySetPackageModel>}
     * @memberof BuildDependencySetPackagesModel
     */
    'depends'?: Array<BuildDependencySetPackageModel>;
}
/**
 * 
 * @export
 * @interface CheckImagesInputFilterModel
 */
export interface CheckImagesInputFilterModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckImagesInputFilterModel
     */
    'editions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckImagesInputFilterModel
     */
    'releases'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckImagesInputFilterModel
     */
    'versions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckImagesInputFilterModel
     */
    'archs'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckImagesInputFilterModel
     */
    'variants'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckImagesInputFilterModel
     */
    'types'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CheckImagesInputModel
 */
export interface CheckImagesInputModel {
    /**
     * task id
     * @type {number}
     * @memberof CheckImagesInputModel
     */
    'task_id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckImagesInputModel
     */
    'binpkgs_names'?: Array<string>;
    /**
     * list of filters
     * @type {Array<CheckImagesInputFilterModel>}
     * @memberof CheckImagesInputModel
     */
    'filters'?: Array<CheckImagesInputFilterModel>;
}
/**
 * 
 * @export
 * @interface CheckImagesOutputImageModel
 */
export interface CheckImagesOutputImageModel {
    /**
     * image file
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'file'?: string;
    /**
     * image branch
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'branch'?: string;
    /**
     * image edition
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'edition'?: string;
    /**
     * image flavor
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'flavor'?: string;
    /**
     * image platform
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'platform'?: string;
    /**
     * image release
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'release'?: string;
    /**
     * image major version
     * @type {number}
     * @memberof CheckImagesOutputImageModel
     */
    'major_version'?: number;
    /**
     * image minor version
     * @type {number}
     * @memberof CheckImagesOutputImageModel
     */
    'minor_version'?: number;
    /**
     * image sub version
     * @type {number}
     * @memberof CheckImagesOutputImageModel
     */
    'sub_version'?: number;
    /**
     * image arch
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'arch'?: string;
    /**
     * image variant
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'variant'?: string;
    /**
     * image type
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'type'?: string;
    /**
     * image built date in ISO8601 format
     * @type {string}
     * @memberof CheckImagesOutputImageModel
     */
    'buildtime'?: string;
    /**
     * list of binary packages
     * @type {Array<CheckImagesOutputPackageModel>}
     * @memberof CheckImagesOutputImageModel
     */
    'packages'?: Array<CheckImagesOutputPackageModel>;
}
/**
 * 
 * @export
 * @interface CheckImagesOutputModel
 */
export interface CheckImagesOutputModel {
    /**
     * request arguments
     * @type {object}
     * @memberof CheckImagesOutputModel
     */
    'request_args'?: object;
    /**
     * list of images with binary packages
     * @type {Array<CheckImagesOutputImageModel>}
     * @memberof CheckImagesOutputModel
     */
    'in_images'?: Array<CheckImagesOutputImageModel>;
    /**
     * list of binary packages which doesn\'t belong to any image
     * @type {Array<CheckImagesOutputPackageModel>}
     * @memberof CheckImagesOutputModel
     */
    'not_in_images'?: Array<CheckImagesOutputPackageModel>;
}
/**
 * 
 * @export
 * @interface CheckImagesOutputPackageModel
 */
export interface CheckImagesOutputPackageModel {
    /**
     * binary package status
     * @type {string}
     * @memberof CheckImagesOutputPackageModel
     */
    'status'?: string;
    /**
     * subtask id
     * @type {number}
     * @memberof CheckImagesOutputPackageModel
     */
    'from_subtask'?: number;
    /**
     * source package name
     * @type {string}
     * @memberof CheckImagesOutputPackageModel
     */
    'srcpkg_name'?: string;
    /**
     * binary package name
     * @type {string}
     * @memberof CheckImagesOutputPackageModel
     */
    'binpkg_name'?: string;
    /**
     * binary package architecture
     * @type {string}
     * @memberof CheckImagesOutputPackageModel
     */
    'binpkg_arch'?: string;
}
/**
 * 
 * @export
 * @interface CveTaskPackageVulnerableElementModel
 */
export interface CveTaskPackageVulnerableElementModel {
    /**
     * vulnerability id
     * @type {string}
     * @memberof CveTaskPackageVulnerableElementModel
     */
    'id'?: string;
    /**
     * vulnerability type
     * @type {string}
     * @memberof CveTaskPackageVulnerableElementModel
     */
    'type'?: string;
    /**
     * vulnerability link
     * @type {string}
     * @memberof CveTaskPackageVulnerableElementModel
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface CveTaskPackagesElementModel
 */
export interface CveTaskPackagesElementModel {
    /**
     * subtasks id
     * @type {number}
     * @memberof CveTaskPackagesElementModel
     */
    'subtask'?: number;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof CveTaskPackagesElementModel
     */
    'pkghash'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof CveTaskPackagesElementModel
     */
    'pkg_name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof CveTaskPackagesElementModel
     */
    'pkg_version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof CveTaskPackagesElementModel
     */
    'pkg_release'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof CveTaskPackagesElementModel
     */
    'branch'?: string;
    /**
     * errata id
     * @type {string}
     * @memberof CveTaskPackagesElementModel
     */
    'errata_id'?: string;
    /**
     * errata link to errata.altlinux.org
     * @type {string}
     * @memberof CveTaskPackagesElementModel
     */
    'errata_link'?: string;
    /**
     * fixed vulnerabilities list
     * @type {Array<CveTaskPackageVulnerableElementModel>}
     * @memberof CveTaskPackagesElementModel
     */
    'vulnerabilities'?: Array<CveTaskPackageVulnerableElementModel>;
}
/**
 * 
 * @export
 * @interface CveVulnerableTaskModel
 */
export interface CveVulnerableTaskModel {
    /**
     * vulnerable packages information
     * @type {Array<CveTaskPackagesElementModel>}
     * @memberof CveVulnerableTaskModel
     */
    'packages'?: Array<CveTaskPackagesElementModel>;
}
/**
 * 
 * @export
 * @interface DependenciesAllPackagasetsElementModel
 */
export interface DependenciesAllPackagasetsElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof DependenciesAllPackagasetsElementModel
     */
    'branch'?: string;
    /**
     * number of source packages
     * @type {number}
     * @memberof DependenciesAllPackagasetsElementModel
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface DependenciesPackageBuildDependenciesModel
 */
export interface DependenciesPackageBuildDependenciesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof DependenciesPackageBuildDependenciesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof DependenciesPackageBuildDependenciesModel
     */
    'length'?: number;
    /**
     * source package info
     * @type {PackageInfoModel}
     * @memberof DependenciesPackageBuildDependenciesModel
     */
    'package_info'?: PackageInfoModel;
    /**
     * package dependencies list
     * @type {Array<DependenciesPackageDependenciesElementModel>}
     * @memberof DependenciesPackageBuildDependenciesModel
     */
    'dependencies'?: Array<DependenciesPackageDependenciesElementModel>;
    /**
     * list of source packages of binary packages that provides required dependencies
     * @type {Array<DependenciesPackageInfoElementModel>}
     * @memberof DependenciesPackageBuildDependenciesModel
     */
    'provided_by_src'?: Array<DependenciesPackageInfoElementModel>;
}
/**
 * 
 * @export
 * @interface DependenciesPackageDependenciesElementModel
 */
export interface DependenciesPackageDependenciesElementModel {
    /**
     * the name of the dependent package
     * @type {string}
     * @memberof DependenciesPackageDependenciesElementModel
     */
    'name'?: string;
    /**
     * the version of the dependent package
     * @type {string}
     * @memberof DependenciesPackageDependenciesElementModel
     */
    'version'?: string;
    /**
     * dependency type
     * @type {string}
     * @memberof DependenciesPackageDependenciesElementModel
     */
    'type'?: string;
    /**
     * dependency flag
     * @type {number}
     * @memberof DependenciesPackageDependenciesElementModel
     */
    'flag'?: number;
    /**
     * decoded dependency flag
     * @type {Array<string>}
     * @memberof DependenciesPackageDependenciesElementModel
     */
    'flag_decoded'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DependenciesPackageDependenciesModel
 */
export interface DependenciesPackageDependenciesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof DependenciesPackageDependenciesModel
     */
    'request_args'?: object;
    /**
     * number of dependencies found
     * @type {number}
     * @memberof DependenciesPackageDependenciesModel
     */
    'length'?: number;
    /**
     * package dependencies list
     * @type {Array<DependenciesPackageDependenciesElementModel>}
     * @memberof DependenciesPackageDependenciesModel
     */
    'dependencies'?: Array<DependenciesPackageDependenciesElementModel>;
}
/**
 * 
 * @export
 * @interface DependenciesPackageInfoElementModel
 */
export interface DependenciesPackageInfoElementModel {
    /**
     * package name
     * @type {string}
     * @memberof DependenciesPackageInfoElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof DependenciesPackageInfoElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof DependenciesPackageInfoElementModel
     */
    'release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof DependenciesPackageInfoElementModel
     */
    'summary'?: string;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof DependenciesPackageInfoElementModel
     */
    'pkghash'?: string;
}
/**
 * 
 * @export
 * @interface DependenciesPackagesElementModel
 */
export interface DependenciesPackagesElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof DependenciesPackagesElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof DependenciesPackagesElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof DependenciesPackagesElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof DependenciesPackagesElementModel
     */
    'release'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof DependenciesPackagesElementModel
     */
    'arch'?: string;
    /**
     * package type
     * @type {number}
     * @memberof DependenciesPackagesElementModel
     */
    'sourcepackage'?: number;
    /**
     * package summary
     * @type {string}
     * @memberof DependenciesPackagesElementModel
     */
    'summary'?: string;
    /**
     * package buildtime
     * @type {number}
     * @memberof DependenciesPackagesElementModel
     */
    'buildtime'?: number;
    /**
     * package category
     * @type {string}
     * @memberof DependenciesPackagesElementModel
     */
    'category'?: string;
    /**
     * package maintainer
     * @type {string}
     * @memberof DependenciesPackagesElementModel
     */
    'maintainer'?: string;
    /**
     * list of dependency types
     * @type {Array<string>}
     * @memberof DependenciesPackagesElementModel
     */
    'dp_types'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DependenciesPackagesModel
 */
export interface DependenciesPackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof DependenciesPackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof DependenciesPackagesModel
     */
    'length'?: number;
    /**
     * package dependencies list
     * @type {Array<DependenciesPackagesElementModel>}
     * @memberof DependenciesPackagesModel
     */
    'packages'?: Array<DependenciesPackagesElementModel>;
    /**
     * list of package sets with binary package count
     * @type {Array<DependenciesAllPackagasetsElementModel>}
     * @memberof DependenciesPackagesModel
     */
    'branches'?: Array<DependenciesAllPackagasetsElementModel>;
}
/**
 * 
 * @export
 * @interface ErrataBranchUpdateModel
 */
export interface ErrataBranchUpdateModel {
    /**
     * errata id
     * @type {string}
     * @memberof ErrataBranchUpdateModel
     */
    'id'?: string;
    /**
     * errata type
     * @type {string}
     * @memberof ErrataBranchUpdateModel
     */
    'type'?: string;
    /**
     * packageset name
     * @type {string}
     * @memberof ErrataBranchUpdateModel
     */
    'pkgset_name'?: string;
    /**
     * packageset date
     * @type {string}
     * @memberof ErrataBranchUpdateModel
     */
    'pkgset_date'?: string;
    /**
     * list of packages updates
     * @type {Array<ErrataPackageUpdateModel>}
     * @memberof ErrataBranchUpdateModel
     */
    'packages_updates'?: Array<ErrataPackageUpdateModel>;
}
/**
 * 
 * @export
 * @interface ErrataBranchesModel
 */
export interface ErrataBranchesModel {
    /**
     * number of branches
     * @type {number}
     * @memberof ErrataBranchesModel
     */
    'length'?: number;
    /**
     * list of branches
     * @type {Array<string>}
     * @memberof ErrataBranchesModel
     */
    'branches'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ErrataBranchesUpdatesModel
 */
export interface ErrataBranchesUpdatesModel {
    /**
     * list of branch updates
     * @type {Array<ErrataBranchUpdateModel>}
     * @memberof ErrataBranchesUpdatesModel
     */
    'branches_updates'?: Array<ErrataBranchUpdateModel>;
}
/**
 * 
 * @export
 * @interface ErrataBugModel
 */
export interface ErrataBugModel {
    /**
     * bug id
     * @type {number}
     * @memberof ErrataBugModel
     */
    'id'?: number;
    /**
     * bug summary
     * @type {string}
     * @memberof ErrataBugModel
     */
    'summary'?: string;
    /**
     * bug information is valid
     * @type {boolean}
     * @memberof ErrataBugModel
     */
    'is_valid'?: boolean;
}
/**
 * 
 * @export
 * @interface ErrataIdsListModel
 */
export interface ErrataIdsListModel {
    /**
     * errata ids list
     * @type {Array<string>}
     * @memberof ErrataIdsListModel
     */
    'errata_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ErrataJsonPostListModel
 */
export interface ErrataJsonPostListModel {
    /**
     * errata ids list
     * @type {Array<string>}
     * @memberof ErrataJsonPostListModel
     */
    'errata_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface ErrataLastChangedElementModel
 */
export interface ErrataLastChangedElementModel {
    /**
     * is errata discarded
     * @type {boolean}
     * @memberof ErrataLastChangedElementModel
     */
    'is_discarded'?: boolean;
    /**
     * errata ID
     * @type {string}
     * @memberof ErrataLastChangedElementModel
     */
    'errata_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrataLastChangedElementModel
     */
    'eh_type'?: string;
    /**
     * task ID
     * @type {number}
     * @memberof ErrataLastChangedElementModel
     */
    'task_id'?: number;
    /**
     * changed
     * @type {string}
     * @memberof ErrataLastChangedElementModel
     */
    'changed'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof ErrataLastChangedElementModel
     */
    'branch'?: string;
    /**
     * affected packages
     * @type {Array<PackagesElementModel>}
     * @memberof ErrataLastChangedElementModel
     */
    'packages'?: Array<PackagesElementModel>;
    /**
     * fixed vulnerabilities list
     * @type {Array<VulnerabilitiesElementModel>}
     * @memberof ErrataLastChangedElementModel
     */
    'vulnerabilities'?: Array<VulnerabilitiesElementModel>;
}
/**
 * 
 * @export
 * @interface ErrataLastChangedModel
 */
export interface ErrataLastChangedModel {
    /**
     * request arguments
     * @type {object}
     * @memberof ErrataLastChangedModel
     */
    'request_args'?: object;
    /**
     * number of erratas
     * @type {number}
     * @memberof ErrataLastChangedModel
     */
    'length'?: number;
    /**
     * erratas last changed
     * @type {Array<ErrataLastChangedElementModel>}
     * @memberof ErrataLastChangedModel
     */
    'erratas'?: Array<ErrataLastChangedElementModel>;
}
/**
 * 
 * @export
 * @interface ErrataModel
 */
export interface ErrataModel {
    /**
     * errata id
     * @type {string}
     * @memberof ErrataModel
     */
    'id'?: string;
    /**
     * errata type
     * @type {string}
     * @memberof ErrataModel
     */
    'type'?: string;
    /**
     * errata created date
     * @type {string}
     * @memberof ErrataModel
     */
    'created'?: string;
    /**
     * errata updated date
     * @type {string}
     * @memberof ErrataModel
     */
    'updated'?: string;
    /**
     * packageset name
     * @type {string}
     * @memberof ErrataModel
     */
    'pkgset_name'?: string;
    /**
     * task id
     * @type {number}
     * @memberof ErrataModel
     */
    'task_id'?: number;
    /**
     * subtask id
     * @type {number}
     * @memberof ErrataModel
     */
    'subtask_id'?: number;
    /**
     * task state
     * @type {string}
     * @memberof ErrataModel
     */
    'task_state'?: string;
    /**
     * package hash
     * @type {string}
     * @memberof ErrataModel
     */
    'pkg_hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof ErrataModel
     */
    'pkg_name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof ErrataModel
     */
    'pkg_version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof ErrataModel
     */
    'pkg_release'?: string;
    /**
     * list of references
     * @type {Array<ErrataReferenceModel>}
     * @memberof ErrataModel
     */
    'references'?: Array<ErrataReferenceModel>;
}
/**
 * 
 * @export
 * @interface ErrataPackageUpdateModel
 */
export interface ErrataPackageUpdateModel {
    /**
     * errata id
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'id'?: string;
    /**
     * errata type
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'type'?: string;
    /**
     * errata created date
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'created'?: string;
    /**
     * errata updated date
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'updated'?: string;
    /**
     * packageset name
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'pkgset_name'?: string;
    /**
     * task id
     * @type {number}
     * @memberof ErrataPackageUpdateModel
     */
    'task_id'?: number;
    /**
     * subtask id
     * @type {number}
     * @memberof ErrataPackageUpdateModel
     */
    'subtask_id'?: number;
    /**
     * task state
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'task_state'?: string;
    /**
     * package hash
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'pkg_hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'pkg_name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'pkg_version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof ErrataPackageUpdateModel
     */
    'pkg_release'?: string;
    /**
     * list of bugs
     * @type {Array<ErrataBugModel>}
     * @memberof ErrataPackageUpdateModel
     */
    'bugs'?: Array<ErrataBugModel>;
    /**
     * list of vulnerabilities
     * @type {Array<ErrataVulnerabilityModel>}
     * @memberof ErrataPackageUpdateModel
     */
    'vulns'?: Array<ErrataVulnerabilityModel>;
}
/**
 * 
 * @export
 * @interface ErrataPackagesUpdatesModel
 */
export interface ErrataPackagesUpdatesModel {
    /**
     * list of packages updates
     * @type {Array<ErrataPackageUpdateModel>}
     * @memberof ErrataPackagesUpdatesModel
     */
    'packages_updates'?: Array<ErrataPackageUpdateModel>;
}
/**
 * 
 * @export
 * @interface ErrataReferenceModel
 */
export interface ErrataReferenceModel {
    /**
     * errata id
     * @type {string}
     * @memberof ErrataReferenceModel
     */
    'id'?: string;
    /**
     * errata type
     * @type {string}
     * @memberof ErrataReferenceModel
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ErrataVulnerabilityModel
 */
export interface ErrataVulnerabilityModel {
    /**
     * vulnerability id
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'id'?: string;
    /**
     * vulnerability hash
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'hash'?: string;
    /**
     * vulnerability type
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'type'?: string;
    /**
     * vulnerability summary
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'summary'?: string;
    /**
     * vulnerability score
     * @type {number}
     * @memberof ErrataVulnerabilityModel
     */
    'score'?: number;
    /**
     * vulnerability severity
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'severity'?: string;
    /**
     * vulnerability url
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'url'?: string;
    /**
     * vulnerability modified date
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'modified_date'?: string;
    /**
     * vulnerability published date
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'published_date'?: string;
    /**
     * vulnerability body in JSON format
     * @type {string}
     * @memberof ErrataVulnerabilityModel
     */
    'body'?: string;
    /**
     * vulnerability information is valid
     * @type {boolean}
     * @memberof ErrataVulnerabilityModel
     */
    'is_valid'?: boolean;
}
/**
 * 
 * @export
 * @interface ErratasModel
 */
export interface ErratasModel {
    /**
     * list of erratas
     * @type {Array<ErrataModel>}
     * @memberof ErratasModel
     */
    'erratas'?: Array<ErrataModel>;
}
/**
 * 
 * @export
 * @interface FastDependencySearchElementModel
 */
export interface FastDependencySearchElementModel {
    /**
     * the name of the dependent package
     * @type {string}
     * @memberof FastDependencySearchElementModel
     */
    'dp_name'?: string;
}
/**
 * 
 * @export
 * @interface FastDependencySearchModel
 */
export interface FastDependencySearchModel {
    /**
     * request arguments
     * @type {object}
     * @memberof FastDependencySearchModel
     */
    'request_args'?: object;
    /**
     * number of dependencies found
     * @type {number}
     * @memberof FastDependencySearchModel
     */
    'length'?: number;
    /**
     * dependency list
     * @type {Array<FastDependencySearchElementModel>}
     * @memberof FastDependencySearchModel
     */
    'dependencies'?: Array<FastDependencySearchElementModel>;
}
/**
 * 
 * @export
 * @interface FastFileSearchElementModel
 */
export interface FastFileSearchElementModel {
    /**
     * file name
     * @type {string}
     * @memberof FastFileSearchElementModel
     */
    'file_name'?: string;
}
/**
 * 
 * @export
 * @interface FastFileSearchModel
 */
export interface FastFileSearchModel {
    /**
     * request arguments
     * @type {object}
     * @memberof FastFileSearchModel
     */
    'request_args'?: object;
    /**
     * number of files found
     * @type {number}
     * @memberof FastFileSearchModel
     */
    'length'?: number;
    /**
     * file list
     * @type {Array<FastFileSearchElementModel>}
     * @memberof FastFileSearchModel
     */
    'files'?: Array<FastFileSearchElementModel>;
}
/**
 * 
 * @export
 * @interface FilePackagesByFileElementModel
 */
export interface FilePackagesByFileElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof FilePackagesByFileElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof FilePackagesByFileElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof FilePackagesByFileElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof FilePackagesByFileElementModel
     */
    'release'?: string;
    /**
     * package architecture
     * @type {string}
     * @memberof FilePackagesByFileElementModel
     */
    'arch'?: string;
}
/**
 * 
 * @export
 * @interface FilePackagesByFileModel
 */
export interface FilePackagesByFileModel {
    /**
     * request arguments
     * @type {object}
     * @memberof FilePackagesByFileModel
     */
    'request_args'?: object;
    /**
     * number of package found
     * @type {number}
     * @memberof FilePackagesByFileModel
     */
    'length'?: number;
    /**
     * package list
     * @type {Array<FilePackagesByFileElementModel>}
     * @memberof FilePackagesByFileModel
     */
    'packages'?: Array<FilePackagesByFileElementModel>;
}
/**
 * 
 * @export
 * @interface FilesElementModel
 */
export interface FilesElementModel {
    /**
     * file name
     * @type {string}
     * @memberof FilesElementModel
     */
    'file_name'?: string;
    /**
     * hash from the filename
     * @type {string}
     * @memberof FilesElementModel
     */
    'file_hashname'?: string;
    /**
     * file class
     * @type {string}
     * @memberof FilesElementModel
     */
    'file_class'?: string;
    /**
     * link path
     * @type {string}
     * @memberof FilesElementModel
     */
    'symlink'?: string;
    /**
     * file permissions string representation
     * @type {string}
     * @memberof FilesElementModel
     */
    'file_mode'?: string;
}
/**
 * 
 * @export
 * @interface FilesModel
 */
export interface FilesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof FilesModel
     */
    'request_args'?: object;
    /**
     * number of files found
     * @type {number}
     * @memberof FilesModel
     */
    'length'?: number;
    /**
     * file list
     * @type {Array<FilesElementModel>}
     * @memberof FilesModel
     */
    'files'?: Array<FilesElementModel>;
}
/**
 * 
 * @export
 * @interface FindImagesByPackageElementModel
 */
export interface FindImagesByPackageElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'pkghash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'name'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'branch'?: string;
    /**
     * package version
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'release'?: string;
    /**
     * package architecture
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'arch'?: string;
    /**
     * Image edition
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'edition'?: string;
    /**
     * Image package set tag
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'tag'?: string;
    /**
     * Image file name
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'file'?: string;
    /**
     * Image package set date
     * @type {string}
     * @memberof FindImagesByPackageElementModel
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface FindImagesByPackageModel
 */
export interface FindImagesByPackageModel {
    /**
     * request arguments
     * @type {object}
     * @memberof FindImagesByPackageModel
     */
    'request_args'?: object;
    /**
     * number of images found
     * @type {number}
     * @memberof FindImagesByPackageModel
     */
    'length'?: number;
    /**
     * list of found images
     * @type {Array<FindImagesByPackageElementModel>}
     * @memberof FindImagesByPackageModel
     */
    'images'?: Array<FindImagesByPackageElementModel>;
}
/**
 * 
 * @export
 * @interface FindImagesByTaskImageElementModel
 */
export interface FindImagesByTaskImageElementModel {
    /**
     * image filename
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'filename'?: string;
    /**
     * image edition
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'edition'?: string;
    /**
     * image tag
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'tag'?: string;
    /**
     * image built date in ISO8601 format
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'buildtime'?: string;
    /**
     * image\'s binary package name
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'binpkg_name'?: string;
    /**
     * image\'s binary package version
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'binpkg_version'?: string;
    /**
     * image\'s binary package release
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'binpkg_release'?: string;
    /**
     * image\'s binary package architecture
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'binpkg_arch'?: string;
    /**
     * image\'s binary package hash
     * @type {string}
     * @memberof FindImagesByTaskImageElementModel
     */
    'binpkg_hash'?: string;
}
/**
 * 
 * @export
 * @interface FindImagesByTaskIterationElementModel
 */
export interface FindImagesByTaskIterationElementModel {
    /**
     * task try
     * @type {number}
     * @memberof FindImagesByTaskIterationElementModel
     */
    'task_try'?: number;
    /**
     * task iter
     * @type {number}
     * @memberof FindImagesByTaskIterationElementModel
     */
    'task_iter'?: number;
}
/**
 * 
 * @export
 * @interface FindImagesByTaskModel
 */
export interface FindImagesByTaskModel {
    /**
     * task id
     * @type {number}
     * @memberof FindImagesByTaskModel
     */
    'task_id'?: number;
    /**
     * task state
     * @type {string}
     * @memberof FindImagesByTaskModel
     */
    'task_state'?: string;
    /**
     * task is test-only
     * @type {number}
     * @memberof FindImagesByTaskModel
     */
    'task_testonly'?: number;
    /**
     * task repo
     * @type {string}
     * @memberof FindImagesByTaskModel
     */
    'task_repo'?: string;
    /**
     * task owner
     * @type {string}
     * @memberof FindImagesByTaskModel
     */
    'task_owner'?: string;
    /**
     * task try
     * @type {number}
     * @memberof FindImagesByTaskModel
     */
    'task_try'?: number;
    /**
     * task iter
     * @type {number}
     * @memberof FindImagesByTaskModel
     */
    'task_iter'?: number;
    /**
     * task message
     * @type {string}
     * @memberof FindImagesByTaskModel
     */
    'task_message'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindImagesByTaskModel
     */
    'task_changed'?: string;
    /**
     * task dependencies
     * @type {Array<number>}
     * @memberof FindImagesByTaskModel
     */
    'dependencies'?: Array<number>;
    /**
     * subtasks
     * @type {Array<FindImagesByTaskSubtaskElementModel>}
     * @memberof FindImagesByTaskModel
     */
    'subtasks'?: Array<FindImagesByTaskSubtaskElementModel>;
    /**
     * 
     * @type {Array<FindImagesByTaskIterationElementModel>}
     * @memberof FindImagesByTaskModel
     */
    'iterations'?: Array<FindImagesByTaskIterationElementModel>;
}
/**
 * 
 * @export
 * @interface FindImagesByTaskSubtaskElementModel
 */
export interface FindImagesByTaskSubtaskElementModel {
    /**
     * subtask id
     * @type {number}
     * @memberof FindImagesByTaskSubtaskElementModel
     */
    'id'?: number;
    /**
     * subtask type
     * @type {string}
     * @memberof FindImagesByTaskSubtaskElementModel
     */
    'type'?: string;
    /**
     * subtask srpm name
     * @type {string}
     * @memberof FindImagesByTaskSubtaskElementModel
     */
    'srpm_name'?: string;
    /**
     * subtask srpm hash
     * @type {string}
     * @memberof FindImagesByTaskSubtaskElementModel
     */
    'srpm_hash'?: string;
    /**
     * subtask\'s source package version
     * @type {string}
     * @memberof FindImagesByTaskSubtaskElementModel
     */
    'pkg_version'?: string;
    /**
     * subtask\'s source package release
     * @type {string}
     * @memberof FindImagesByTaskSubtaskElementModel
     */
    'pkg_release'?: string;
    /**
     * affected images (by binary packages)
     * @type {Array<FindImagesByTaskImageElementModel>}
     * @memberof FindImagesByTaskSubtaskElementModel
     */
    'images'?: Array<FindImagesByTaskImageElementModel>;
}
/**
 * 
 * @export
 * @interface FindSourcePackageInBranch
 */
export interface FindSourcePackageInBranch {
    /**
     * request arguments
     * @type {object}
     * @memberof FindSourcePackageInBranch
     */
    'request_args'?: object;
    /**
     * source package name
     * @type {string}
     * @memberof FindSourcePackageInBranch
     */
    'source_package'?: string;
}
/**
 * 
 * @export
 * @interface FindTasksElementModel
 */
export interface FindTasksElementModel {
    /**
     * task id
     * @type {number}
     * @memberof FindTasksElementModel
     */
    'task_id'?: number;
    /**
     * task owner
     * @type {string}
     * @memberof FindTasksElementModel
     */
    'task_owner'?: string;
    /**
     * task state
     * @type {string}
     * @memberof FindTasksElementModel
     */
    'task_state'?: string;
    /**
     * repository name
     * @type {string}
     * @memberof FindTasksElementModel
     */
    'task_repo'?: string;
    /**
     * task components
     * @type {Array<string>}
     * @memberof FindTasksElementModel
     */
    'components'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FindTasksModel
 */
export interface FindTasksModel {
    /**
     * request arguments
     * @type {object}
     * @memberof FindTasksModel
     */
    'request_args'?: object;
    /**
     * number of tasks found
     * @type {number}
     * @memberof FindTasksModel
     */
    'length'?: number;
    /**
     * list of found tasks
     * @type {Array<FindTasksElementModel>}
     * @memberof FindTasksModel
     */
    'tasks'?: Array<FindTasksElementModel>;
}
/**
 * 
 * @export
 * @interface ImageAllISOElementModel
 */
export interface ImageAllISOElementModel {
    /**
     * ISO image base branch
     * @type {string}
     * @memberof ImageAllISOElementModel
     */
    'branch'?: string;
    /**
     * ISO image package set name
     * @type {string}
     * @memberof ImageAllISOElementModel
     */
    'name'?: string;
    /**
     * ISO image package set tag
     * @type {string}
     * @memberof ImageAllISOElementModel
     */
    'tag'?: string;
    /**
     * ISO image file name
     * @type {string}
     * @memberof ImageAllISOElementModel
     */
    'file'?: string;
    /**
     * ISO image package set date
     * @type {string}
     * @memberof ImageAllISOElementModel
     */
    'date'?: string;
    /**
     * ISO image package set UUID
     * @type {string}
     * @memberof ImageAllISOElementModel
     */
    'uuid'?: string;
}
/**
 * 
 * @export
 * @interface ImageAllISOModel
 */
export interface ImageAllISOModel {
    /**
     * number of ISO images
     * @type {number}
     * @memberof ImageAllISOModel
     */
    'length'?: number;
    /**
     * list of ISO images package sets information
     * @type {Array<ImageAllISOElementModel>}
     * @memberof ImageAllISOModel
     */
    'images'?: Array<ImageAllISOElementModel>;
}
/**
 * 
 * @export
 * @interface ImageErrataElementModel
 */
export interface ImageErrataElementModel {
    /**
     * package hash UInt64 as string in the image
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'img_hash'?: string;
    /**
     * package version in the image
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'img_version'?: string;
    /**
     * package release in the image
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'img_release'?: string;
    /**
     * binary package name
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'pkg_name'?: string;
    /**
     * package architecture in the repository
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'pkg_arch'?: string;
    /**
     * package hash UInt64 as string in the repository
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'pkg_hash'?: string;
    /**
     * package version in the repository
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'pkg_version'?: string;
    /**
     * package release in the repository
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'pkg_release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'summary'?: string;
    /**
     * errata ID
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'errata_id'?: string;
    /**
     * errata type
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'eh_type'?: string;
    /**
     * task ID
     * @type {number}
     * @memberof ImageErrataElementModel
     */
    'task_id'?: number;
    /**
     * changed
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'changed'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof ImageErrataElementModel
     */
    'branch'?: string;
    /**
     * is errata discarded
     * @type {boolean}
     * @memberof ImageErrataElementModel
     */
    'is_discarded'?: boolean;
    /**
     * fixed vulnerabilities list
     * @type {Array<VulnerabilitiesElementModel>}
     * @memberof ImageErrataElementModel
     */
    'vulnerabilities'?: Array<VulnerabilitiesElementModel>;
}
/**
 * 
 * @export
 * @interface ImageErrataModel
 */
export interface ImageErrataModel {
    /**
     * request arguments
     * @type {object}
     * @memberof ImageErrataModel
     */
    'request_args'?: object;
    /**
     * number of erratas
     * @type {number}
     * @memberof ImageErrataModel
     */
    'length'?: number;
    /**
     * image errata list
     * @type {Array<ImageErrataElementModel>}
     * @memberof ImageErrataModel
     */
    'erratas'?: Array<ImageErrataElementModel>;
}
/**
 * 
 * @export
 * @interface ImageInfoComponentModel
 */
export interface ImageInfoComponentModel {
    /**
     * Component name
     * @type {string}
     * @memberof ImageInfoComponentModel
     */
    'name'?: string;
    /**
     * Component size (human readable)
     * @type {string}
     * @memberof ImageInfoComponentModel
     */
    'size'?: string;
    /**
     * Component packages count
     * @type {number}
     * @memberof ImageInfoComponentModel
     */
    'packages'?: number;
    /**
     * Component package set UUID
     * @type {string}
     * @memberof ImageInfoComponentModel
     */
    'uuid'?: string;
    /**
     * Component package set root UUID
     * @type {string}
     * @memberof ImageInfoComponentModel
     */
    'ruuid'?: string;
    /**
     * Component metadata
     * @type {object}
     * @memberof ImageInfoComponentModel
     */
    'kv'?: object;
}
/**
 * 
 * @export
 * @interface ImageInfoElementModel
 */
export interface ImageInfoElementModel {
    /**
     * Image package set date
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'date'?: string;
    /**
     * Image package set UUID
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'uuid'?: string;
    /**
     * Image package set tag
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'tag'?: string;
    /**
     * Image base branch
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'branch'?: string;
    /**
     * Image edition
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'edition'?: string;
    /**
     * Image flavor
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'flavor'?: string;
    /**
     * Image platform
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'platform'?: string;
    /**
     * Image release type
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'release'?: string;
    /**
     * Image version major
     * @type {number}
     * @memberof ImageInfoElementModel
     */
    'version_major'?: number;
    /**
     * Image version minor
     * @type {number}
     * @memberof ImageInfoElementModel
     */
    'version_minor'?: number;
    /**
     * Image version sub
     * @type {number}
     * @memberof ImageInfoElementModel
     */
    'version_sub'?: number;
    /**
     * Image architecture
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'arch'?: string;
    /**
     * Image variant
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'variant'?: string;
    /**
     * Image type
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'type'?: string;
    /**
     * Image file name
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'file'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImageInfoElementModel
     */
    'url'?: Array<string>;
    /**
     * Image MD5 checksum
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'md5sum'?: string;
    /**
     * Image GOST12 checksum
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'gost12sum'?: string;
    /**
     * Image SHA256 checksum
     * @type {string}
     * @memberof ImageInfoElementModel
     */
    'sha256sum'?: string;
    /**
     * list of image components information
     * @type {Array<ImageInfoComponentModel>}
     * @memberof ImageInfoElementModel
     */
    'components'?: Array<ImageInfoComponentModel>;
}
/**
 * 
 * @export
 * @interface ImageInfoModel
 */
export interface ImageInfoModel {
    /**
     * request arguments
     * @type {object}
     * @memberof ImageInfoModel
     */
    'request_args'?: object;
    /**
     * number of images
     * @type {number}
     * @memberof ImageInfoModel
     */
    'length'?: number;
    /**
     * list of images information
     * @type {Array<ImageInfoElementModel>}
     * @memberof ImageInfoModel
     */
    'images'?: Array<ImageInfoElementModel>;
}
/**
 * 
 * @export
 * @interface ImageJSONElementModel
 */
export interface ImageJSONElementModel {
    /**
     * ISO image edition
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_edition': string;
    /**
     * ISO image name
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_name': string;
    /**
     * hide - hide image, show - show image
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_show': string;
    /**
     * image summary in Russian
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_summary_ru'?: string;
    /**
     * image summary in English
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_summary_en'?: string;
    /**
     * support start date
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_start_date': string;
    /**
     * support end date
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_end_date': string;
    /**
     * link to mailing list
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_mailing_list'?: string;
    /**
     * image name for bugzilla
     * @type {string}
     * @memberof ImageJSONElementModel
     */
    'img_name_bugzilla'?: string;
    /**
     * image mirror\'s auxilary info as JSON substructure
     * @type {object}
     * @memberof ImageJSONElementModel
     */
    'img_json': object;
}
/**
 * 
 * @export
 * @interface ImageJSONModel
 */
export interface ImageJSONModel {
    /**
     * image base branch
     * @type {string}
     * @memberof ImageJSONModel
     */
    'img_branch': string;
    /**
     * html description in Russian in Base64 format
     * @type {string}
     * @memberof ImageJSONModel
     */
    'img_description_ru'?: string;
    /**
     * html description in English in Base64 format
     * @type {string}
     * @memberof ImageJSONModel
     */
    'img_description_en'?: string;
    /**
     * image info
     * @type {Array<ImageJSONElementModel>}
     * @memberof ImageJSONModel
     */
    'images'?: Array<ImageJSONElementModel>;
}
/**
 * 
 * @export
 * @interface ImagePackageSetModel
 */
export interface ImagePackageSetModel {
    /**
     * number of packagesets found
     * @type {number}
     * @memberof ImagePackageSetModel
     */
    'length'?: number;
    /**
     * list of packagesets
     * @type {Array<string>}
     * @memberof ImagePackageSetModel
     */
    'branches'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ImagePackagesElement1Model
 */
export interface ImagePackagesElement1Model {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof ImagePackagesElement1Model
     */
    'hash'?: string;
    /**
     * package architecture
     * @type {string}
     * @memberof ImagePackagesElement1Model
     */
    'arch'?: string;
    /**
     * package name
     * @type {string}
     * @memberof ImagePackagesElement1Model
     */
    'name'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof ImagePackagesElement1Model
     */
    'epoch'?: number;
    /**
     * package version
     * @type {string}
     * @memberof ImagePackagesElement1Model
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof ImagePackagesElement1Model
     */
    'release'?: string;
    /**
     * package disttag
     * @type {string}
     * @memberof ImagePackagesElement1Model
     */
    'disttag'?: string;
    /**
     * package build time
     * @type {number}
     * @memberof ImagePackagesElement1Model
     */
    'buildtime'?: number;
}
/**
 * 
 * @export
 * @interface ImagePackagesElement2Model
 */
export interface ImagePackagesElement2Model {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof ImagePackagesElement2Model
     */
    'hash'?: string;
    /**
     * package architecture
     * @type {string}
     * @memberof ImagePackagesElement2Model
     */
    'arch'?: string;
    /**
     * package name
     * @type {string}
     * @memberof ImagePackagesElement2Model
     */
    'name'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof ImagePackagesElement2Model
     */
    'epoch'?: number;
    /**
     * package version
     * @type {string}
     * @memberof ImagePackagesElement2Model
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof ImagePackagesElement2Model
     */
    'release'?: string;
    /**
     * package disttag
     * @type {string}
     * @memberof ImagePackagesElement2Model
     */
    'disttag'?: string;
    /**
     * package build time
     * @type {number}
     * @memberof ImagePackagesElement2Model
     */
    'buildtime'?: number;
    /**
     * build task id
     * @type {number}
     * @memberof ImagePackagesElement2Model
     */
    'task_id'?: number;
    /**
     * build task subtask id
     * @type {number}
     * @memberof ImagePackagesElement2Model
     */
    'subtask_id'?: number;
}
/**
 * 
 * @export
 * @interface ImagePackagesElementModel
 */
export interface ImagePackagesElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof ImagePackagesElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof ImagePackagesElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof ImagePackagesElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof ImagePackagesElementModel
     */
    'release'?: string;
    /**
     * package architecture
     * @type {string}
     * @memberof ImagePackagesElementModel
     */
    'arch'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof ImagePackagesElementModel
     */
    'summary'?: string;
    /**
     * last binary package buildtime
     * @type {number}
     * @memberof ImagePackagesElementModel
     */
    'buildtime'?: number;
    /**
     * package last changelog message
     * @type {string}
     * @memberof ImagePackagesElementModel
     */
    'changelog_text'?: string;
}
/**
 * 
 * @export
 * @interface ImagePackagesInspectRegularModel
 */
export interface ImagePackagesInspectRegularModel {
    /**
     * request arguments
     * @type {object}
     * @memberof ImagePackagesInspectRegularModel
     */
    'request_args'?: object;
    /**
     * number of input packages
     * @type {number}
     * @memberof ImagePackagesInspectRegularModel
     */
    'input_pakages'?: number;
    /**
     * number of packages not found in branch
     * @type {number}
     * @memberof ImagePackagesInspectRegularModel
     */
    'not_in_branch'?: number;
    /**
     * number of packages found in build tasks
     * @type {number}
     * @memberof ImagePackagesInspectRegularModel
     */
    'found_in_tasks'?: number;
    /**
     * number of packages not found in database
     * @type {number}
     * @memberof ImagePackagesInspectRegularModel
     */
    'not_found_in_db'?: number;
    /**
     * list of packages that not in branch but found in build tasks
     * @type {Array<ImagePackagesElement2Model>}
     * @memberof ImagePackagesInspectRegularModel
     */
    'packages_in_tasks'?: Array<ImagePackagesElement2Model>;
    /**
     * list of packages that not found in database
     * @type {Array<ImagePackagesElement1Model>}
     * @memberof ImagePackagesInspectRegularModel
     */
    'packages_not_in_db'?: Array<ImagePackagesElement1Model>;
}
/**
 * 
 * @export
 * @interface ImagePackagesInspectSPModel
 */
export interface ImagePackagesInspectSPModel {
    /**
     * request arguments
     * @type {object}
     * @memberof ImagePackagesInspectSPModel
     */
    'request_args'?: object;
    /**
     * number of input packages
     * @type {number}
     * @memberof ImagePackagesInspectSPModel
     */
    'input_pakages'?: number;
    /**
     * number of packages found in branch
     * @type {number}
     * @memberof ImagePackagesInspectSPModel
     */
    'in_branch'?: number;
    /**
     * number of packages not found in branch
     * @type {number}
     * @memberof ImagePackagesInspectSPModel
     */
    'not_in_branch'?: number;
    /**
     * number of packages found in build tasks
     * @type {number}
     * @memberof ImagePackagesInspectSPModel
     */
    'found_in_tasks'?: number;
    /**
     * number of packages not found in database
     * @type {number}
     * @memberof ImagePackagesInspectSPModel
     */
    'not_found_in_db'?: number;
    /**
     * list of packages with inspection results
     * @type {Array<ImagePackagesInspectSPPackageModel>}
     * @memberof ImagePackagesInspectSPModel
     */
    'packages'?: Array<ImagePackagesInspectSPPackageModel>;
}
/**
 * 
 * @export
 * @interface ImagePackagesInspectSPPackageModel
 */
export interface ImagePackagesInspectSPPackageModel {
    /**
     * package found in [branch|task|last branch]
     * @type {string}
     * @memberof ImagePackagesInspectSPPackageModel
     */
    'found_in'?: string;
    /**
     * package version compared with last branch state
     * @type {string}
     * @memberof ImagePackagesInspectSPPackageModel
     */
    'version_check'?: string;
    /**
     * package from image
     * @type {ImagePackagesElement1Model}
     * @memberof ImagePackagesInspectSPPackageModel
     */
    'image'?: ImagePackagesElement1Model;
    /**
     * matching package found in database by NEVRDA
     * @type {ImagePackagesElement1Model}
     * @memberof ImagePackagesInspectSPPackageModel
     */
    'database'?: ImagePackagesElement1Model;
    /**
     * package matched from last branch state by NA
     * @type {ImagePackagesElement1Model}
     * @memberof ImagePackagesInspectSPPackageModel
     */
    'last_branch'?: ImagePackagesElement1Model;
}
/**
 * 
 * @export
 * @interface ImagePackagesJSONElementModel
 */
export interface ImagePackagesJSONElementModel {
    /**
     * package hash
     * @type {string}
     * @memberof ImagePackagesJSONElementModel
     */
    'pkg_hash': string;
    /**
     * package name
     * @type {string}
     * @memberof ImagePackagesJSONElementModel
     */
    'pkg_name': string;
    /**
     * package epoch
     * @type {number}
     * @memberof ImagePackagesJSONElementModel
     */
    'pkg_epoch': number;
    /**
     * package version
     * @type {string}
     * @memberof ImagePackagesJSONElementModel
     */
    'pkg_version': string;
    /**
     * package release
     * @type {string}
     * @memberof ImagePackagesJSONElementModel
     */
    'pkg_release': string;
    /**
     * package architecture
     * @type {string}
     * @memberof ImagePackagesJSONElementModel
     */
    'pkg_arch': string;
    /**
     * package disttag
     * @type {string}
     * @memberof ImagePackagesJSONElementModel
     */
    'pkg_disttag': string;
    /**
     * package buildtime
     * @type {number}
     * @memberof ImagePackagesJSONElementModel
     */
    'pkg_buildtime': number;
}
/**
 * 
 * @export
 * @interface ImagePackagesJSONModel
 */
export interface ImagePackagesJSONModel {
    /**
     * image base branch
     * @type {string}
     * @memberof ImagePackagesJSONModel
     */
    'branch': string;
    /**
     * list of packages
     * @type {Array<ImagePackagesJSONElementModel>}
     * @memberof ImagePackagesJSONModel
     */
    'packages': Array<ImagePackagesJSONElementModel>;
}
/**
 * 
 * @export
 * @interface ImagePackagesModel
 */
export interface ImagePackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof ImagePackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof ImagePackagesModel
     */
    'length'?: number;
    /**
     * list of subcategories
     * @type {Array<string>}
     * @memberof ImagePackagesModel
     */
    'subcategories'?: Array<string>;
    /**
     * last packages list
     * @type {Array<ImagePackagesElementModel>}
     * @memberof ImagePackagesModel
     */
    'packages'?: Array<ImagePackagesElementModel>;
}
/**
 * 
 * @export
 * @interface ImageStatusGetElementModel
 */
export interface ImageStatusGetElementModel {
    /**
     * ISO image base branch
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'branch'?: string;
    /**
     * ISO image edition
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'edition'?: string;
    /**
     * ISO image name
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'name'?: string;
    /**
     * hide - hide image, show - show image
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'show'?: string;
    /**
     * support start date
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'start_date'?: string;
    /**
     * support end date
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'end_date'?: string;
    /**
     * image summary in Russian
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'summary_ru'?: string;
    /**
     * image summary in English
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'summary_en'?: string;
    /**
     * html description in Russian in Base64 format
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'description_ru'?: string;
    /**
     * html description in English in Base64 format
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'description_en'?: string;
    /**
     * link to mailing list
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'mailing_list'?: string;
    /**
     * image name for bugzilla
     * @type {string}
     * @memberof ImageStatusGetElementModel
     */
    'name_bugzilla'?: string;
    /**
     * image mirror\'s auxilary info as JSON substructure
     * @type {object}
     * @memberof ImageStatusGetElementModel
     */
    'json'?: object;
}
/**
 * 
 * @export
 * @interface ImageStatusGetModel
 */
export interface ImageStatusGetModel {
    /**
     * image info
     * @type {Array<ImageStatusGetElementModel>}
     * @memberof ImageStatusGetModel
     */
    'images'?: Array<ImageStatusGetElementModel>;
}
/**
 * 
 * @export
 * @interface ImageTagJSONElementModel
 */
export interface ImageTagJSONElementModel {
    /**
     * ISO image package set tag
     * @type {string}
     * @memberof ImageTagJSONElementModel
     */
    'img_tag': string;
    /**
     * hide - hide image, show - show image
     * @type {string}
     * @memberof ImageTagJSONElementModel
     */
    'img_show': string;
}
/**
 * 
 * @export
 * @interface ImageTagJSONModel
 */
export interface ImageTagJSONModel {
    /**
     * iso image info
     * @type {Array<ImageTagJSONElementModel>}
     * @memberof ImageTagJSONModel
     */
    'tags'?: Array<ImageTagJSONElementModel>;
}
/**
 * 
 * @export
 * @interface ImageTagStatusGetElementModel
 */
export interface ImageTagStatusGetElementModel {
    /**
     * ISO image package set tag
     * @type {string}
     * @memberof ImageTagStatusGetElementModel
     */
    'tag'?: string;
    /**
     * hide - hide image, show - show image
     * @type {string}
     * @memberof ImageTagStatusGetElementModel
     */
    'show'?: string;
}
/**
 * 
 * @export
 * @interface ImageTagStatusGetModel
 */
export interface ImageTagStatusGetModel {
    /**
     * image info
     * @type {Array<ImageTagStatusGetElementModel>}
     * @memberof ImageTagStatusGetModel
     */
    'tags'?: Array<ImageTagStatusGetElementModel>;
}
/**
 * 
 * @export
 * @interface ImageTagUUIDModel
 */
export interface ImageTagUUIDModel {
    /**
     * request arguments
     * @type {object}
     * @memberof ImageTagUUIDModel
     */
    'request_args'?: object;
    /**
     * Image package set UUID
     * @type {string}
     * @memberof ImageTagUUIDModel
     */
    'uuid'?: string;
    /**
     * ISO image file name
     * @type {string}
     * @memberof ImageTagUUIDModel
     */
    'file'?: string;
    /**
     * Image type
     * @type {string}
     * @memberof ImageTagUUIDModel
     */
    'type'?: string;
    /**
     * List of components for given tag
     * @type {object}
     * @memberof ImageTagUUIDModel
     */
    'components'?: object;
}
/**
 * 
 * @export
 * @interface LastImagePackagesElementModel
 */
export interface LastImagePackagesElementModel {
    /**
     * task id
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'task_id'?: string;
    /**
     * task changed date
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'task_changed'?: string;
    /**
     * task type [add|delete]
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'tplan_action'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'branch'?: string;
    /**
     * package hash UInt64 as string in the repository
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'name'?: string;
    /**
     * package version in the repository
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'version'?: string;
    /**
     * package release in the repository
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'release'?: string;
    /**
     * package architecture in the repository
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'arch'?: string;
    /**
     * package hash UInt64 as string in the image
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'img_hash'?: string;
    /**
     * package version in the image
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'img_version'?: string;
    /**
     * package release in the image
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'img_release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'summary'?: string;
    /**
     * package last changelog name
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'chlog_name'?: string;
    /**
     * maintainer nickname in the changelog
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'chlog_nick'?: string;
    /**
     * package last changelog message date
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'chlog_date'?: string;
    /**
     * package last changelog message
     * @type {string}
     * @memberof LastImagePackagesElementModel
     */
    'chlog_text'?: string;
}
/**
 * 
 * @export
 * @interface LastImagePackagesModel
 */
export interface LastImagePackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof LastImagePackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof LastImagePackagesModel
     */
    'length'?: number;
    /**
     * last packages list
     * @type {Array<LastImagePackagesElementModel>}
     * @memberof LastImagePackagesModel
     */
    'packages'?: Array<LastImagePackagesElementModel>;
}
/**
 * 
 * @export
 * @interface LicenseInfoModel
 */
export interface LicenseInfoModel {
    /**
     * 
     * @type {object}
     * @memberof LicenseInfoModel
     */
    'request_args'?: object;
    /**
     * SPDX license ID
     * @type {string}
     * @memberof LicenseInfoModel
     */
    'id'?: string;
    /**
     * SPDX license name
     * @type {string}
     * @memberof LicenseInfoModel
     */
    'name'?: string;
    /**
     * license text
     * @type {string}
     * @memberof LicenseInfoModel
     */
    'text'?: string;
    /**
     * license type
     * @type {string}
     * @memberof LicenseInfoModel
     */
    'type'?: string;
    /**
     * license header
     * @type {string}
     * @memberof LicenseInfoModel
     */
    'header'?: string;
    /**
     * license comment
     * @type {string}
     * @memberof LicenseInfoModel
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LicenseInfoModel
     */
    'urls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface LicenseTokensElementModel
 */
export interface LicenseTokensElementModel {
    /**
     * license token
     * @type {string}
     * @memberof LicenseTokensElementModel
     */
    'token'?: string;
    /**
     * SPDX license ID
     * @type {string}
     * @memberof LicenseTokensElementModel
     */
    'license'?: string;
}
/**
 * 
 * @export
 * @interface LicenseTokensModel
 */
export interface LicenseTokensModel {
    /**
     * 
     * @type {object}
     * @memberof LicenseTokensModel
     */
    'request_args'?: object;
    /**
     * number of tokens
     * @type {number}
     * @memberof LicenseTokensModel
     */
    'length'?: number;
    /**
     * list of found valid license tokens
     * @type {Array<LicenseTokensElementModel>}
     * @memberof LicenseTokensModel
     */
    'tokens'?: Array<LicenseTokensElementModel>;
}
/**
 * 
 * @export
 * @interface MaintainerBranchesModel
 */
export interface MaintainerBranchesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof MaintainerBranchesModel
     */
    'request_args'?: object;
    /**
     * number of maintainers found
     * @type {number}
     * @memberof MaintainerBranchesModel
     */
    'length'?: number;
    /**
     * all branches of the maintainer
     * @type {Array<SiteAllPackagasetsElementModel>}
     * @memberof MaintainerBranchesModel
     */
    'branches'?: Array<SiteAllPackagasetsElementModel>;
}
/**
 * 
 * @export
 * @interface MaintainerInfoModel
 */
export interface MaintainerInfoModel {
    /**
     * request arguments
     * @type {object}
     * @memberof MaintainerInfoModel
     */
    'request_args'?: object;
    /**
     * maintainers info
     * @type {AllMaintainersElementModel}
     * @memberof MaintainerInfoModel
     */
    'information'?: AllMaintainersElementModel;
}
/**
 * 
 * @export
 * @interface MaintainerPackagesElementModel
 */
export interface MaintainerPackagesElementModel {
    /**
     * package name
     * @type {string}
     * @memberof MaintainerPackagesElementModel
     */
    'name'?: string;
    /**
     * package build time
     * @type {number}
     * @memberof MaintainerPackagesElementModel
     */
    'buildtime'?: number;
    /**
     * package url
     * @type {string}
     * @memberof MaintainerPackagesElementModel
     */
    'url'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof MaintainerPackagesElementModel
     */
    'summary'?: string;
    /**
     * package version
     * @type {string}
     * @memberof MaintainerPackagesElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof MaintainerPackagesElementModel
     */
    'release'?: string;
}
/**
 * 
 * @export
 * @interface MaintainerPackagesModel
 */
export interface MaintainerPackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof MaintainerPackagesModel
     */
    'request_args'?: object;
    /**
     * number of maintainers found
     * @type {number}
     * @memberof MaintainerPackagesModel
     */
    'length'?: number;
    /**
     * found packages
     * @type {Array<MaintainerPackagesElementModel>}
     * @memberof MaintainerPackagesModel
     */
    'packages'?: Array<MaintainerPackagesElementModel>;
}
/**
 * 
 * @export
 * @interface NeedsApprovalModel
 */
export interface NeedsApprovalModel {
    /**
     * number of tasks found
     * @type {number}
     * @memberof NeedsApprovalModel
     */
    'length'?: number;
    /**
     * list of tasks
     * @type {Array<NeedsApprovalTaskElementModel>}
     * @memberof NeedsApprovalModel
     */
    'tasks'?: Array<NeedsApprovalTaskElementModel>;
}
/**
 * 
 * @export
 * @interface NeedsApprovalSubtaskElementModel
 */
export interface NeedsApprovalSubtaskElementModel {
    /**
     * subtask id
     * @type {number}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'id'?: number;
    /**
     * subtask type
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'type'?: string;
    /**
     * subtask package
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'package'?: string;
    /**
     * subtask userid
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'userid'?: string;
    /**
     * subtask dir
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'dir'?: string;
    /**
     * subtask sid
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'sid'?: string;
    /**
     * subtask package from
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'pkg_from'?: string;
    /**
     * subtask tag author
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'tag_author'?: string;
    /**
     * subtask tag id
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'tag_id'?: string;
    /**
     * subtask tag name
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'tag_name'?: string;
    /**
     * subtask srpm
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'srpm'?: string;
    /**
     * subtask srpm name
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'srpm_name'?: string;
    /**
     * subtask evr
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'srpm_evr'?: string;
    /**
     * subtask last changed
     * @type {string}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'last_changed'?: string;
    /**
     * 
     * @type {TaskInfoPackageModel}
     * @memberof NeedsApprovalSubtaskElementModel
     */
    'source_package'?: TaskInfoPackageModel;
}
/**
 * 
 * @export
 * @interface NeedsApprovalTaskElementModel
 */
export interface NeedsApprovalTaskElementModel {
    /**
     * task id
     * @type {number}
     * @memberof NeedsApprovalTaskElementModel
     */
    'id'?: number;
    /**
     * task state
     * @type {string}
     * @memberof NeedsApprovalTaskElementModel
     */
    'state'?: string;
    /**
     * task runby
     * @type {string}
     * @memberof NeedsApprovalTaskElementModel
     */
    'runby'?: string;
    /**
     * task last try
     * @type {number}
     * @memberof NeedsApprovalTaskElementModel
     */
    'try'?: number;
    /**
     * task last iteration
     * @type {number}
     * @memberof NeedsApprovalTaskElementModel
     */
    'iter'?: number;
    /**
     * task failearly
     * @type {boolean}
     * @memberof NeedsApprovalTaskElementModel
     */
    'failearly'?: boolean;
    /**
     * task shared
     * @type {boolean}
     * @memberof NeedsApprovalTaskElementModel
     */
    'shared'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof NeedsApprovalTaskElementModel
     */
    'depends'?: Array<number>;
    /**
     * task testonly
     * @type {boolean}
     * @memberof NeedsApprovalTaskElementModel
     */
    'testonly'?: boolean;
    /**
     * task message
     * @type {string}
     * @memberof NeedsApprovalTaskElementModel
     */
    'message'?: string;
    /**
     * task version
     * @type {string}
     * @memberof NeedsApprovalTaskElementModel
     */
    'version'?: string;
    /**
     * previous task
     * @type {number}
     * @memberof NeedsApprovalTaskElementModel
     */
    'prev'?: number;
    /**
     * task last changed
     * @type {string}
     * @memberof NeedsApprovalTaskElementModel
     */
    'last_changed'?: string;
    /**
     * task branch
     * @type {string}
     * @memberof NeedsApprovalTaskElementModel
     */
    'branch'?: string;
    /**
     * task user
     * @type {string}
     * @memberof NeedsApprovalTaskElementModel
     */
    'user'?: string;
    /**
     * list of subtasks
     * @type {Array<NeedsApprovalSubtaskElementModel>}
     * @memberof NeedsApprovalTaskElementModel
     */
    'subtasks'?: Array<NeedsApprovalSubtaskElementModel>;
}
/**
 * 
 * @export
 * @interface OvalBranchesModel
 */
export interface OvalBranchesModel {
    /**
     * number of branches
     * @type {number}
     * @memberof OvalBranchesModel
     */
    'length'?: number;
    /**
     * OVAL export available branches
     * @type {Array<string>}
     * @memberof OvalBranchesModel
     */
    'branches'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PackageBuildDependencyElementModel
 */
export interface PackageBuildDependencyElementModel {
    /**
     * source package hash UInt64 as string
     * @type {string}
     * @memberof PackageBuildDependencyElementModel
     */
    'pkghash'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof PackageBuildDependencyElementModel
     */
    'name'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof PackageBuildDependencyElementModel
     */
    'branch'?: string;
    /**
     * source package buildtime
     * @type {string}
     * @memberof PackageBuildDependencyElementModel
     */
    'buildtime'?: string;
    /**
     * package ACL list
     * @type {Array<string>}
     * @memberof PackageBuildDependencyElementModel
     */
    'acl'?: Array<string>;
    /**
     * package dependencies list
     * @type {Array<PackageDependsModel>}
     * @memberof PackageBuildDependencyElementModel
     */
    'depends'?: Array<PackageDependsModel>;
}
/**
 * 
 * @export
 * @interface PackageBuildDependencyModel
 */
export interface PackageBuildDependencyModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageBuildDependencyModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof PackageBuildDependencyModel
     */
    'length'?: number;
    /**
     * build dependency results
     * @type {Array<PackageBuildDependencyElementModel>}
     * @memberof PackageBuildDependencyModel
     */
    'dependencies'?: Array<PackageBuildDependencyElementModel>;
}
/**
 * 
 * @export
 * @interface PackageByFileNameElementModel
 */
export interface PackageByFileNameElementModel {
    /**
     * package name
     * @type {string}
     * @memberof PackageByFileNameElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof PackageByFileNameElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackageByFileNameElementModel
     */
    'release'?: string;
    /**
     * package disttag
     * @type {string}
     * @memberof PackageByFileNameElementModel
     */
    'disttag'?: string;
    /**
     * package name
     * @type {string}
     * @memberof PackageByFileNameElementModel
     */
    'sha1'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof PackageByFileNameElementModel
     */
    'branch'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof PackageByFileNameElementModel
     */
    'arch'?: string;
    /**
     * found files
     * @type {Array<string>}
     * @memberof PackageByFileNameElementModel
     */
    'files'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PackageByFileNameModel
 */
export interface PackageByFileNameModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageByFileNameModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof PackageByFileNameModel
     */
    'length'?: number;
    /**
     * package set packages information
     * @type {Array<PackageByFileNameElementModel>}
     * @memberof PackageByFileNameModel
     */
    'packages'?: Array<PackageByFileNameElementModel>;
    /**
     * list of not found filenames
     * @type {Array<string>}
     * @memberof PackageByFileNameModel
     */
    'not_found'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PackageDependsElementModel
 */
export interface PackageDependsElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof PackageDependsElementModel
     */
    'pkghash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof PackageDependsElementModel
     */
    'name'?: string;
    /**
     * package architecture
     * @type {string}
     * @memberof PackageDependsElementModel
     */
    'arch'?: string;
    /**
     * the name of the dependent package
     * @type {string}
     * @memberof PackageDependsElementModel
     */
    'dp_name'?: string;
    /**
     * the version of the dependent package
     * @type {string}
     * @memberof PackageDependsElementModel
     */
    'dp_version'?: string;
    /**
     * dependency flag
     * @type {number}
     * @memberof PackageDependsElementModel
     */
    'dp_flag'?: number;
    /**
     * decoded dependency flag
     * @type {Array<string>}
     * @memberof PackageDependsElementModel
     */
    'dp_flag_decoded'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PackageDependsModel
 */
export interface PackageDependsModel {
    /**
     * package requirements
     * @type {PackageDependsElementModel}
     * @memberof PackageDependsModel
     */
    'requires'?: PackageDependsElementModel;
    /**
     * package provides
     * @type {PackageDependsElementModel}
     * @memberof PackageDependsModel
     */
    'provides'?: PackageDependsElementModel;
}
/**
 * 
 * @export
 * @interface PackageFilesElementModel
 */
export interface PackageFilesElementModel {
    /**
     * file name
     * @type {string}
     * @memberof PackageFilesElementModel
     */
    'file_name'?: string;
    /**
     * human readable file size
     * @type {string}
     * @memberof PackageFilesElementModel
     */
    'file_size'?: string;
    /**
     * file class
     * @type {string}
     * @memberof PackageFilesElementModel
     */
    'file_class'?: string;
    /**
     * link path
     * @type {string}
     * @memberof PackageFilesElementModel
     */
    'symlink'?: string;
    /**
     * file modification time
     * @type {string}
     * @memberof PackageFilesElementModel
     */
    'file_mtime'?: string;
    /**
     * file permissions string representation
     * @type {string}
     * @memberof PackageFilesElementModel
     */
    'file_mode'?: string;
}
/**
 * 
 * @export
 * @interface PackageFilesModel
 */
export interface PackageFilesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageFilesModel
     */
    'request_args'?: object;
    /**
     * number of files found
     * @type {number}
     * @memberof PackageFilesModel
     */
    'length'?: number;
    /**
     * package file list
     * @type {Array<PackageFilesElementModel>}
     * @memberof PackageFilesModel
     */
    'files'?: Array<PackageFilesElementModel>;
}
/**
 * 
 * @export
 * @interface PackageFindPackagesetElementModel
 */
export interface PackageFindPackagesetElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof PackageFindPackagesetElementModel
     */
    'branch'?: string;
    /**
     * package set date
     * @type {string}
     * @memberof PackageFindPackagesetElementModel
     */
    'pkgset_datetime'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof PackageFindPackagesetElementModel
     */
    'sourcepkgname'?: string;
    /**
     * binary packages list
     * @type {Array<string>}
     * @memberof PackageFindPackagesetElementModel
     */
    'packages'?: Array<string>;
    /**
     * package version
     * @type {string}
     * @memberof PackageFindPackagesetElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackageFindPackagesetElementModel
     */
    'release'?: string;
    /**
     * package disttag
     * @type {string}
     * @memberof PackageFindPackagesetElementModel
     */
    'disttag'?: string;
    /**
     * package packager email
     * @type {string}
     * @memberof PackageFindPackagesetElementModel
     */
    'packager_email'?: string;
    /**
     * package build time
     * @type {string}
     * @memberof PackageFindPackagesetElementModel
     */
    'buildtime'?: string;
    /**
     * binary packages archs
     * @type {Array<string>}
     * @memberof PackageFindPackagesetElementModel
     */
    'archs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PackageFindPackagesetModel
 */
export interface PackageFindPackagesetModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageFindPackagesetModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof PackageFindPackagesetModel
     */
    'length'?: number;
    /**
     * package set packages information
     * @type {Array<PackageFindPackagesetElementModel>}
     * @memberof PackageFindPackagesetModel
     */
    'packages'?: Array<PackageFindPackagesetElementModel>;
}
/**
 * 
 * @export
 * @interface PackageInfoModel
 */
export interface PackageInfoModel {
    /**
     * package name
     * @type {string}
     * @memberof PackageInfoModel
     */
    'name'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof PackageInfoModel
     */
    'epoch'?: number;
    /**
     * package version
     * @type {string}
     * @memberof PackageInfoModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackageInfoModel
     */
    'release'?: string;
    /**
     * package buildtime
     * @type {number}
     * @memberof PackageInfoModel
     */
    'buildtime'?: number;
}
/**
 * 
 * @export
 * @interface PackageMisconflictBySrcElementModel
 */
export interface PackageMisconflictBySrcElementModel {
    /**
     * package name
     * @type {string}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'input_package'?: string;
    /**
     * input package archs
     * @type {Array<string>}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'input_archs'?: Array<string>;
    /**
     * package name
     * @type {string}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'conflict_package'?: string;
    /**
     * package version
     * @type {string}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'release'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'epoch'?: number;
    /**
     * package archs
     * @type {Array<string>}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'archs'?: Array<string>;
    /**
     * conflict files
     * @type {Array<string>}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'files_with_conflict'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PackageMisconflictBySrcElementModel
     */
    'explicit'?: boolean;
}
/**
 * 
 * @export
 * @interface PackageMisconflictBySrcModel
 */
export interface PackageMisconflictBySrcModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageMisconflictBySrcModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof PackageMisconflictBySrcModel
     */
    'length'?: number;
    /**
     * conflicts
     * @type {Array<PackageMisconflictBySrcElementModel>}
     * @memberof PackageMisconflictBySrcModel
     */
    'conflicts'?: Array<PackageMisconflictBySrcElementModel>;
}
/**
 * 
 * @export
 * @interface PackageMisconflictPackageModel
 */
export interface PackageMisconflictPackageModel {
    /**
     * package name
     * @type {string}
     * @memberof PackageMisconflictPackageModel
     */
    'input_package'?: string;
    /**
     * package name
     * @type {string}
     * @memberof PackageMisconflictPackageModel
     */
    'conflict_package'?: string;
    /**
     * package version
     * @type {string}
     * @memberof PackageMisconflictPackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackageMisconflictPackageModel
     */
    'release'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof PackageMisconflictPackageModel
     */
    'epoch'?: number;
    /**
     * package archs
     * @type {Array<string>}
     * @memberof PackageMisconflictPackageModel
     */
    'archs'?: Array<string>;
    /**
     * conflict files
     * @type {Array<string>}
     * @memberof PackageMisconflictPackageModel
     */
    'files_with_conflict'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PackageMisconflictPackagesModel
 */
export interface PackageMisconflictPackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageMisconflictPackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof PackageMisconflictPackagesModel
     */
    'length'?: number;
    /**
     * conflicts
     * @type {Array<PackageMisconflictPackageModel>}
     * @memberof PackageMisconflictPackagesModel
     */
    'conflicts'?: Array<PackageMisconflictPackageModel>;
}
/**
 * 
 * @export
 * @interface PackageNVRByHashModel
 */
export interface PackageNVRByHashModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageNVRByHashModel
     */
    'request_args'?: object;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof PackageNVRByHashModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof PackageNVRByHashModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof PackageNVRByHashModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackageNVRByHashModel
     */
    'release'?: string;
    /**
     * is source package
     * @type {boolean}
     * @memberof PackageNVRByHashModel
     */
    'is_source'?: boolean;
}
/**
 * 
 * @export
 * @interface PackageNameFromRepologyModel
 */
export interface PackageNameFromRepologyModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageNameFromRepologyModel
     */
    'request_args'?: object;
    /**
     * package name from repology
     * @type {string}
     * @memberof PackageNameFromRepologyModel
     */
    'name'?: string;
    /**
     * repository name from repology
     * @type {string}
     * @memberof PackageNameFromRepologyModel
     */
    'repo'?: string;
}
/**
 * 
 * @export
 * @interface PackageSetActivePackageSetsModel
 */
export interface PackageSetActivePackageSetsModel {
    /**
     * number of active package sets found
     * @type {number}
     * @memberof PackageSetActivePackageSetsModel
     */
    'length'?: number;
    /**
     * active package sets list
     * @type {Array<string>}
     * @memberof PackageSetActivePackageSetsModel
     */
    'packagesets'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PackageSetStatusGetElementModel
 */
export interface PackageSetStatusGetElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof PackageSetStatusGetElementModel
     */
    'branch'?: string;
    /**
     * package set name for bugzilla
     * @type {string}
     * @memberof PackageSetStatusGetElementModel
     */
    'pkgset_name_bugzilla'?: string;
    /**
     * support start date
     * @type {string}
     * @memberof PackageSetStatusGetElementModel
     */
    'start_date'?: string;
    /**
     * support end date
     * @type {string}
     * @memberof PackageSetStatusGetElementModel
     */
    'end_date'?: string;
    /**
     * 0 - hide branch, 1 - show branch
     * @type {number}
     * @memberof PackageSetStatusGetElementModel
     */
    'show'?: number;
    /**
     * html description in Russian
     * @type {string}
     * @memberof PackageSetStatusGetElementModel
     */
    'description_ru'?: string;
    /**
     * html description in English
     * @type {string}
     * @memberof PackageSetStatusGetElementModel
     */
    'description_en'?: string;
    /**
     * link to mailing list
     * @type {string}
     * @memberof PackageSetStatusGetElementModel
     */
    'url_mailing_list'?: string;
    /**
     * packageset mirror\'s auxilary info as JSON substructure
     * @type {object}
     * @memberof PackageSetStatusGetElementModel
     */
    'mirrors_json'?: object;
    /**
     * 0 - branch has no active images, 1 - branch has active images
     * @type {number}
     * @memberof PackageSetStatusGetElementModel
     */
    'has_images'?: number;
}
/**
 * 
 * @export
 * @interface PackageSetStatusGetModel
 */
export interface PackageSetStatusGetModel {
    /**
     * package set info
     * @type {Array<PackageSetStatusGetElementModel>}
     * @memberof PackageSetStatusGetModel
     */
    'branches'?: Array<PackageSetStatusGetElementModel>;
}
/**
 * 
 * @export
 * @interface PackageSetStatusPostElementModel
 */
export interface PackageSetStatusPostElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof PackageSetStatusPostElementModel
     */
    'pkgset_name': string;
    /**
     * package set name for bugzilla
     * @type {string}
     * @memberof PackageSetStatusPostElementModel
     */
    'rs_pkgset_name_bugzilla': string;
    /**
     * support start date
     * @type {string}
     * @memberof PackageSetStatusPostElementModel
     */
    'rs_start_date': string;
    /**
     * support end date
     * @type {string}
     * @memberof PackageSetStatusPostElementModel
     */
    'rs_end_date': string;
    /**
     * 0 - hide branch, 1 - show branch
     * @type {number}
     * @memberof PackageSetStatusPostElementModel
     */
    'rs_show': number;
    /**
     * html description in Russian in Base64 format
     * @type {string}
     * @memberof PackageSetStatusPostElementModel
     */
    'rs_description_ru': string;
    /**
     * html description in English in Base64 format
     * @type {string}
     * @memberof PackageSetStatusPostElementModel
     */
    'rs_description_en': string;
    /**
     * link to mailing list
     * @type {string}
     * @memberof PackageSetStatusPostElementModel
     */
    'rs_mailing_list': string;
    /**
     * packageset mirror\'s auxilary info as JSON substructure
     * @type {Array<object>}
     * @memberof PackageSetStatusPostElementModel
     */
    'rs_mirrors_json'?: Array<object>;
}
/**
 * 
 * @export
 * @interface PackageSetStatusPostModel
 */
export interface PackageSetStatusPostModel {
    /**
     * package set info
     * @type {Array<PackageSetStatusPostElementModel>}
     * @memberof PackageSetStatusPostModel
     */
    'branches': Array<PackageSetStatusPostElementModel>;
}
/**
 * 
 * @export
 * @interface PackageSpecfileModel
 */
export interface PackageSpecfileModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackageSpecfileModel
     */
    'request_args'?: object;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof PackageSpecfileModel
     */
    'pkg_hash'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof PackageSpecfileModel
     */
    'pkg_name'?: string;
    /**
     * source package version
     * @type {string}
     * @memberof PackageSpecfileModel
     */
    'pkg_version'?: string;
    /**
     * source package release
     * @type {string}
     * @memberof PackageSpecfileModel
     */
    'pkg_release'?: string;
    /**
     * spec file name
     * @type {string}
     * @memberof PackageSpecfileModel
     */
    'specfile_name'?: string;
    /**
     * spec file mtime
     * @type {string}
     * @memberof PackageSpecfileModel
     */
    'specfile_date'?: string;
    /**
     * spec file base64 encoded raw contents
     * @type {string}
     * @memberof PackageSpecfileModel
     */
    'specfile_content'?: string;
}
/**
 * 
 * @export
 * @interface PackagesByFileNamesJsonModel
 */
export interface PackagesByFileNamesJsonModel {
    /**
     * 
     * @type {Array<string>}
     * @memberof PackagesByFileNamesJsonModel
     */
    'files': Array<string>;
    /**
     * name of packageset
     * @type {string}
     * @memberof PackagesByFileNamesJsonModel
     */
    'branch': string;
    /**
     * packages architecture
     * @type {string}
     * @memberof PackagesByFileNamesJsonModel
     */
    'arch'?: string;
}
/**
 * 
 * @export
 * @interface PackagesByUuidElementModel
 */
export interface PackagesByUuidElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof PackagesByUuidElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof PackagesByUuidElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof PackagesByUuidElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackagesByUuidElementModel
     */
    'release'?: string;
    /**
     * package architecture
     * @type {string}
     * @memberof PackagesByUuidElementModel
     */
    'arch'?: string;
    /**
     * source package file
     * @type {string}
     * @memberof PackagesByUuidElementModel
     */
    'sourcerpm'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof PackagesByUuidElementModel
     */
    'summary'?: string;
    /**
     * last binary package buildtime
     * @type {number}
     * @memberof PackagesByUuidElementModel
     */
    'buildtime'?: number;
    /**
     * package last changelog message
     * @type {string}
     * @memberof PackagesByUuidElementModel
     */
    'changelog_text'?: string;
}
/**
 * 
 * @export
 * @interface PackagesByUuidModel
 */
export interface PackagesByUuidModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackagesByUuidModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof PackagesByUuidModel
     */
    'length'?: number;
    /**
     * packages list by packageset component UUID
     * @type {Array<PackagesByUuidElementModel>}
     * @memberof PackagesByUuidModel
     */
    'packages'?: Array<PackagesByUuidElementModel>;
}
/**
 * 
 * @export
 * @interface PackagesElementModel
 */
export interface PackagesElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof PackagesElementModel
     */
    'pkghash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof PackagesElementModel
     */
    'pkg_name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof PackagesElementModel
     */
    'pkg_version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackagesElementModel
     */
    'pkg_release'?: string;
}
/**
 * 
 * @export
 * @interface PackagesetCompareElementModel
 */
export interface PackagesetCompareElementModel {
    /**
     * packageset #1 name
     * @type {string}
     * @memberof PackagesetCompareElementModel
     */
    'pkgset1'?: string;
    /**
     * packageset #2 name
     * @type {string}
     * @memberof PackagesetCompareElementModel
     */
    'pkgset2'?: string;
    /**
     * package from packageset #1
     * @type {PackagesetComparePackageModel}
     * @memberof PackagesetCompareElementModel
     */
    'package1'?: PackagesetComparePackageModel;
    /**
     * package from packageset #2
     * @type {PackagesetComparePackageModel}
     * @memberof PackagesetCompareElementModel
     */
    'package2'?: PackagesetComparePackageModel;
}
/**
 * 
 * @export
 * @interface PackagesetCompareModel
 */
export interface PackagesetCompareModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackagesetCompareModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof PackagesetCompareModel
     */
    'length'?: number;
    /**
     * packages information
     * @type {Array<PackagesetCompareElementModel>}
     * @memberof PackagesetCompareModel
     */
    'packages'?: Array<PackagesetCompareElementModel>;
}
/**
 * 
 * @export
 * @interface PackagesetComparePackageModel
 */
export interface PackagesetComparePackageModel {
    /**
     * package name
     * @type {string}
     * @memberof PackagesetComparePackageModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof PackagesetComparePackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackagesetComparePackageModel
     */
    'release'?: string;
}
/**
 * 
 * @export
 * @interface PackagesetPackagesElementModel
 */
export interface PackagesetPackagesElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof PackagesetPackagesElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof PackagesetPackagesElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof PackagesetPackagesElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackagesetPackagesElementModel
     */
    'release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof PackagesetPackagesElementModel
     */
    'summary'?: string;
    /**
     * package url
     * @type {string}
     * @memberof PackagesetPackagesElementModel
     */
    'url'?: string;
    /**
     * package license
     * @type {string}
     * @memberof PackagesetPackagesElementModel
     */
    'license'?: string;
    /**
     * package category
     * @type {string}
     * @memberof PackagesetPackagesElementModel
     */
    'category'?: string;
    /**
     * package maintainers
     * @type {Array<string>}
     * @memberof PackagesetPackagesElementModel
     */
    'maintainers'?: Array<string>;
    /**
     * package ACL list
     * @type {Array<string>}
     * @memberof PackagesetPackagesElementModel
     */
    'acl_list'?: Array<string>;
    /**
     * package archs
     * @type {Array<string>}
     * @memberof PackagesetPackagesElementModel
     */
    'archs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PackagesetPackagesExportElementModel
 */
export interface PackagesetPackagesExportElementModel {
    /**
     * package name
     * @type {string}
     * @memberof PackagesetPackagesExportElementModel
     */
    'name'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof PackagesetPackagesExportElementModel
     */
    'epoch'?: number;
    /**
     * package version
     * @type {string}
     * @memberof PackagesetPackagesExportElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof PackagesetPackagesExportElementModel
     */
    'release'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof PackagesetPackagesExportElementModel
     */
    'arch'?: string;
    /**
     * package disttag
     * @type {string}
     * @memberof PackagesetPackagesExportElementModel
     */
    'disttag'?: string;
    /**
     * package build time
     * @type {number}
     * @memberof PackagesetPackagesExportElementModel
     */
    'buildtime'?: number;
    /**
     * source package name
     * @type {string}
     * @memberof PackagesetPackagesExportElementModel
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface PackagesetPackagesExportModel
 */
export interface PackagesetPackagesExportModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackagesetPackagesExportModel
     */
    'request_args'?: object;
    /**
     * number of binary packages found
     * @type {number}
     * @memberof PackagesetPackagesExportModel
     */
    'length'?: number;
    /**
     * binary packages information
     * @type {Array<PackagesetPackagesExportElementModel>}
     * @memberof PackagesetPackagesExportModel
     */
    'packages'?: Array<PackagesetPackagesExportElementModel>;
}
/**
 * 
 * @export
 * @interface PackagesetPackagesModel
 */
export interface PackagesetPackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof PackagesetPackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof PackagesetPackagesModel
     */
    'length'?: number;
    /**
     * packages information
     * @type {Array<PackagesetPackagesElementModel>}
     * @memberof PackagesetPackagesModel
     */
    'packages'?: Array<PackagesetPackagesElementModel>;
}
/**
 * 
 * @export
 * @interface RepocopByMaintainerElementModel
 */
export interface RepocopByMaintainerElementModel {
    /**
     * package name
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'pkg_name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'pkg_version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'pkg_release'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'pkg_arch'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'srcpkg_name'?: string;
    /**
     * repocop branch
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'branch'?: string;
    /**
     * repocop test name
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'test_name'?: string;
    /**
     * repocop test status
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'test_status'?: string;
    /**
     * repocop test message
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'test_message'?: string;
    /**
     * repocop test date
     * @type {string}
     * @memberof RepocopByMaintainerElementModel
     */
    'test_date'?: string;
}
/**
 * 
 * @export
 * @interface RepocopByMaintainerModel
 */
export interface RepocopByMaintainerModel {
    /**
     * request arguments
     * @type {object}
     * @memberof RepocopByMaintainerModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof RepocopByMaintainerModel
     */
    'length'?: number;
    /**
     * repocop packages info
     * @type {Array<RepocopByMaintainerElementModel>}
     * @memberof RepocopByMaintainerModel
     */
    'packages'?: Array<RepocopByMaintainerElementModel>;
}
/**
 * 
 * @export
 * @interface RepocopJsonGetListModel
 */
export interface RepocopJsonGetListModel {
    /**
     * request arguments
     * @type {object}
     * @memberof RepocopJsonGetListModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof RepocopJsonGetListModel
     */
    'length'?: number;
    /**
     * repocop packages info
     * @type {Array<RepocopJsonGetModel>}
     * @memberof RepocopJsonGetListModel
     */
    'packages'?: Array<RepocopJsonGetModel>;
}
/**
 * 
 * @export
 * @interface RepocopJsonGetModel
 */
export interface RepocopJsonGetModel {
    /**
     * package name
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'pkg_name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'pkg_version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'pkg_release'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'pkg_arch'?: string;
    /**
     * package branch
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'branch'?: string;
    /**
     * repocop test name
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'test_name'?: string;
    /**
     * repocop test status
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'test_status'?: string;
    /**
     * repocop test message
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'test_message'?: string;
    /**
     * repocop test date
     * @type {string}
     * @memberof RepocopJsonGetModel
     */
    'test_date'?: string;
}
/**
 * 
 * @export
 * @interface RepocopJsonPostListModel
 */
export interface RepocopJsonPostListModel {
    /**
     * repocop packages info
     * @type {Array<RepocopJsonPostModel>}
     * @memberof RepocopJsonPostListModel
     */
    'packages': Array<RepocopJsonPostModel>;
}
/**
 * 
 * @export
 * @interface RepocopJsonPostModel
 */
export interface RepocopJsonPostModel {
    /**
     * package name
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'pkg_name': string;
    /**
     * package version
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'pkg_version': string;
    /**
     * package release
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'pkg_release': string;
    /**
     * package arch
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'pkg_arch': string;
    /**
     * package branch
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'pkgset_name': string;
    /**
     * source package name
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'rc_srcpkg_name': string;
    /**
     * source package version
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'rc_srcpkg_version': string;
    /**
     * source package version
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'rc_srcpkg_release': string;
    /**
     * repocop test name
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'rc_test_name': string;
    /**
     * repocop test status
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'rc_test_status': string;
    /**
     * repocop test message
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'rc_test_message': string;
    /**
     * repocop test date
     * @type {string}
     * @memberof RepocopJsonPostModel
     */
    'rc_test_date': string;
}
/**
 * 
 * @export
 * @interface RepologyExportBranchBinaryPackageElementModel
 */
export interface RepologyExportBranchBinaryPackageElementModel {
    /**
     * package name
     * @type {string}
     * @memberof RepologyExportBranchBinaryPackageElementModel
     */
    'name'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof RepologyExportBranchBinaryPackageElementModel
     */
    'epoch'?: number;
    /**
     * package version
     * @type {string}
     * @memberof RepologyExportBranchBinaryPackageElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof RepologyExportBranchBinaryPackageElementModel
     */
    'release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof RepologyExportBranchBinaryPackageElementModel
     */
    'summary'?: string;
    /**
     * package archs
     * @type {Array<string>}
     * @memberof RepologyExportBranchBinaryPackageElementModel
     */
    'archs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RepologyExportBranchSourcePackageElementModel
 */
export interface RepologyExportBranchSourcePackageElementModel {
    /**
     * package name
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'name'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'epoch'?: number;
    /**
     * package version
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'release'?: string;
    /**
     * package upstream URL
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'url'?: string;
    /**
     * package license
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'license'?: string;
    /**
     * package category
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'category'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'summary'?: string;
    /**
     * packager email
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'packager'?: string;
    /**
     * package homepage
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'homepage'?: string;
    /**
     * package spec file
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'recipe'?: string;
    /**
     * package spec file raw
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'recipe_raw'?: string;
    /**
     * package bugs
     * @type {string}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'bugzilla'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'CPE'?: Array<string>;
    /**
     * binary packages info
     * @type {Array<RepologyExportBranchBinaryPackageElementModel>}
     * @memberof RepologyExportBranchSourcePackageElementModel
     */
    'binaries'?: Array<RepologyExportBranchBinaryPackageElementModel>;
}
/**
 * 
 * @export
 * @interface RepologyExportBranchStatElementModel
 */
export interface RepologyExportBranchStatElementModel {
    /**
     * source package arch
     * @type {string}
     * @memberof RepologyExportBranchStatElementModel
     */
    'arch'?: string;
    /**
     * count of source packages by binary packages arch
     * @type {number}
     * @memberof RepologyExportBranchStatElementModel
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface RepologyExportModel
 */
export interface RepologyExportModel {
    /**
     * package set name
     * @type {string}
     * @memberof RepologyExportModel
     */
    'branch'?: string;
    /**
     * package set commit date
     * @type {string}
     * @memberof RepologyExportModel
     */
    'date'?: string;
    /**
     * package set stats
     * @type {Array<RepologyExportBranchStatElementModel>}
     * @memberof RepologyExportModel
     */
    'stats'?: Array<RepologyExportBranchStatElementModel>;
    /**
     * source packages info
     * @type {Array<RepologyExportBranchSourcePackageElementModel>}
     * @memberof RepologyExportModel
     */
    'packages'?: Array<RepologyExportBranchSourcePackageElementModel>;
}
/**
 * 
 * @export
 * @interface RepositoryStatisticsBranchesModel
 */
export interface RepositoryStatisticsBranchesModel {
    /**
     * package set name
     * @type {string}
     * @memberof RepositoryStatisticsBranchesModel
     */
    'branch'?: string;
    /**
     * branch upload date
     * @type {string}
     * @memberof RepositoryStatisticsBranchesModel
     */
    'date_update'?: string;
    /**
     * list of packages count by package archs
     * @type {Array<RepositoryStatisticsPackageCountsModel>}
     * @memberof RepositoryStatisticsBranchesModel
     */
    'packages_count'?: Array<RepositoryStatisticsPackageCountsModel>;
}
/**
 * 
 * @export
 * @interface RepositoryStatisticsModel
 */
export interface RepositoryStatisticsModel {
    /**
     * number of packages found
     * @type {number}
     * @memberof RepositoryStatisticsModel
     */
    'length'?: number;
    /**
     * list of branches with packages count
     * @type {Array<RepositoryStatisticsBranchesModel>}
     * @memberof RepositoryStatisticsModel
     */
    'branches'?: Array<RepositoryStatisticsBranchesModel>;
}
/**
 * 
 * @export
 * @interface RepositoryStatisticsPackageCountsModel
 */
export interface RepositoryStatisticsPackageCountsModel {
    /**
     * packages arch
     * @type {string}
     * @memberof RepositoryStatisticsPackageCountsModel
     */
    'arch'?: string;
    /**
     * component name
     * @type {string}
     * @memberof RepositoryStatisticsPackageCountsModel
     */
    'component'?: string;
    /**
     * packages count
     * @type {number}
     * @memberof RepositoryStatisticsPackageCountsModel
     */
    'count'?: number;
    /**
     * total packages files size in bytes
     * @type {number}
     * @memberof RepositoryStatisticsPackageCountsModel
     */
    'size'?: number;
    /**
     * total packages files size human readable
     * @type {string}
     * @memberof RepositoryStatisticsPackageCountsModel
     */
    'size_hr'?: string;
    /**
     * repository component UUID
     * @type {string}
     * @memberof RepositoryStatisticsPackageCountsModel
     */
    'uuid'?: string;
}
/**
 * 
 * @export
 * @interface SItePackagesVersionsFromTasksElementModel
 */
export interface SItePackagesVersionsFromTasksElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof SItePackagesVersionsFromTasksElementModel
     */
    'branch'?: string;
    /**
     * package build task
     * @type {number}
     * @memberof SItePackagesVersionsFromTasksElementModel
     */
    'task'?: number;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SItePackagesVersionsFromTasksElementModel
     */
    'hash'?: string;
    /**
     * task owner nickname
     * @type {string}
     * @memberof SItePackagesVersionsFromTasksElementModel
     */
    'owner'?: string;
    /**
     * task change date
     * @type {string}
     * @memberof SItePackagesVersionsFromTasksElementModel
     */
    'changed'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SItePackagesVersionsFromTasksElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SItePackagesVersionsFromTasksElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SItePackagesVersionsFromTasksElementModel
     */
    'release'?: string;
}
/**
 * 
 * @export
 * @interface SItePackagesVersionsFromTasksModel
 */
export interface SItePackagesVersionsFromTasksModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SItePackagesVersionsFromTasksModel
     */
    'request_args'?: object;
    /**
     * number of versions found
     * @type {number}
     * @memberof SItePackagesVersionsFromTasksModel
     */
    'length'?: number;
    /**
     * package versions list
     * @type {Array<SItePackagesVersionsFromTasksElementModel>}
     * @memberof SItePackagesVersionsFromTasksModel
     */
    'versions'?: Array<SItePackagesVersionsFromTasksElementModel>;
}
/**
 * 
 * @export
 * @interface SiteAllArchsElementModel
 */
export interface SiteAllArchsElementModel {
    /**
     * binary package arch
     * @type {string}
     * @memberof SiteAllArchsElementModel
     */
    'arch'?: string;
    /**
     * number of source packages
     * @type {number}
     * @memberof SiteAllArchsElementModel
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SiteAllArchsModel
 */
export interface SiteAllArchsModel {
    /**
     * number of binary package archs and source packages count
     * @type {number}
     * @memberof SiteAllArchsModel
     */
    'length'?: number;
    /**
     * binary package archs
     * @type {Array<SiteAllArchsElementModel>}
     * @memberof SiteAllArchsModel
     */
    'archs'?: Array<SiteAllArchsElementModel>;
}
/**
 * 
 * @export
 * @interface SiteAllPackagasetsElementModel
 */
export interface SiteAllPackagasetsElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof SiteAllPackagasetsElementModel
     */
    'branch'?: string;
    /**
     * number of source packages
     * @type {number}
     * @memberof SiteAllPackagasetsElementModel
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SiteAllPackagasetsModel
 */
export interface SiteAllPackagasetsModel {
    /**
     * number of package sets found
     * @type {number}
     * @memberof SiteAllPackagasetsModel
     */
    'length'?: number;
    /**
     * list of package sets with source package count
     * @type {Array<SiteAllPackagasetsElementModel>}
     * @memberof SiteAllPackagasetsModel
     */
    'branches'?: Array<SiteAllPackagasetsElementModel>;
}
/**
 * 
 * @export
 * @interface SiteAllPackagesetsSummaryBranchesModel
 */
export interface SiteAllPackagesetsSummaryBranchesModel {
    /**
     * package set name
     * @type {string}
     * @memberof SiteAllPackagesetsSummaryBranchesModel
     */
    'branch'?: string;
    /**
     * list of source packages count by binary packages archs
     * @type {Array<SiteAllPackagesetsSummaryCountsModel>}
     * @memberof SiteAllPackagesetsSummaryBranchesModel
     */
    'packages_count'?: Array<SiteAllPackagesetsSummaryCountsModel>;
}
/**
 * 
 * @export
 * @interface SiteAllPackagesetsSummaryCountsModel
 */
export interface SiteAllPackagesetsSummaryCountsModel {
    /**
     * binary packages arch
     * @type {string}
     * @memberof SiteAllPackagesetsSummaryCountsModel
     */
    'arch'?: string;
    /**
     * source packages count
     * @type {number}
     * @memberof SiteAllPackagesetsSummaryCountsModel
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SiteAllPackagesetsSummaryModel
 */
export interface SiteAllPackagesetsSummaryModel {
    /**
     * number of packages found
     * @type {number}
     * @memberof SiteAllPackagesetsSummaryModel
     */
    'length'?: number;
    /**
     * list of branches with source packages count
     * @type {Array<SiteAllPackagesetsSummaryBranchesModel>}
     * @memberof SiteAllPackagesetsSummaryModel
     */
    'branches'?: Array<SiteAllPackagesetsSummaryBranchesModel>;
}
/**
 * 
 * @export
 * @interface SiteBeehiveByMaintainerElementModel
 */
export interface SiteBeehiveByMaintainerElementModel {
    /**
     * Beehive branch
     * @type {string}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'branch'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'release'?: string;
    /**
     * Beehive arch
     * @type {string}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'arch'?: string;
    /**
     * Beehive rebuild date
     * @type {string}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'updated'?: string;
    /**
     * Package FTBFS since date
     * @type {string}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'ftbfs_since'?: string;
    /**
     * Beehive package build elapsed (seconds)
     * @type {number}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'build_time'?: number;
    /**
     * Beehive package build error log URL
     * @type {string}
     * @memberof SiteBeehiveByMaintainerElementModel
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface SiteBeehiveByMaintainerModel
 */
export interface SiteBeehiveByMaintainerModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteBeehiveByMaintainerModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SiteBeehiveByMaintainerModel
     */
    'length'?: number;
    /**
     * Beehive packages rebuild errors
     * @type {Array<SiteBeehiveByMaintainerElementModel>}
     * @memberof SiteBeehiveByMaintainerModel
     */
    'beehive'?: Array<SiteBeehiveByMaintainerElementModel>;
}
/**
 * 
 * @export
 * @interface SiteBinPackageScriptsElementModel
 */
export interface SiteBinPackageScriptsElementModel {
    /**
     * pre install script
     * @type {string}
     * @memberof SiteBinPackageScriptsElementModel
     */
    'prein'?: string;
    /**
     * post install script
     * @type {string}
     * @memberof SiteBinPackageScriptsElementModel
     */
    'postin'?: string;
    /**
     * pre uninstall script
     * @type {string}
     * @memberof SiteBinPackageScriptsElementModel
     */
    'preun'?: string;
    /**
     * post uninstall script
     * @type {string}
     * @memberof SiteBinPackageScriptsElementModel
     */
    'postun'?: string;
    /**
     * pre transaction script
     * @type {string}
     * @memberof SiteBinPackageScriptsElementModel
     */
    'pretrans'?: string;
    /**
     * post transaction script
     * @type {string}
     * @memberof SiteBinPackageScriptsElementModel
     */
    'posttrans'?: string;
}
/**
 * 
 * @export
 * @interface SiteBinPackageScriptsModel
 */
export interface SiteBinPackageScriptsModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteBinPackageScriptsModel
     */
    'request_args'?: object;
    /**
     * package name
     * @type {string}
     * @memberof SiteBinPackageScriptsModel
     */
    'pkg_name'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof SiteBinPackageScriptsModel
     */
    'pkg_arch'?: string;
    /**
     * number of scripts found
     * @type {number}
     * @memberof SiteBinPackageScriptsModel
     */
    'length'?: number;
    /**
     * unpackaged directories information
     * @type {Array<SiteBinPackageScriptsElementModel>}
     * @memberof SiteBinPackageScriptsModel
     */
    'scripts'?: Array<SiteBinPackageScriptsElementModel>;
}
/**
 * 
 * @export
 * @interface SiteBriefPackageInfoModel
 */
export interface SiteBriefPackageInfoModel {
    /**
     * package name
     * @type {string}
     * @memberof SiteBriefPackageInfoModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SiteBriefPackageInfoModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SiteBriefPackageInfoModel
     */
    'release'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof SiteBriefPackageInfoModel
     */
    'arch'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof SiteBriefPackageInfoModel
     */
    'summary'?: string;
    /**
     * package type (source | binary)
     * @type {string}
     * @memberof SiteBriefPackageInfoModel
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface SiteChangelogElementModel
 */
export interface SiteChangelogElementModel {
    /**
     * changelog date
     * @type {string}
     * @memberof SiteChangelogElementModel
     */
    'date'?: string;
    /**
     * changelog name
     * @type {string}
     * @memberof SiteChangelogElementModel
     */
    'name'?: string;
    /**
     * changelog nickname
     * @type {string}
     * @memberof SiteChangelogElementModel
     */
    'nick'?: string;
    /**
     * changelog EVR
     * @type {string}
     * @memberof SiteChangelogElementModel
     */
    'evr'?: string;
    /**
     * changelog message
     * @type {string}
     * @memberof SiteChangelogElementModel
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SiteChangelogModel
 */
export interface SiteChangelogModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SiteChangelogModel
     */
    'pkghash'?: string;
    /**
     * request arguments
     * @type {object}
     * @memberof SiteChangelogModel
     */
    'request_args'?: object;
    /**
     * number changelog records
     * @type {number}
     * @memberof SiteChangelogModel
     */
    'length'?: number;
    /**
     * package changelog
     * @type {Array<SiteChangelogElementModel>}
     * @memberof SiteChangelogModel
     */
    'changelog'?: Array<SiteChangelogElementModel>;
}
/**
 * 
 * @export
 * @interface SiteDeletedPackageModel
 */
export interface SiteDeletedPackageModel {
    /**
     * package set name
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'branch'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'package'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'release'?: string;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'hash'?: string;
    /**
     * task id
     * @type {number}
     * @memberof SiteDeletedPackageModel
     */
    'task_id'?: number;
    /**
     * subtask id
     * @type {number}
     * @memberof SiteDeletedPackageModel
     */
    'subtask_id'?: number;
    /**
     * task created by
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'task_owner'?: string;
    /**
     * subtask created by
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'subtask_owner'?: string;
    /**
     * task completed at
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'task_changed'?: string;
    /**
     * task message
     * @type {string}
     * @memberof SiteDeletedPackageModel
     */
    'task_message'?: string;
}
/**
 * 
 * @export
 * @interface SiteFastPackagesSearchElementModel
 */
export interface SiteFastPackagesSearchElementModel {
    /**
     * package name
     * @type {string}
     * @memberof SiteFastPackagesSearchElementModel
     */
    'name'?: string;
    /**
     * package type
     * @type {string}
     * @memberof SiteFastPackagesSearchElementModel
     */
    'sourcepackage'?: string;
    /**
     * list of package branches
     * @type {Array<string>}
     * @memberof SiteFastPackagesSearchElementModel
     */
    'branches'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SiteFastPackagesSearchModel
 */
export interface SiteFastPackagesSearchModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteFastPackagesSearchModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SiteFastPackagesSearchModel
     */
    'length'?: number;
    /**
     * list of found packages
     * @type {Array<SiteFastPackagesSearchElementModel>}
     * @memberof SiteFastPackagesSearchModel
     */
    'packages'?: Array<SiteFastPackagesSearchElementModel>;
}
/**
 * 
 * @export
 * @interface SiteFingPackagesModel
 */
export interface SiteFingPackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteFingPackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SiteFingPackagesModel
     */
    'length'?: number;
    /**
     * found packages
     * @type {Array<SiteFingPackagesPackageModel>}
     * @memberof SiteFingPackagesModel
     */
    'packages'?: Array<SiteFingPackagesPackageModel>;
}
/**
 * 
 * @export
 * @interface SiteFingPackagesPackageModel
 */
export interface SiteFingPackagesPackageModel {
    /**
     * package name
     * @type {string}
     * @memberof SiteFingPackagesPackageModel
     */
    'name'?: string;
    /**
     * package build time
     * @type {number}
     * @memberof SiteFingPackagesPackageModel
     */
    'buildtime'?: number;
    /**
     * package url
     * @type {string}
     * @memberof SiteFingPackagesPackageModel
     */
    'url'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof SiteFingPackagesPackageModel
     */
    'summary'?: string;
    /**
     * package category
     * @type {string}
     * @memberof SiteFingPackagesPackageModel
     */
    'category'?: string;
    /**
     * all package versions
     * @type {Array<SitePackageVersionsElementModel>}
     * @memberof SiteFingPackagesPackageModel
     */
    'versions'?: Array<SitePackageVersionsElementModel>;
    /**
     * found by binary package name
     * @type {boolean}
     * @memberof SiteFingPackagesPackageModel
     */
    'by_binary'?: boolean;
}
/**
 * 
 * @export
 * @interface SiteImageCategoriesModel
 */
export interface SiteImageCategoriesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteImageCategoriesModel
     */
    'request_args'?: object;
    /**
     * number of categories in list
     * @type {number}
     * @memberof SiteImageCategoriesModel
     */
    'length'?: number;
    /**
     * found categories
     * @type {Array<SiteImageCategoryElementModel>}
     * @memberof SiteImageCategoriesModel
     */
    'categories'?: Array<SiteImageCategoryElementModel>;
}
/**
 * 
 * @export
 * @interface SiteImageCategoryElementModel
 */
export interface SiteImageCategoryElementModel {
    /**
     * package category
     * @type {string}
     * @memberof SiteImageCategoryElementModel
     */
    'category'?: string;
    /**
     * number of packages in category
     * @type {number}
     * @memberof SiteImageCategoryElementModel
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SiteImagePackageVersionsElementModel
 */
export interface SiteImagePackageVersionsElementModel {
    /**
     * image tag
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'tag'?: string;
    /**
     * image root UUID
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'uuid'?: string;
    /**
     * Image version major
     * @type {number}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'version_major'?: number;
    /**
     * Image version minor
     * @type {number}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'version_minor'?: number;
    /**
     * Image version sub
     * @type {number}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'version_sub'?: number;
    /**
     * Image architecture
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'img_arch'?: string;
    /**
     * Image platform
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'platform'?: string;
    /**
     * Image variant
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'variant'?: string;
    /**
     * Image flavor
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'flavor'?: string;
    /**
     * Image type
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'type'?: string;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'release'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof SiteImagePackageVersionsElementModel
     */
    'arch'?: string;
}
/**
 * 
 * @export
 * @interface SiteImagePackageVersionsModel
 */
export interface SiteImagePackageVersionsModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteImagePackageVersionsModel
     */
    'request_args'?: object;
    /**
     * number of images found
     * @type {number}
     * @memberof SiteImagePackageVersionsModel
     */
    'length'?: number;
    /**
     * all package versions
     * @type {Array<SiteImagePackageVersionsElementModel>}
     * @memberof SiteImagePackageVersionsModel
     */
    'versions'?: Array<SiteImagePackageVersionsElementModel>;
}
/**
 * 
 * @export
 * @interface SiteLastBranchPackagesModel
 */
export interface SiteLastBranchPackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteLastBranchPackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SiteLastBranchPackagesModel
     */
    'length'?: number;
    /**
     * last packages list
     * @type {Array<SiteLastBranchPackagesPackageModel>}
     * @memberof SiteLastBranchPackagesModel
     */
    'packages'?: Array<SiteLastBranchPackagesPackageModel>;
    /**
     * last loaded branch date
     * @type {string}
     * @memberof SiteLastBranchPackagesModel
     */
    'last_branch_date'?: string;
}
/**
 * 
 * @export
 * @interface SiteLastBranchPackagesPackageModel
 */
export interface SiteLastBranchPackagesPackageModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'summary'?: string;
    /**
     * last binary package buildtime
     * @type {number}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'buildtime'?: number;
    /**
     * package last changelog name
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'changelog_name'?: string;
    /**
     * package last changelog nickname
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'changelog_nickname'?: string;
    /**
     * package last changelog message date
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'changelog_date'?: string;
    /**
     * package last changelog message
     * @type {string}
     * @memberof SiteLastBranchPackagesPackageModel
     */
    'changelog_text'?: string;
}
/**
 * 
 * @export
 * @interface SiteLastPackagesElementModel
 */
export interface SiteLastPackagesElementModel {
    /**
     * subtask id
     * @type {number}
     * @memberof SiteLastPackagesElementModel
     */
    'subtask_id'?: number;
    /**
     * subtask created by
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'subtask_userid'?: string;
    /**
     * subtask type [build|rebuild|delete]
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'subtask_type'?: string;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'summary'?: string;
    /**
     * package buildtime
     * @type {number}
     * @memberof SiteLastPackagesElementModel
     */
    'buildtime'?: number;
    /**
     * package last changelog name
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'changelog_name'?: string;
    /**
     * package last changelog nickname
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'changelog_nickname'?: string;
    /**
     * package last changelog message date
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'changelog_date'?: string;
    /**
     * package last changelog message
     * @type {string}
     * @memberof SiteLastPackagesElementModel
     */
    'changelog_text'?: string;
}
/**
 * 
 * @export
 * @interface SiteLastPackagesModel
 */
export interface SiteLastPackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteLastPackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SiteLastPackagesModel
     */
    'length'?: number;
    /**
     * last tasks packages information
     * @type {Array<SiteLastPackagesPackageModel>}
     * @memberof SiteLastPackagesModel
     */
    'tasks'?: Array<SiteLastPackagesPackageModel>;
    /**
     * last loaded branch task
     * @type {number}
     * @memberof SiteLastPackagesModel
     */
    'last_branch_task'?: number;
    /**
     * last loaded branch date
     * @type {string}
     * @memberof SiteLastPackagesModel
     */
    'last_branch_date'?: string;
}
/**
 * 
 * @export
 * @interface SiteLastPackagesPackageModel
 */
export interface SiteLastPackagesPackageModel {
    /**
     * task id
     * @type {number}
     * @memberof SiteLastPackagesPackageModel
     */
    'task_id'?: number;
    /**
     * task owner
     * @type {string}
     * @memberof SiteLastPackagesPackageModel
     */
    'task_owner'?: string;
    /**
     * task completed at
     * @type {string}
     * @memberof SiteLastPackagesPackageModel
     */
    'task_changed'?: string;
    /**
     * task message
     * @type {string}
     * @memberof SiteLastPackagesPackageModel
     */
    'task_message'?: string;
    /**
     * task subtasks packages information
     * @type {Array<SiteLastPackagesElementModel>}
     * @memberof SiteLastPackagesPackageModel
     */
    'packages'?: Array<SiteLastPackagesElementModel>;
}
/**
 * 
 * @export
 * @interface SiteLastPackagesWithCVEFixesElementModel
 */
export interface SiteLastPackagesWithCVEFixesElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SiteLastPackagesWithCVEFixesElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SiteLastPackagesWithCVEFixesElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SiteLastPackagesWithCVEFixesElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SiteLastPackagesWithCVEFixesElementModel
     */
    'release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof SiteLastPackagesWithCVEFixesElementModel
     */
    'summary'?: string;
    /**
     * package buildtime
     * @type {number}
     * @memberof SiteLastPackagesWithCVEFixesElementModel
     */
    'buildtime'?: number;
    /**
     * package last changelog date (ISO 8601 format)
     * @type {string}
     * @memberof SiteLastPackagesWithCVEFixesElementModel
     */
    'changelog_date'?: string;
    /**
     * package last changelog text
     * @type {string}
     * @memberof SiteLastPackagesWithCVEFixesElementModel
     */
    'changelog_text'?: string;
}
/**
 * 
 * @export
 * @interface SiteLastPackagesWithCVEFixesModel
 */
export interface SiteLastPackagesWithCVEFixesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteLastPackagesWithCVEFixesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SiteLastPackagesWithCVEFixesModel
     */
    'length'?: number;
    /**
     * last packages with CVE fixes information
     * @type {Array<SiteLastPackagesWithCVEFixesElementModel>}
     * @memberof SiteLastPackagesWithCVEFixesModel
     */
    'packages'?: Array<SiteLastPackagesWithCVEFixesElementModel>;
}
/**
 * 
 * @export
 * @interface SitePackageBeehiveElementModel
 */
export interface SitePackageBeehiveElementModel {
    /**
     * Beehive rebuild arch
     * @type {string}
     * @memberof SitePackageBeehiveElementModel
     */
    'arch'?: string;
    /**
     * Beehive rebuild status
     * @type {string}
     * @memberof SitePackageBeehiveElementModel
     */
    'status'?: string;
    /**
     * Beehive rebuild date
     * @type {string}
     * @memberof SitePackageBeehiveElementModel
     */
    'updated'?: string;
    /**
     * Beehive package build elapsed (seconds)
     * @type {number}
     * @memberof SitePackageBeehiveElementModel
     */
    'build_time'?: number;
    /**
     * Package FTBFS since date
     * @type {string}
     * @memberof SitePackageBeehiveElementModel
     */
    'ftbfs_since'?: string;
    /**
     * Beehive package build error log URL
     * @type {string}
     * @memberof SitePackageBeehiveElementModel
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface SitePackageDependenciesElementModel
 */
export interface SitePackageDependenciesElementModel {
    /**
     * the name of the dependent package
     * @type {string}
     * @memberof SitePackageDependenciesElementModel
     */
    'name'?: string;
    /**
     * the version of the dependent package
     * @type {string}
     * @memberof SitePackageDependenciesElementModel
     */
    'version'?: string;
    /**
     * dependency type
     * @type {string}
     * @memberof SitePackageDependenciesElementModel
     */
    'type'?: string;
    /**
     * dependency flag
     * @type {number}
     * @memberof SitePackageDependenciesElementModel
     */
    'flag'?: number;
    /**
     * decoded dependency flag
     * @type {Array<string>}
     * @memberof SitePackageDependenciesElementModel
     */
    'flag_decoded'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SitePackageInfoArchsModel
 */
export interface SitePackageInfoArchsModel {
    /**
     * package name
     * @type {string}
     * @memberof SitePackageInfoArchsModel
     */
    'name'?: string;
    /**
     * package arches
     * @type {Array<string>}
     * @memberof SitePackageInfoArchsModel
     */
    'archs'?: Array<string>;
    /**
     * package hash UInt64 as string
     * @type {Array<string>}
     * @memberof SitePackageInfoArchsModel
     */
    'pkghash'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SitePackageInfoChangelogElementModel
 */
export interface SitePackageInfoChangelogElementModel {
    /**
     * changelog date
     * @type {string}
     * @memberof SitePackageInfoChangelogElementModel
     */
    'date'?: string;
    /**
     * changelog name
     * @type {string}
     * @memberof SitePackageInfoChangelogElementModel
     */
    'name'?: string;
    /**
     * changelog nickname
     * @type {string}
     * @memberof SitePackageInfoChangelogElementModel
     */
    'nick'?: string;
    /**
     * changelog EVR
     * @type {string}
     * @memberof SitePackageInfoChangelogElementModel
     */
    'evr'?: string;
    /**
     * changelog message
     * @type {string}
     * @memberof SitePackageInfoChangelogElementModel
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SitePackageInfoModel
 */
export interface SitePackageInfoModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'pkghash'?: string;
    /**
     * request arguments
     * @type {object}
     * @memberof SitePackageInfoModel
     */
    'request_args'?: object;
    /**
     * package name
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'release'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'arch'?: string;
    /**
     * package build time
     * @type {number}
     * @memberof SitePackageInfoModel
     */
    'buildtime'?: number;
    /**
     * package build task
     * @type {number}
     * @memberof SitePackageInfoModel
     */
    'task'?: number;
    /**
     * task build date (ISO 8601 format)
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'task_date'?: string;
    /**
     * package task gear type
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'gear'?: string;
    /**
     * package license
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'license'?: string;
    /**
     * package group
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'category'?: string;
    /**
     * package url
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'url'?: string;
    /**
     * package vcs
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'vcs'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'summary'?: string;
    /**
     * package description
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'description'?: string;
    /**
     * package packager name
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'packager'?: string;
    /**
     * package packager nickname
     * @type {string}
     * @memberof SitePackageInfoModel
     */
    'packager_nickname'?: string;
    /**
     * binary packages
     * @type {Array<string>}
     * @memberof SitePackageInfoModel
     */
    'acl'?: Array<string>;
    /**
     * all maintainer\'s nicknames
     * @type {Array<string>}
     * @memberof SitePackageInfoModel
     */
    'maintainers'?: Array<string>;
    /**
     * List of source or binary packages by archs
     * @type {Array<SitePackageInfoArchsModel>}
     * @memberof SitePackageInfoModel
     */
    'package_archs'?: Array<SitePackageInfoArchsModel>;
    /**
     * package tasks
     * @type {Array<SitePackageTasksElementModel>}
     * @memberof SitePackageInfoModel
     */
    'tasks'?: Array<SitePackageTasksElementModel>;
    /**
     * package changelog
     * @type {Array<SitePackageInfoChangelogElementModel>}
     * @memberof SitePackageInfoModel
     */
    'changelog'?: Array<SitePackageInfoChangelogElementModel>;
    /**
     * new package version
     * @type {Array<SitePackageNewVersionModel>}
     * @memberof SitePackageInfoModel
     */
    'new_version'?: Array<SitePackageNewVersionModel>;
    /**
     * Beehive rebuild status
     * @type {Array<SitePackageBeehiveElementModel>}
     * @memberof SitePackageInfoModel
     */
    'beehive'?: Array<SitePackageBeehiveElementModel>;
    /**
     * all the dependence of the package
     * @type {Array<SitePackageDependenciesElementModel>}
     * @memberof SitePackageInfoModel
     */
    'dependencies'?: Array<SitePackageDependenciesElementModel>;
    /**
     * list of found valid license tokens
     * @type {Array<SitePackageLicenseTokensElementModel>}
     * @memberof SitePackageInfoModel
     */
    'license_tokens'?: Array<SitePackageLicenseTokensElementModel>;
}
/**
 * 
 * @export
 * @interface SitePackageLicenseTokensElementModel
 */
export interface SitePackageLicenseTokensElementModel {
    /**
     * license token
     * @type {string}
     * @memberof SitePackageLicenseTokensElementModel
     */
    'token'?: string;
    /**
     * SPDX license ID
     * @type {string}
     * @memberof SitePackageLicenseTokensElementModel
     */
    'license'?: string;
}
/**
 * 
 * @export
 * @interface SitePackageNewVersionModel
 */
export interface SitePackageNewVersionModel {
    /**
     * task id
     * @type {number}
     * @memberof SitePackageNewVersionModel
     */
    'task_id'?: number;
    /**
     * task build date
     * @type {string}
     * @memberof SitePackageNewVersionModel
     */
    'date'?: string;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackageNewVersionModel
     */
    'pkghash'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SitePackageNewVersionModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SitePackageNewVersionModel
     */
    'release'?: string;
}
/**
 * 
 * @export
 * @interface SitePackageTasksElementModel
 */
export interface SitePackageTasksElementModel {
    /**
     * task type
     * @type {string}
     * @memberof SitePackageTasksElementModel
     */
    'type'?: string;
    /**
     * task id
     * @type {number}
     * @memberof SitePackageTasksElementModel
     */
    'id'?: number;
    /**
     * task build date (ISO 8601 format)
     * @type {string}
     * @memberof SitePackageTasksElementModel
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface SitePackageVersionsElementModel
 */
export interface SitePackageVersionsElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof SitePackageVersionsElementModel
     */
    'branch'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SitePackageVersionsElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SitePackageVersionsElementModel
     */
    'release'?: string;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackageVersionsElementModel
     */
    'pkghash'?: string;
    /**
     * package was deleted from branch
     * @type {boolean}
     * @memberof SitePackageVersionsElementModel
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface SitePackagesBinaryListElementModel
 */
export interface SitePackagesBinaryListElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackagesBinaryListElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SitePackagesBinaryListElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SitePackagesBinaryListElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SitePackagesBinaryListElementModel
     */
    'release'?: string;
    /**
     * package arch
     * @type {string}
     * @memberof SitePackagesBinaryListElementModel
     */
    'arch'?: string;
}
/**
 * 
 * @export
 * @interface SitePackagesBinaryListModel
 */
export interface SitePackagesBinaryListModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SitePackagesBinaryListModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SitePackagesBinaryListModel
     */
    'length'?: number;
    /**
     * binary packages list
     * @type {Array<SitePackagesBinaryListElementModel>}
     * @memberof SitePackagesBinaryListModel
     */
    'packages'?: Array<SitePackagesBinaryListElementModel>;
    /**
     * all package versions
     * @type {Array<SitePackageVersionsElementModel>}
     * @memberof SitePackagesBinaryListModel
     */
    'versions'?: Array<SitePackageVersionsElementModel>;
}
/**
 * 
 * @export
 * @interface SitePackagesDownloadsElementModel
 */
export interface SitePackagesDownloadsElementModel {
    /**
     * package architecture
     * @type {string}
     * @memberof SitePackagesDownloadsElementModel
     */
    'arch'?: string;
    /**
     * Packages downloads
     * @type {Array<SitePackagesDownloadsPackageModel>}
     * @memberof SitePackagesDownloadsElementModel
     */
    'packages'?: Array<SitePackagesDownloadsPackageModel>;
}
/**
 * 
 * @export
 * @interface SitePackagesDownloadsModel
 */
export interface SitePackagesDownloadsModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackagesDownloadsModel
     */
    'pkghash'?: string;
    /**
     * request arguments
     * @type {object}
     * @memberof SitePackagesDownloadsModel
     */
    'request_args'?: object;
    /**
     * Packages downloads
     * @type {Array<SitePackagesDownloadsElementModel>}
     * @memberof SitePackagesDownloadsModel
     */
    'downloads'?: Array<SitePackagesDownloadsElementModel>;
}
/**
 * 
 * @export
 * @interface SitePackagesDownloadsPackageModel
 */
export interface SitePackagesDownloadsPackageModel {
    /**
     * package name
     * @type {string}
     * @memberof SitePackagesDownloadsPackageModel
     */
    'name'?: string;
    /**
     * package download link
     * @type {string}
     * @memberof SitePackagesDownloadsPackageModel
     */
    'url'?: string;
    /**
     * package MD5 checksum
     * @type {string}
     * @memberof SitePackagesDownloadsPackageModel
     */
    'md5'?: string;
    /**
     * human readable package file size
     * @type {string}
     * @memberof SitePackagesDownloadsPackageModel
     */
    'size'?: string;
}
/**
 * 
 * @export
 * @interface SitePackagesElementModel
 */
export interface SitePackagesElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'hash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'release'?: string;
    /**
     * package summary
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'summary'?: string;
    /**
     * package buildtime
     * @type {number}
     * @memberof SitePackagesElementModel
     */
    'buildtime'?: number;
    /**
     * package category
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'category'?: string;
    /**
     * package maintainer
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'maintainer'?: string;
    /**
     * package last changelog message
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'changelog'?: string;
    /**
     * package build task id
     * @type {number}
     * @memberof SitePackagesElementModel
     */
    'task_id'?: number;
    /**
     * package build subtask id
     * @type {number}
     * @memberof SitePackagesElementModel
     */
    'subtask_id'?: number;
    /**
     * package build task owner
     * @type {string}
     * @memberof SitePackagesElementModel
     */
    'task_owner'?: string;
}
/**
 * 
 * @export
 * @interface SitePackagesModel
 */
export interface SitePackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SitePackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SitePackagesModel
     */
    'length'?: number;
    /**
     * list of subcategories
     * @type {Array<string>}
     * @memberof SitePackagesModel
     */
    'subcategories'?: Array<string>;
    /**
     * unpackaged directories information
     * @type {Array<SitePackagesElementModel>}
     * @memberof SitePackagesModel
     */
    'packages'?: Array<SitePackagesElementModel>;
}
/**
 * 
 * @export
 * @interface SitePackagesetCategoriesModel
 */
export interface SitePackagesetCategoriesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SitePackagesetCategoriesModel
     */
    'request_args'?: object;
    /**
     * number of categories in list
     * @type {number}
     * @memberof SitePackagesetCategoriesModel
     */
    'length'?: number;
    /**
     * found categories
     * @type {Array<SitePackagesetCategoryElementModel>}
     * @memberof SitePackagesetCategoriesModel
     */
    'categories'?: Array<SitePackagesetCategoryElementModel>;
}
/**
 * 
 * @export
 * @interface SitePackagesetCategoryElementModel
 */
export interface SitePackagesetCategoryElementModel {
    /**
     * package category
     * @type {string}
     * @memberof SitePackagesetCategoryElementModel
     */
    'category'?: string;
    /**
     * number of packages in category
     * @type {number}
     * @memberof SitePackagesetCategoryElementModel
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SitePackagesetPackageHashByNameVersionRelease
 */
export interface SitePackagesetPackageHashByNameVersionRelease {
    /**
     * request arguments
     * @type {object}
     * @memberof SitePackagesetPackageHashByNameVersionRelease
     */
    'request_args'?: object;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackagesetPackageHashByNameVersionRelease
     */
    'pkghash'?: string;
}
/**
 * 
 * @export
 * @interface SitePackagesetPackageHashModel
 */
export interface SitePackagesetPackageHashModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SitePackagesetPackageHashModel
     */
    'request_args'?: object;
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackagesetPackageHashModel
     */
    'pkghash'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SitePackagesetPackageHashModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SitePackagesetPackageHashModel
     */
    'release'?: string;
}
/**
 * 
 * @export
 * @interface SitePackagesetStatusElementModel
 */
export interface SitePackagesetStatusElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof SitePackagesetStatusElementModel
     */
    'branch'?: string;
    /**
     * support start date
     * @type {string}
     * @memberof SitePackagesetStatusElementModel
     */
    'start_date'?: string;
    /**
     * support end date
     * @type {string}
     * @memberof SitePackagesetStatusElementModel
     */
    'end_date'?: string;
    /**
     * 0 - hide branch, 1 - show branch
     * @type {number}
     * @memberof SitePackagesetStatusElementModel
     */
    'show'?: number;
    /**
     * html description in Russian
     * @type {string}
     * @memberof SitePackagesetStatusElementModel
     */
    'description_ru'?: string;
    /**
     * html description in English
     * @type {string}
     * @memberof SitePackagesetStatusElementModel
     */
    'description_en'?: string;
    /**
     * 0 - branch has no active images, 1 - branch has active images
     * @type {number}
     * @memberof SitePackagesetStatusElementModel
     */
    'has_images'?: number;
}
/**
 * 
 * @export
 * @interface SitePackagesetsByHashModel
 */
export interface SitePackagesetsByHashModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitePackagesetsByHashModel
     */
    'pkghash'?: string;
    /**
     * number of package sets found
     * @type {number}
     * @memberof SitePackagesetsByHashModel
     */
    'length'?: number;
    /**
     * package sets
     * @type {Array<string>}
     * @memberof SitePackagesetsByHashModel
     */
    'branches'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SitePackagesetsSummaryStatusModel
 */
export interface SitePackagesetsSummaryStatusModel {
    /**
     * number of packages found
     * @type {number}
     * @memberof SitePackagesetsSummaryStatusModel
     */
    'length'?: number;
    /**
     * list of branches with source packages count
     * @type {Array<SiteAllPackagesetsSummaryBranchesModel>}
     * @memberof SitePackagesetsSummaryStatusModel
     */
    'branches'?: Array<SiteAllPackagesetsSummaryBranchesModel>;
    /**
     * list of branches status
     * @type {Array<SitePackagesetStatusElementModel>}
     * @memberof SitePackagesetsSummaryStatusModel
     */
    'status'?: Array<SitePackagesetStatusElementModel>;
}
/**
 * 
 * @export
 * @interface SiteSourcePackagesVersionsModel
 */
export interface SiteSourcePackagesVersionsModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteSourcePackagesVersionsModel
     */
    'request_args'?: object;
    /**
     * Packages downloads
     * @type {Array<SitePackageVersionsElementModel>}
     * @memberof SiteSourcePackagesVersionsModel
     */
    'versions'?: Array<SitePackageVersionsElementModel>;
}
/**
 * 
 * @export
 * @interface SiteTaskByNameModel
 */
export interface SiteTaskByNameModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteTaskByNameModel
     */
    'request_args'?: object;
    /**
     * number of tasks found
     * @type {number}
     * @memberof SiteTaskByNameModel
     */
    'length'?: number;
    /**
     * tasks list
     * @type {Array<SiteTaskByNameTaskModel>}
     * @memberof SiteTaskByNameModel
     */
    'tasks'?: Array<SiteTaskByNameTaskModel>;
}
/**
 * 
 * @export
 * @interface SiteTaskByNamePackageModel
 */
export interface SiteTaskByNamePackageModel {
    /**
     * subtask type [gear|srpm|delete|search]
     * @type {string}
     * @memberof SiteTaskByNamePackageModel
     */
    'type'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SiteTaskByNamePackageModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof SiteTaskByNamePackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof SiteTaskByNamePackageModel
     */
    'release'?: string;
    /**
     * package git link
     * @type {string}
     * @memberof SiteTaskByNamePackageModel
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface SiteTaskByNameTaskModel
 */
export interface SiteTaskByNameTaskModel {
    /**
     * task id
     * @type {number}
     * @memberof SiteTaskByNameTaskModel
     */
    'id'?: number;
    /**
     * task state
     * @type {string}
     * @memberof SiteTaskByNameTaskModel
     */
    'state'?: string;
    /**
     * task branch
     * @type {string}
     * @memberof SiteTaskByNameTaskModel
     */
    'branch'?: string;
    /**
     * task owner nickname
     * @type {string}
     * @memberof SiteTaskByNameTaskModel
     */
    'owner'?: string;
    /**
     * task last changed (ISO 8601 format)
     * @type {string}
     * @memberof SiteTaskByNameTaskModel
     */
    'changed'?: string;
    /**
     * task packages
     * @type {Array<SiteTaskByNamePackageModel>}
     * @memberof SiteTaskByNameTaskModel
     */
    'packages'?: Array<SiteTaskByNamePackageModel>;
}
/**
 * 
 * @export
 * @interface SiteTasksHistoryModel
 */
export interface SiteTasksHistoryModel {
    /**
     * list of active branches
     * @type {Array<string>}
     * @memberof SiteTasksHistoryModel
     */
    'branches'?: Array<string>;
    /**
     * branches tasks list
     * @type {Array<TasksHistoryTaskModel>}
     * @memberof SiteTasksHistoryModel
     */
    'tasks'?: Array<TasksHistoryTaskModel>;
    /**
     * branches commits list
     * @type {Array<TasksHistoryBranchCommitModel>}
     * @memberof SiteTasksHistoryModel
     */
    'branch_commits'?: Array<TasksHistoryBranchCommitModel>;
}
/**
 * 
 * @export
 * @interface SiteWatchByMaintainerElementModel
 */
export interface SiteWatchByMaintainerElementModel {
    /**
     * package name
     * @type {string}
     * @memberof SiteWatchByMaintainerElementModel
     */
    'pkg_name'?: string;
    /**
     * old package version
     * @type {string}
     * @memberof SiteWatchByMaintainerElementModel
     */
    'old_version'?: string;
    /**
     * new package version
     * @type {string}
     * @memberof SiteWatchByMaintainerElementModel
     */
    'new_version'?: string;
    /**
     * package name from repology
     * @type {string}
     * @memberof SiteWatchByMaintainerElementModel
     */
    'repology_name'?: string;
    /**
     * url for download src
     * @type {string}
     * @memberof SiteWatchByMaintainerElementModel
     */
    'url'?: string;
    /**
     * Watch update date
     * @type {string}
     * @memberof SiteWatchByMaintainerElementModel
     */
    'date_update'?: string;
}
/**
 * 
 * @export
 * @interface SiteWatchByMaintainerModel
 */
export interface SiteWatchByMaintainerModel {
    /**
     * request arguments
     * @type {object}
     * @memberof SiteWatchByMaintainerModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof SiteWatchByMaintainerModel
     */
    'length'?: number;
    /**
     * found packages
     * @type {Array<SiteWatchByMaintainerElementModel>}
     * @memberof SiteWatchByMaintainerModel
     */
    'packages'?: Array<SiteWatchByMaintainerElementModel>;
}
/**
 * 
 * @export
 * @interface SitemapPackagesElementModel
 */
export interface SitemapPackagesElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof SitemapPackagesElementModel
     */
    'pkghash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof SitemapPackagesElementModel
     */
    'name'?: string;
    /**
     * package buildtime
     * @type {number}
     * @memberof SitemapPackagesElementModel
     */
    'buildtime'?: number;
}
/**
 * 
 * @export
 * @interface SitemapPackagesExportModel
 */
export interface SitemapPackagesExportModel {
    /**
     * package set name
     * @type {string}
     * @memberof SitemapPackagesExportModel
     */
    'branch'?: string;
    /**
     * source packages info
     * @type {Array<SitemapPackagesElementModel>}
     * @memberof SitemapPackagesExportModel
     */
    'packages'?: Array<SitemapPackagesElementModel>;
}
/**
 * 
 * @export
 * @interface SubTaskArchitectureModel
 */
export interface SubTaskArchitectureModel {
    /**
     * stage status
     * @type {string}
     * @memberof SubTaskArchitectureModel
     */
    'stage_status'?: string;
    /**
     * subtask architecture
     * @type {string}
     * @memberof SubTaskArchitectureModel
     */
    'arch'?: string;
}
/**
 * 
 * @export
 * @interface SubTaskInfoElementModel
 */
export interface SubTaskInfoElementModel {
    /**
     * subtasks id
     * @type {number}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_id'?: number;
    /**
     * subtask type
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_type'?: string;
    /**
     * subtask srpm
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_srpm'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_srpm_name'?: string;
    /**
     * source package version and release
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_srpm_evr'?: string;
    /**
     * subtask dir
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_dir'?: string;
    /**
     * subtask tag id
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_tag_id'?: string;
    /**
     * subtask tag name
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_tag_name'?: string;
    /**
     * subtask tag author
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_tag_author'?: string;
    /**
     * subtask package
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_package'?: string;
    /**
     * subtask package from
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_pkg_from'?: string;
    /**
     * subtask changed
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'subtask_changed'?: string;
    /**
     * subtask type
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'type'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'src_pkg_name'?: string;
    /**
     * source package hash
     * @type {string}
     * @memberof SubTaskInfoElementModel
     */
    'src_pkg_hash'?: string;
    /**
     * list of subtask architectures
     * @type {Array<SubTaskArchitectureModel>}
     * @memberof SubTaskInfoElementModel
     */
    'archs'?: Array<SubTaskArchitectureModel>;
    /**
     * list of approvals for task
     * @type {Array<TaskApprovalElementModel>}
     * @memberof SubTaskInfoElementModel
     */
    'approval'?: Array<TaskApprovalElementModel>;
}
/**
 * 
 * @export
 * @interface SubTasksElementModel
 */
export interface SubTasksElementModel {
    /**
     * subtasks id
     * @type {number}
     * @memberof SubTasksElementModel
     */
    'subtask_id'?: number;
    /**
     * subtask type
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_type'?: string;
    /**
     * subtask srpm
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_srpm'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_srpm_name'?: string;
    /**
     * source package version and release
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_srpm_evr'?: string;
    /**
     * subtask dir
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_dir'?: string;
    /**
     * subtask tag id
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_tag_id'?: string;
    /**
     * subtask tag name
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_tag_name'?: string;
    /**
     * subtask tag author
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_tag_author'?: string;
    /**
     * subtask package
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_package'?: string;
    /**
     * subtask package from
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_pkg_from'?: string;
    /**
     * subtask changed
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'subtask_changed'?: string;
    /**
     * subtask type
     * @type {string}
     * @memberof SubTasksElementModel
     */
    'type'?: string;
    /**
     * list of subtask architectures
     * @type {Array<SubTaskArchitectureModel>}
     * @memberof SubTasksElementModel
     */
    'archs'?: Array<SubTaskArchitectureModel>;
}
/**
 * 
 * @export
 * @interface TaskApprovalElementModel
 */
export interface TaskApprovalElementModel {
    /**
     * approval type
     * @type {string}
     * @memberof TaskApprovalElementModel
     */
    'type'?: string;
    /**
     * maintainer nickname
     * @type {string}
     * @memberof TaskApprovalElementModel
     */
    'nickname'?: string;
    /**
     * approval message
     * @type {string}
     * @memberof TaskApprovalElementModel
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface TaskBuildDependencyElementModel
 */
export interface TaskBuildDependencyElementModel {
    /**
     * package dependenyc depth
     * @type {number}
     * @memberof TaskBuildDependencyElementModel
     */
    'depth'?: number;
    /**
     * package name
     * @type {string}
     * @memberof TaskBuildDependencyElementModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof TaskBuildDependencyElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof TaskBuildDependencyElementModel
     */
    'release'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof TaskBuildDependencyElementModel
     */
    'epoch'?: number;
    /**
     * package serial
     * @type {number}
     * @memberof TaskBuildDependencyElementModel
     */
    'serial'?: number;
    /**
     * source package file
     * @type {string}
     * @memberof TaskBuildDependencyElementModel
     */
    'sourcerpm'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof TaskBuildDependencyElementModel
     */
    'branch'?: string;
    /**
     * package build time
     * @type {string}
     * @memberof TaskBuildDependencyElementModel
     */
    'buildtime'?: string;
    /**
     * package archs
     * @type {Array<string>}
     * @memberof TaskBuildDependencyElementModel
     */
    'archs'?: Array<string>;
    /**
     * package cycle dependencies
     * @type {Array<string>}
     * @memberof TaskBuildDependencyElementModel
     */
    'cycle'?: Array<string>;
    /**
     * package requirements
     * @type {Array<string>}
     * @memberof TaskBuildDependencyElementModel
     */
    'requires'?: Array<string>;
    /**
     * package ACL list
     * @type {Array<string>}
     * @memberof TaskBuildDependencyElementModel
     */
    'acl'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaskBuildDependencyModel
 */
export interface TaskBuildDependencyModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskBuildDependencyModel
     */
    'id'?: number;
    /**
     * request arguments
     * @type {object}
     * @memberof TaskBuildDependencyModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof TaskBuildDependencyModel
     */
    'length'?: number;
    /**
     * build dependency results
     * @type {Array<TaskBuildDependencyElementModel>}
     * @memberof TaskBuildDependencyModel
     */
    'dependencies'?: Array<TaskBuildDependencyElementModel>;
}
/**
 * 
 * @export
 * @interface TaskDiffArchsModel
 */
export interface TaskDiffArchsModel {
    /**
     * 
     * @type {string}
     * @memberof TaskDiffArchsModel
     */
    'arch'?: string;
    /**
     * 
     * @type {Array<TaskDiffPackagesModel>}
     * @memberof TaskDiffArchsModel
     */
    'packages'?: Array<TaskDiffPackagesModel>;
}
/**
 * 
 * @export
 * @interface TaskDiffDependenciesModel
 */
export interface TaskDiffDependenciesModel {
    /**
     * 
     * @type {string}
     * @memberof TaskDiffDependenciesModel
     */
    'type'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDiffDependenciesModel
     */
    'del'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDiffDependenciesModel
     */
    'add'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaskDiffModel
 */
export interface TaskDiffModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskDiffModel
     */
    'task_id'?: number;
    /**
     * task have package hashses add/delete plan
     * @type {boolean}
     * @memberof TaskDiffModel
     */
    'task_have_plan'?: boolean;
    /**
     * task diff
     * @type {Array<TaskDiffArchsModel>}
     * @memberof TaskDiffModel
     */
    'task_diff'?: Array<TaskDiffArchsModel>;
}
/**
 * 
 * @export
 * @interface TaskDiffPackagesModel
 */
export interface TaskDiffPackagesModel {
    /**
     * 
     * @type {string}
     * @memberof TaskDiffPackagesModel
     */
    'package'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDiffPackagesModel
     */
    'del'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDiffPackagesModel
     */
    'add'?: Array<string>;
    /**
     * 
     * @type {Array<TaskDiffDependenciesModel>}
     * @memberof TaskDiffPackagesModel
     */
    'dependencies'?: Array<TaskDiffDependenciesModel>;
}
/**
 * 
 * @export
 * @interface TaskFindPackagesetElementModel
 */
export interface TaskFindPackagesetElementModel {
    /**
     * package set name
     * @type {string}
     * @memberof TaskFindPackagesetElementModel
     */
    'branch'?: string;
    /**
     * package set date
     * @type {string}
     * @memberof TaskFindPackagesetElementModel
     */
    'pkgset_datetime'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof TaskFindPackagesetElementModel
     */
    'sourcepkgname'?: string;
    /**
     * binary packages list
     * @type {Array<string>}
     * @memberof TaskFindPackagesetElementModel
     */
    'packages'?: Array<string>;
    /**
     * package version
     * @type {string}
     * @memberof TaskFindPackagesetElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof TaskFindPackagesetElementModel
     */
    'release'?: string;
    /**
     * package disttag
     * @type {string}
     * @memberof TaskFindPackagesetElementModel
     */
    'disttag'?: string;
    /**
     * package packager email
     * @type {string}
     * @memberof TaskFindPackagesetElementModel
     */
    'packager_email'?: string;
    /**
     * package build time
     * @type {string}
     * @memberof TaskFindPackagesetElementModel
     */
    'buildtime'?: string;
    /**
     * binary packages archs
     * @type {Array<string>}
     * @memberof TaskFindPackagesetElementModel
     */
    'archs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaskFindPackagesetModel
 */
export interface TaskFindPackagesetModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskFindPackagesetModel
     */
    'id'?: number;
    /**
     * request arguments
     * @type {object}
     * @memberof TaskFindPackagesetModel
     */
    'request_args'?: object;
    /**
     * request arguments
     * @type {Array<string>}
     * @memberof TaskFindPackagesetModel
     */
    'task_packages'?: Array<string>;
    /**
     * number of packages found
     * @type {number}
     * @memberof TaskFindPackagesetModel
     */
    'length'?: number;
    /**
     * package set packages information
     * @type {Array<TaskFindPackagesetElementModel>}
     * @memberof TaskFindPackagesetModel
     */
    'packages'?: Array<TaskFindPackagesetElementModel>;
}
/**
 * 
 * @export
 * @interface TaskHistoryElementModel
 */
export interface TaskHistoryElementModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskHistoryElementModel
     */
    'task_id'?: number;
    /**
     * task commited date in ISO8601 format
     * @type {string}
     * @memberof TaskHistoryElementModel
     */
    'task_commited'?: string;
    /**
     * branch commited date in ISO8601 format
     * @type {string}
     * @memberof TaskHistoryElementModel
     */
    'branch_commited'?: string;
}
/**
 * 
 * @export
 * @interface TaskHistoryModel
 */
export interface TaskHistoryModel {
    /**
     * request arguments
     * @type {object}
     * @memberof TaskHistoryModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof TaskHistoryModel
     */
    'length'?: number;
    /**
     * build requirements packages information
     * @type {Array<TaskHistoryElementModel>}
     * @memberof TaskHistoryModel
     */
    'tasks'?: Array<TaskHistoryElementModel>;
}
/**
 * 
 * @export
 * @interface TaskInfoApprovalsModel
 */
export interface TaskInfoApprovalsModel {
    /**
     * approval date
     * @type {string}
     * @memberof TaskInfoApprovalsModel
     */
    'date'?: string;
    /**
     * approval type
     * @type {string}
     * @memberof TaskInfoApprovalsModel
     */
    'type'?: string;
    /**
     * approver name
     * @type {string}
     * @memberof TaskInfoApprovalsModel
     */
    'name'?: string;
    /**
     * approval message
     * @type {string}
     * @memberof TaskInfoApprovalsModel
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface TaskInfoArchsModel
 */
export interface TaskInfoArchsModel {
    /**
     * iteration state last changed
     * @type {string}
     * @memberof TaskInfoArchsModel
     */
    'last_changed'?: string;
    /**
     * iteration arch
     * @type {string}
     * @memberof TaskInfoArchsModel
     */
    'arch'?: string;
    /**
     * iteration state
     * @type {string}
     * @memberof TaskInfoArchsModel
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface TaskInfoModel
 */
export interface TaskInfoModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskInfoModel
     */
    'id'?: number;
    /**
     * previous task id
     * @type {number}
     * @memberof TaskInfoModel
     */
    'prev'?: number;
    /**
     * task try
     * @type {number}
     * @memberof TaskInfoModel
     */
    'try'?: number;
    /**
     * task iteration
     * @type {number}
     * @memberof TaskInfoModel
     */
    'iter'?: number;
    /**
     * all task rebuilds
     * @type {Array<string>}
     * @memberof TaskInfoModel
     */
    'rebuilds'?: Array<string>;
    /**
     * task state
     * @type {string}
     * @memberof TaskInfoModel
     */
    'state'?: string;
    /**
     * task branch
     * @type {string}
     * @memberof TaskInfoModel
     */
    'branch'?: string;
    /**
     * task owner
     * @type {string}
     * @memberof TaskInfoModel
     */
    'user'?: string;
    /**
     * task ran by
     * @type {string}
     * @memberof TaskInfoModel
     */
    'runby'?: string;
    /**
     * testonly flag
     * @type {number}
     * @memberof TaskInfoModel
     */
    'testonly'?: number;
    /**
     * failearly flag
     * @type {number}
     * @memberof TaskInfoModel
     */
    'failearly'?: number;
    /**
     * shared flag
     * @type {number}
     * @memberof TaskInfoModel
     */
    'shared'?: number;
    /**
     * task depends on
     * @type {Array<number>}
     * @memberof TaskInfoModel
     */
    'depends'?: Array<number>;
    /**
     * task message
     * @type {string}
     * @memberof TaskInfoModel
     */
    'message'?: string;
    /**
     * task version
     * @type {string}
     * @memberof TaskInfoModel
     */
    'version'?: string;
    /**
     * task state last changed
     * @type {string}
     * @memberof TaskInfoModel
     */
    'last_changed'?: string;
    /**
     * task subtasks
     * @type {Array<TaskInfoSubtaskModel>}
     * @memberof TaskInfoModel
     */
    'subtasks'?: Array<TaskInfoSubtaskModel>;
    /**
     * task packages add/delete
     * @type {TaskInfoPlan2Model}
     * @memberof TaskInfoModel
     */
    'plan'?: TaskInfoPlan2Model;
}
/**
 * 
 * @export
 * @interface TaskInfoPackageModel
 */
export interface TaskInfoPackageModel {
    /**
     * package name
     * @type {string}
     * @memberof TaskInfoPackageModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof TaskInfoPackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof TaskInfoPackageModel
     */
    'release'?: string;
    /**
     * package file name
     * @type {string}
     * @memberof TaskInfoPackageModel
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface TaskInfoPlan2Model
 */
export interface TaskInfoPlan2Model {
    /**
     * added packages
     * @type {TaskInfoPlanModel}
     * @memberof TaskInfoPlan2Model
     */
    'add'?: TaskInfoPlanModel;
    /**
     * deleted packages
     * @type {TaskInfoPlanModel}
     * @memberof TaskInfoPlan2Model
     */
    'del'?: TaskInfoPlanModel;
}
/**
 * 
 * @export
 * @interface TaskInfoPlanModel
 */
export interface TaskInfoPlanModel {
    /**
     * source packages
     * @type {Array<TaskInfoPackageModel>}
     * @memberof TaskInfoPlanModel
     */
    'src'?: Array<TaskInfoPackageModel>;
    /**
     * binary packages
     * @type {Array<TaskInfoPackageModel>}
     * @memberof TaskInfoPlanModel
     */
    'bin'?: Array<TaskInfoPackageModel>;
}
/**
 * 
 * @export
 * @interface TaskInfoSubtaskModel
 */
export interface TaskInfoSubtaskModel {
    /**
     * subtask id
     * @type {number}
     * @memberof TaskInfoSubtaskModel
     */
    'subtask_id'?: number;
    /**
     * subtask state last changed
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'last_changed'?: string;
    /**
     * subtask creator
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'userid'?: string;
    /**
     * subtask type
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'type'?: string;
    /**
     * subtask sid
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'sid'?: string;
    /**
     * subtask dir
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'dir'?: string;
    /**
     * subtask package
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'package'?: string;
    /**
     * gear tag author
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'tag_author'?: string;
    /**
     * gear tag name
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'tag_name'?: string;
    /**
     * gear tag id
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'tag_id'?: string;
    /**
     * source package
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'srpm'?: string;
    /**
     * source package name
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'srpm_name'?: string;
    /**
     * source package EVR
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'srpm_evr'?: string;
    /**
     * package copy from
     * @type {string}
     * @memberof TaskInfoSubtaskModel
     */
    'pkg_from'?: string;
    /**
     * 
     * @type {TaskInfoPackageModel}
     * @memberof TaskInfoSubtaskModel
     */
    'source_package'?: TaskInfoPackageModel;
    /**
     * subtask approvals
     * @type {Array<TaskInfoApprovalsModel>}
     * @memberof TaskInfoSubtaskModel
     */
    'approvals'?: Array<TaskInfoApprovalsModel>;
    /**
     * subtask archs
     * @type {Array<TaskInfoArchsModel>}
     * @memberof TaskInfoSubtaskModel
     */
    'archs'?: Array<TaskInfoArchsModel>;
}
/**
 * 
 * @export
 * @interface TaskIterationsElementModel
 */
export interface TaskIterationsElementModel {
    /**
     * task try number
     * @type {number}
     * @memberof TaskIterationsElementModel
     */
    'task_try'?: number;
    /**
     * task iteration number
     * @type {number}
     * @memberof TaskIterationsElementModel
     */
    'task_iter'?: number;
}
/**
 * 
 * @export
 * @interface TaskMisconflictPackageModel
 */
export interface TaskMisconflictPackageModel {
    /**
     * package name
     * @type {string}
     * @memberof TaskMisconflictPackageModel
     */
    'input_package'?: string;
    /**
     * package name
     * @type {string}
     * @memberof TaskMisconflictPackageModel
     */
    'conflict_package'?: string;
    /**
     * package version
     * @type {string}
     * @memberof TaskMisconflictPackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof TaskMisconflictPackageModel
     */
    'release'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof TaskMisconflictPackageModel
     */
    'epoch'?: number;
    /**
     * package archs
     * @type {Array<string>}
     * @memberof TaskMisconflictPackageModel
     */
    'archs'?: Array<string>;
    /**
     * conflict files
     * @type {Array<string>}
     * @memberof TaskMisconflictPackageModel
     */
    'files_with_conflict'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TaskMisconflictPackagesModel
 */
export interface TaskMisconflictPackagesModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskMisconflictPackagesModel
     */
    'id'?: number;
    /**
     * request arguments
     * @type {object}
     * @memberof TaskMisconflictPackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof TaskMisconflictPackagesModel
     */
    'length'?: number;
    /**
     * conflicts
     * @type {Array<TaskMisconflictPackageModel>}
     * @memberof TaskMisconflictPackagesModel
     */
    'conflicts'?: Array<TaskMisconflictPackageModel>;
}
/**
 * 
 * @export
 * @interface TaskPackagesModel
 */
export interface TaskPackagesModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskPackagesModel
     */
    'id'?: number;
    /**
     * task repo
     * @type {string}
     * @memberof TaskPackagesModel
     */
    'repo'?: string;
    /**
     * task owner
     * @type {string}
     * @memberof TaskPackagesModel
     */
    'owner'?: string;
    /**
     * task state
     * @type {string}
     * @memberof TaskPackagesModel
     */
    'state'?: string;
    /**
     * task is test-only
     * @type {number}
     * @memberof TaskPackagesModel
     */
    'testonly'?: number;
    /**
     * task last try
     * @type {number}
     * @memberof TaskPackagesModel
     */
    'try'?: number;
    /**
     * task last iteration
     * @type {number}
     * @memberof TaskPackagesModel
     */
    'iter'?: number;
    /**
     * task message
     * @type {string}
     * @memberof TaskPackagesModel
     */
    'message'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof TaskPackagesModel
     */
    'dependencies'?: Array<number>;
    /**
     * number of subtasks found
     * @type {number}
     * @memberof TaskPackagesModel
     */
    'length'?: number;
    /**
     * subtask packages
     * @type {Array<TaskPackagesSubtaskElementModel>}
     * @memberof TaskPackagesModel
     */
    'subtasks'?: Array<TaskPackagesSubtaskElementModel>;
    /**
     * arepo packages
     * @type {Array<TaskPackagesPackageElementModel>}
     * @memberof TaskPackagesModel
     */
    'arepo'?: Array<TaskPackagesPackageElementModel>;
}
/**
 * 
 * @export
 * @interface TaskPackagesPackageElementModel
 */
export interface TaskPackagesPackageElementModel {
    /**
     * package name
     * @type {string}
     * @memberof TaskPackagesPackageElementModel
     */
    'name'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof TaskPackagesPackageElementModel
     */
    'epoch'?: number;
    /**
     * package version
     * @type {string}
     * @memberof TaskPackagesPackageElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof TaskPackagesPackageElementModel
     */
    'release'?: string;
    /**
     * package disttag
     * @type {string}
     * @memberof TaskPackagesPackageElementModel
     */
    'disttag'?: string;
    /**
     * package build time
     * @type {string}
     * @memberof TaskPackagesPackageElementModel
     */
    'buildtime'?: string;
    /**
     * package architecture
     * @type {string}
     * @memberof TaskPackagesPackageElementModel
     */
    'arch'?: string;
}
/**
 * 
 * @export
 * @interface TaskPackagesSubtaskElementModel
 */
export interface TaskPackagesSubtaskElementModel {
    /**
     * subtask id
     * @type {number}
     * @memberof TaskPackagesSubtaskElementModel
     */
    'subtask'?: number;
    /**
     * source package
     * @type {TaskPackagesPackageElementModel}
     * @memberof TaskPackagesSubtaskElementModel
     */
    'source'?: TaskPackagesPackageElementModel;
    /**
     * binary packages
     * @type {Array<TaskPackagesPackageElementModel>}
     * @memberof TaskPackagesSubtaskElementModel
     */
    'binaries'?: Array<TaskPackagesPackageElementModel>;
}
/**
 * 
 * @export
 * @interface TaskProgressTaskInfoModel
 */
export interface TaskProgressTaskInfoModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_id'?: number;
    /**
     * repository name
     * @type {string}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_repo'?: string;
    /**
     * task state
     * @type {string}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_state'?: string;
    /**
     * task owner
     * @type {string}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_owner'?: string;
    /**
     * task try number
     * @type {number}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_try'?: number;
    /**
     * task iteration number
     * @type {number}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_iter'?: number;
    /**
     * task test only
     * @type {number}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_testonly'?: number;
    /**
     * task changed
     * @type {string}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_changed'?: string;
    /**
     * task message
     * @type {string}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_message'?: string;
    /**
     * task stage
     * @type {string}
     * @memberof TaskProgressTaskInfoModel
     */
    'task_stage'?: string;
    /**
     * task dependencies
     * @type {Array<number>}
     * @memberof TaskProgressTaskInfoModel
     */
    'dependencies'?: Array<number>;
    /**
     * list of subtasks by task
     * @type {Array<SubTaskInfoElementModel>}
     * @memberof TaskProgressTaskInfoModel
     */
    'subtasks'?: Array<SubTaskInfoElementModel>;
    /**
     * task iteration list
     * @type {Array<TaskIterationsElementModel>}
     * @memberof TaskProgressTaskInfoModel
     */
    'iterations'?: Array<TaskIterationsElementModel>;
}
/**
 * 
 * @export
 * @interface TaskRepoArchsModel
 */
export interface TaskRepoArchsModel {
    /**
     * architecture
     * @type {string}
     * @memberof TaskRepoArchsModel
     */
    'arch'?: string;
    /**
     * packages list
     * @type {Array<TaskRepoPackageModel>}
     * @memberof TaskRepoArchsModel
     */
    'packages'?: Array<TaskRepoPackageModel>;
}
/**
 * 
 * @export
 * @interface TaskRepoInfoModel
 */
export interface TaskRepoInfoModel {
    /**
     * package set name
     * @type {string}
     * @memberof TaskRepoInfoModel
     */
    'name'?: string;
    /**
     * package set upload date in ISO8601 format
     * @type {string}
     * @memberof TaskRepoInfoModel
     */
    'date'?: string;
    /**
     * package set upload tag
     * @type {string}
     * @memberof TaskRepoInfoModel
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface TaskRepoModel
 */
export interface TaskRepoModel {
    /**
     * task id
     * @type {number}
     * @memberof TaskRepoModel
     */
    'task_id'?: number;
    /**
     * last uploaded package set used as base
     * @type {TaskRepoInfoModel}
     * @memberof TaskRepoModel
     */
    'base_repository'?: TaskRepoInfoModel;
    /**
     * list of tasks applied to base package set
     * @type {Array<number>}
     * @memberof TaskRepoModel
     */
    'task_diff_list'?: Array<number>;
    /**
     * list of packages by architectures
     * @type {Array<TaskRepoArchsModel>}
     * @memberof TaskRepoModel
     */
    'archs'?: Array<TaskRepoArchsModel>;
}
/**
 * 
 * @export
 * @interface TaskRepoPackageModel
 */
export interface TaskRepoPackageModel {
    /**
     * package name
     * @type {string}
     * @memberof TaskRepoPackageModel
     */
    'name'?: string;
    /**
     * package version
     * @type {string}
     * @memberof TaskRepoPackageModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof TaskRepoPackageModel
     */
    'release'?: string;
    /**
     * package file name
     * @type {string}
     * @memberof TaskRepoPackageModel
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface TasksHistoryBranchCommitModel
 */
export interface TasksHistoryBranchCommitModel {
    /**
     * branch name
     * @type {string}
     * @memberof TasksHistoryBranchCommitModel
     */
    'name'?: string;
    /**
     * branch commit date
     * @type {string}
     * @memberof TasksHistoryBranchCommitModel
     */
    'date'?: string;
    /**
     * branch commit task ID
     * @type {number}
     * @memberof TasksHistoryBranchCommitModel
     */
    'task'?: number;
}
/**
 * 
 * @export
 * @interface TasksHistoryTaskModel
 */
export interface TasksHistoryTaskModel {
    /**
     * task ID
     * @type {number}
     * @memberof TasksHistoryTaskModel
     */
    'id'?: number;
    /**
     * previous task ID
     * @type {number}
     * @memberof TasksHistoryTaskModel
     */
    'prev'?: number;
    /**
     * task branch name
     * @type {string}
     * @memberof TasksHistoryTaskModel
     */
    'branch'?: string;
    /**
     * task build time
     * @type {string}
     * @memberof TasksHistoryTaskModel
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface TasksListElementModel
 */
export interface TasksListElementModel {
    /**
     * task id
     * @type {number}
     * @memberof TasksListElementModel
     */
    'task_id'?: number;
    /**
     * repository name
     * @type {string}
     * @memberof TasksListElementModel
     */
    'task_repo'?: string;
    /**
     * task state
     * @type {string}
     * @memberof TasksListElementModel
     */
    'task_state'?: string;
    /**
     * task owner
     * @type {string}
     * @memberof TasksListElementModel
     */
    'task_owner'?: string;
    /**
     * task try number
     * @type {number}
     * @memberof TasksListElementModel
     */
    'task_try'?: number;
    /**
     * task iteration number
     * @type {number}
     * @memberof TasksListElementModel
     */
    'task_iter'?: number;
    /**
     * task test only
     * @type {number}
     * @memberof TasksListElementModel
     */
    'task_testonly'?: number;
    /**
     * task changed
     * @type {string}
     * @memberof TasksListElementModel
     */
    'task_changed'?: string;
    /**
     * task message
     * @type {string}
     * @memberof TasksListElementModel
     */
    'task_message'?: string;
    /**
     * task stage
     * @type {string}
     * @memberof TasksListElementModel
     */
    'task_stage'?: string;
    /**
     * task dependencies
     * @type {Array<number>}
     * @memberof TasksListElementModel
     */
    'dependencies'?: Array<number>;
    /**
     * list of subtasks by task
     * @type {Array<SubTasksElementModel>}
     * @memberof TasksListElementModel
     */
    'subtasks'?: Array<SubTasksElementModel>;
    /**
     * list of approvals for task
     * @type {Array<TaskApprovalElementModel>}
     * @memberof TasksListElementModel
     */
    'approval'?: Array<TaskApprovalElementModel>;
}
/**
 * 
 * @export
 * @interface TasksListModel
 */
export interface TasksListModel {
    /**
     * request arguments
     * @type {object}
     * @memberof TasksListModel
     */
    'request_args'?: object;
    /**
     * number of tasks found
     * @type {number}
     * @memberof TasksListModel
     */
    'length'?: number;
    /**
     * list of latest task changes
     * @type {Array<TasksListElementModel>}
     * @memberof TasksListModel
     */
    'tasks'?: Array<TasksListElementModel>;
}
/**
 * 
 * @export
 * @interface UnpackagedDirsElementModel
 */
export interface UnpackagedDirsElementModel {
    /**
     * package name
     * @type {string}
     * @memberof UnpackagedDirsElementModel
     */
    'package'?: string;
    /**
     * unpackaged directory
     * @type {string}
     * @memberof UnpackagedDirsElementModel
     */
    'directory'?: string;
    /**
     * package version
     * @type {string}
     * @memberof UnpackagedDirsElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof UnpackagedDirsElementModel
     */
    'release'?: string;
    /**
     * package epoch
     * @type {number}
     * @memberof UnpackagedDirsElementModel
     */
    'epoch'?: number;
    /**
     * maintainer name
     * @type {string}
     * @memberof UnpackagedDirsElementModel
     */
    'packager'?: string;
    /**
     * maintainer email
     * @type {string}
     * @memberof UnpackagedDirsElementModel
     */
    'email'?: string;
    /**
     * binary packages archs
     * @type {Array<string>}
     * @memberof UnpackagedDirsElementModel
     */
    'archs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UnpackagedDirsModel
 */
export interface UnpackagedDirsModel {
    /**
     * request arguments
     * @type {object}
     * @memberof UnpackagedDirsModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof UnpackagedDirsModel
     */
    'length'?: number;
    /**
     * packages with unpackaged directories
     * @type {Array<UnpackagedDirsElementModel>}
     * @memberof UnpackagedDirsModel
     */
    'packages'?: Array<UnpackagedDirsElementModel>;
}
/**
 * 
 * @export
 * @interface VulnFixesPackagesElementModel
 */
export interface VulnFixesPackagesElementModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof VulnFixesPackagesElementModel
     */
    'pkghash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof VulnFixesPackagesElementModel
     */
    'name'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof VulnFixesPackagesElementModel
     */
    'branch'?: string;
    /**
     * package version
     * @type {string}
     * @memberof VulnFixesPackagesElementModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof VulnFixesPackagesElementModel
     */
    'release'?: string;
    /**
     * errata ID
     * @type {string}
     * @memberof VulnFixesPackagesElementModel
     */
    'errata_id'?: string;
    /**
     * task ID
     * @type {number}
     * @memberof VulnFixesPackagesElementModel
     */
    'task_id'?: number;
    /**
     * task state
     * @type {string}
     * @memberof VulnFixesPackagesElementModel
     */
    'task_state'?: string;
    /**
     * last package version and release from repository
     * @type {VulnPackageLastVersionModel}
     * @memberof VulnFixesPackagesElementModel
     */
    'last_version'?: VulnPackageLastVersionModel;
}
/**
 * 
 * @export
 * @interface VulnFixesPackagesModel
 */
export interface VulnFixesPackagesModel {
    /**
     * request arguments
     * @type {object}
     * @memberof VulnFixesPackagesModel
     */
    'request_args'?: object;
    /**
     * number of packages found
     * @type {number}
     * @memberof VulnFixesPackagesModel
     */
    'length'?: number;
    /**
     * vulnerable packages information
     * @type {Array<VulnFixesPackagesElementModel>}
     * @memberof VulnFixesPackagesModel
     */
    'packages'?: Array<VulnFixesPackagesElementModel>;
}
/**
 * 
 * @export
 * @interface VulnPackageLastVersionModel
 */
export interface VulnPackageLastVersionModel {
    /**
     * package hash UInt64 as string
     * @type {string}
     * @memberof VulnPackageLastVersionModel
     */
    'pkghash'?: string;
    /**
     * package name
     * @type {string}
     * @memberof VulnPackageLastVersionModel
     */
    'name'?: string;
    /**
     * package set name
     * @type {string}
     * @memberof VulnPackageLastVersionModel
     */
    'branch'?: string;
    /**
     * package version
     * @type {string}
     * @memberof VulnPackageLastVersionModel
     */
    'version'?: string;
    /**
     * package release
     * @type {string}
     * @memberof VulnPackageLastVersionModel
     */
    'release'?: string;
}
/**
 * 
 * @export
 * @interface VulnerabilitiesElementModel
 */
export interface VulnerabilitiesElementModel {
    /**
     * vulnerability id
     * @type {string}
     * @memberof VulnerabilitiesElementModel
     */
    'id'?: string;
    /**
     * vulnerability type
     * @type {string}
     * @memberof VulnerabilitiesElementModel
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface VulnerabilityInfoModel
 */
export interface VulnerabilityInfoModel {
    /**
     * request arguments
     * @type {object}
     * @memberof VulnerabilityInfoModel
     */
    'request_args'?: object;
    /**
     * vulnerabilty information
     * @type {VulnerabilityModel}
     * @memberof VulnerabilityInfoModel
     */
    'vuln_info'?: VulnerabilityModel;
}
/**
 * 
 * @export
 * @interface VulnerabilityModel
 */
export interface VulnerabilityModel {
    /**
     * vulnerability id
     * @type {string}
     * @memberof VulnerabilityModel
     */
    'id'?: string;
    /**
     * description summary
     * @type {string}
     * @memberof VulnerabilityModel
     */
    'summary'?: string;
    /**
     * origin URL
     * @type {string}
     * @memberof VulnerabilityModel
     */
    'url'?: string;
    /**
     * severity level
     * @type {string}
     * @memberof VulnerabilityModel
     */
    'severity'?: string;
    /**
     * severity score
     * @type {number}
     * @memberof VulnerabilityModel
     */
    'score'?: number;
    /**
     * published date
     * @type {string}
     * @memberof VulnerabilityModel
     */
    'published'?: string;
    /**
     * modified date
     * @type {string}
     * @memberof VulnerabilityModel
     */
    'modified'?: string;
    /**
     * vulnerability references
     * @type {Array<string>}
     * @memberof VulnerabilityModel
     */
    'refs'?: Array<string>;
    /**
     * vulnerability original JSON
     * @type {object}
     * @memberof VulnerabilityModel
     */
    'json'?: object;
}

/**
 * AclApi - axios parameter creator
 * @export
 */
export const AclApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ACL groups for source packages list in specific branch
         * @param {string} branch name of packageset
         * @param {Array<string>} packagesNames source packages names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAclByPackages: async (branch: string, packagesNames: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteAclByPackages', 'branch', branch)
            // verify required parameter 'packagesNames' is not null or undefined
            assertParamExists('getRouteAclByPackages', 'packagesNames', packagesNames)
            const localVarPath = `/acl/by_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (packagesNames) {
                localVarQueryParameter['packages_names'] = packagesNames.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of ACL groups for specific branch
         * @param {string} branch name of packageset
         * @param {string} [name] ACL group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAclGroups: async (branch: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteAclGroups', 'branch', branch)
            const localVarPath = `/acl/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the ACL groups that the given user belongs to
         * @param {string} nickname ACL member nickname
         * @param {Array<string>} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainerGroups: async (nickname: string, branch?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nickname' is not null or undefined
            assertParamExists('getRouteMaintainerGroups', 'nickname', nickname)
            const localVarPath = `/acl/maintainer_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch) {
                localVarQueryParameter['branch'] = branch.join(COLLECTION_FORMATS.csv);
            }

            if (nickname !== undefined) {
                localVarQueryParameter['nickname'] = nickname;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AclApi - functional programming interface
 * @export
 */
export const AclApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AclApiAxiosParamCreator(configuration)
    return {
        /**
         * ACL groups for source packages list in specific branch
         * @param {string} branch name of packageset
         * @param {Array<string>} packagesNames source packages names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAclByPackages(branch: string, packagesNames: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AclByPackagesModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAclByPackages(branch, packagesNames, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AclApi.getRouteAclByPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of ACL groups for specific branch
         * @param {string} branch name of packageset
         * @param {string} [name] ACL group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAclGroups(branch: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AclGroupsModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAclGroups(branch, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AclApi.getRouteAclGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the ACL groups that the given user belongs to
         * @param {string} nickname ACL member nickname
         * @param {Array<string>} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteMaintainerGroups(nickname: string, branch?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AclMaintainerGroupsModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteMaintainerGroups(nickname, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AclApi.getRouteMaintainerGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AclApi - factory interface
 * @export
 */
export const AclApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AclApiFp(configuration)
    return {
        /**
         * ACL groups for source packages list in specific branch
         * @param {string} branch name of packageset
         * @param {Array<string>} packagesNames source packages names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAclByPackages(branch: string, packagesNames: Array<string>, options?: any): AxiosPromise<Array<AclByPackagesModel>> {
            return localVarFp.getRouteAclByPackages(branch, packagesNames, options).then((request) => request(axios, basePath));
        },
        /**
         * List of ACL groups for specific branch
         * @param {string} branch name of packageset
         * @param {string} [name] ACL group name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAclGroups(branch: string, name?: string, options?: any): AxiosPromise<Array<AclGroupsModel>> {
            return localVarFp.getRouteAclGroups(branch, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the ACL groups that the given user belongs to
         * @param {string} nickname ACL member nickname
         * @param {Array<string>} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainerGroups(nickname: string, branch?: Array<string>, options?: any): AxiosPromise<Array<AclMaintainerGroupsModel>> {
            return localVarFp.getRouteMaintainerGroups(nickname, branch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AclApi - object-oriented interface
 * @export
 * @class AclApi
 * @extends {BaseAPI}
 */
export class AclApi extends BaseAPI {
    /**
     * ACL groups for source packages list in specific branch
     * @param {string} branch name of packageset
     * @param {Array<string>} packagesNames source packages names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AclApi
     */
    public getRouteAclByPackages(branch: string, packagesNames: Array<string>, options?: RawAxiosRequestConfig) {
        return AclApiFp(this.configuration).getRouteAclByPackages(branch, packagesNames, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of ACL groups for specific branch
     * @param {string} branch name of packageset
     * @param {string} [name] ACL group name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AclApi
     */
    public getRouteAclGroups(branch: string, name?: string, options?: RawAxiosRequestConfig) {
        return AclApiFp(this.configuration).getRouteAclGroups(branch, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the ACL groups that the given user belongs to
     * @param {string} nickname ACL member nickname
     * @param {Array<string>} [branch] name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AclApi
     */
    public getRouteMaintainerGroups(nickname: string, branch?: Array<string>, options?: RawAxiosRequestConfig) {
        return AclApiFp(this.configuration).getRouteMaintainerGroups(nickname, branch, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiLicense: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/license`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * get license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiLicense(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiLicense(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.getApiLicense']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiApi.getApiVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * get license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiLicense(options?: any): AxiosPromise<void> {
            return localVarFp.getApiLicense(options).then((request) => request(axios, basePath));
        },
        /**
         * get API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiVersion(options?: any): AxiosPromise<APIVersion> {
            return localVarFp.getApiVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * get license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public getApiLicense(options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).getApiLicense(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public getApiVersion(options?: RawAxiosRequestConfig) {
        return ApiApiFp(this.configuration).getApiVersion(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate an existing user and return an access token.
         * @param {string} nickname User nickname
         * @param {string} password User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteAuthLoginAuthLogin: async (nickname: string, password: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nickname' is not null or undefined
            assertParamExists('postRouteAuthLoginAuthLogin', 'nickname', nickname)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('postRouteAuthLoginAuthLogin', 'password', password)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (nickname !== undefined) { 
                localVarFormParams.append('nickname', nickname as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User logs out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteAuthLogoutAuthLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update access token.
         * @param {string} accessToken Access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteRefreshTokenAuthRefreshToken: async (accessToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('postRouteRefreshTokenAuthRefreshToken', 'accessToken', accessToken)
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (accessToken !== undefined) { 
                localVarFormParams.append('access_token', accessToken as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate an existing user and return an access token.
         * @param {string} nickname User nickname
         * @param {string} password User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteAuthLoginAuthLogin(nickname: string, password: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteAuthLoginAuthLogin(nickname, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postRouteAuthLoginAuthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User logs out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteAuthLogoutAuthLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteAuthLogoutAuthLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postRouteAuthLogoutAuthLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update access token.
         * @param {string} accessToken Access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteRefreshTokenAuthRefreshToken(accessToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteRefreshTokenAuthRefreshToken(accessToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postRouteRefreshTokenAuthRefreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Authenticate an existing user and return an access token.
         * @param {string} nickname User nickname
         * @param {string} password User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteAuthLoginAuthLogin(nickname: string, password: string, options?: any): AxiosPromise<void> {
            return localVarFp.postRouteAuthLoginAuthLogin(nickname, password, options).then((request) => request(axios, basePath));
        },
        /**
         * User logs out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteAuthLogoutAuthLogout(options?: any): AxiosPromise<void> {
            return localVarFp.postRouteAuthLogoutAuthLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Update access token.
         * @param {string} accessToken Access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteRefreshTokenAuthRefreshToken(accessToken: string, options?: any): AxiosPromise<void> {
            return localVarFp.postRouteRefreshTokenAuthRefreshToken(accessToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Authenticate an existing user and return an access token.
     * @param {string} nickname User nickname
     * @param {string} password User password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postRouteAuthLoginAuthLogin(nickname: string, password: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postRouteAuthLoginAuthLogin(nickname, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User logs out.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postRouteAuthLogoutAuthLogout(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postRouteAuthLogoutAuthLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update access token.
     * @param {string} accessToken Access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postRouteRefreshTokenAuthRefreshToken(accessToken: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postRouteRefreshTokenAuthRefreshToken(accessToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BugApi - axios parameter creator
 * @export
 */
export const BugApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information from bugzilla by image edition
         * @param {string} branch name of packageset
         * @param {string} edition Image edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBugzillaByImageEditionBugBugzillaByImageEdition: async (branch: string, edition: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteBugzillaByImageEditionBugBugzillaByImageEdition', 'branch', branch)
            // verify required parameter 'edition' is not null or undefined
            assertParamExists('getRouteBugzillaByImageEditionBugBugzillaByImageEdition', 'edition', edition)
            const localVarPath = `/bug/bugzilla_by_image_edition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (edition !== undefined) {
                localVarQueryParameter['edition'] = edition;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information from bugzilla by the maintainer nickname
         * @param {string} maintainerNickname maintainer nickname
         * @param {GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBugzillaByMaintainerBugBugzillaByMaintainer: async (maintainerNickname: string, byAcl?: GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'maintainerNickname' is not null or undefined
            assertParamExists('getRouteBugzillaByMaintainerBugBugzillaByMaintainer', 'maintainerNickname', maintainerNickname)
            const localVarPath = `/bug/bugzilla_by_maintainer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maintainerNickname !== undefined) {
                localVarQueryParameter['maintainer_nickname'] = maintainerNickname;
            }

            if (byAcl !== undefined) {
                localVarQueryParameter['by_acl'] = byAcl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information from bugzilla by the source package name
         * @param {string} packageName source or binary package name
         * @param {GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBugzillaByPackageBugBugzillaByPackage: async (packageName: string, packageType?: GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('getRouteBugzillaByPackageBugBugzillaByPackage', 'packageName', packageName)
            const localVarPath = `/bug/bugzilla_by_package`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (packageName !== undefined) {
                localVarQueryParameter['package_name'] = packageName;
            }

            if (packageType !== undefined) {
                localVarQueryParameter['package_type'] = packageType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BugApi - functional programming interface
 * @export
 */
export const BugApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BugApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information from bugzilla by image edition
         * @param {string} branch name of packageset
         * @param {string} edition Image edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBugzillaByImageEditionBugBugzillaByImageEdition(branch: string, edition: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BugzillaInfoModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBugzillaByImageEditionBugBugzillaByImageEdition(branch, edition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BugApi.getRouteBugzillaByImageEditionBugBugzillaByImageEdition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information from bugzilla by the maintainer nickname
         * @param {string} maintainerNickname maintainer nickname
         * @param {GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBugzillaByMaintainerBugBugzillaByMaintainer(maintainerNickname: string, byAcl?: GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BugzillaInfoModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBugzillaByMaintainerBugBugzillaByMaintainer(maintainerNickname, byAcl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BugApi.getRouteBugzillaByMaintainerBugBugzillaByMaintainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information from bugzilla by the source package name
         * @param {string} packageName source or binary package name
         * @param {GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBugzillaByPackageBugBugzillaByPackage(packageName: string, packageType?: GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BugzillaInfoModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBugzillaByPackageBugBugzillaByPackage(packageName, packageType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BugApi.getRouteBugzillaByPackageBugBugzillaByPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BugApi - factory interface
 * @export
 */
export const BugApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BugApiFp(configuration)
    return {
        /**
         * Get information from bugzilla by image edition
         * @param {string} branch name of packageset
         * @param {string} edition Image edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBugzillaByImageEditionBugBugzillaByImageEdition(branch: string, edition: string, options?: any): AxiosPromise<Array<BugzillaInfoModel>> {
            return localVarFp.getRouteBugzillaByImageEditionBugBugzillaByImageEdition(branch, edition, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information from bugzilla by the maintainer nickname
         * @param {string} maintainerNickname maintainer nickname
         * @param {GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBugzillaByMaintainerBugBugzillaByMaintainer(maintainerNickname: string, byAcl?: GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum, options?: any): AxiosPromise<Array<BugzillaInfoModel>> {
            return localVarFp.getRouteBugzillaByMaintainerBugBugzillaByMaintainer(maintainerNickname, byAcl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information from bugzilla by the source package name
         * @param {string} packageName source or binary package name
         * @param {GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBugzillaByPackageBugBugzillaByPackage(packageName: string, packageType?: GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum, options?: any): AxiosPromise<Array<BugzillaInfoModel>> {
            return localVarFp.getRouteBugzillaByPackageBugBugzillaByPackage(packageName, packageType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BugApi - object-oriented interface
 * @export
 * @class BugApi
 * @extends {BaseAPI}
 */
export class BugApi extends BaseAPI {
    /**
     * Get information from bugzilla by image edition
     * @param {string} branch name of packageset
     * @param {string} edition Image edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugApi
     */
    public getRouteBugzillaByImageEditionBugBugzillaByImageEdition(branch: string, edition: string, options?: RawAxiosRequestConfig) {
        return BugApiFp(this.configuration).getRouteBugzillaByImageEditionBugBugzillaByImageEdition(branch, edition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information from bugzilla by the maintainer nickname
     * @param {string} maintainerNickname maintainer nickname
     * @param {GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugApi
     */
    public getRouteBugzillaByMaintainerBugBugzillaByMaintainer(maintainerNickname: string, byAcl?: GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum, options?: RawAxiosRequestConfig) {
        return BugApiFp(this.configuration).getRouteBugzillaByMaintainerBugBugzillaByMaintainer(maintainerNickname, byAcl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information from bugzilla by the source package name
     * @param {string} packageName source or binary package name
     * @param {GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum} [packageType] packages type [source|binary]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugApi
     */
    public getRouteBugzillaByPackageBugBugzillaByPackage(packageName: string, packageType?: GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum, options?: RawAxiosRequestConfig) {
        return BugApiFp(this.configuration).getRouteBugzillaByPackageBugBugzillaByPackage(packageName, packageType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum = typeof GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum[keyof typeof GetRouteBugzillaByMaintainerBugBugzillaByMaintainerByAclEnum];
/**
 * @export
 */
export const GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum = typeof GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum[keyof typeof GetRouteBugzillaByPackageBugBugzillaByPackagePackageTypeEnum];


/**
 * DependenciesApi - axios parameter creator
 * @export
 */
export const DependenciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Find packages required to backport too
         * @param {string} fromBranch packageset name where are packages backported from
         * @param {string} intoBranch packageset name where are packages backported to
         * @param {Array<string>} packagesNames source packages names
         * @param {GetRouteBackportHelperDpTypeEnum} [dpType] type of dependency [source|binary|both]
         * @param {Array<string>} [archs] architectures to show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBackportHelper: async (fromBranch: string, intoBranch: string, packagesNames: Array<string>, dpType?: GetRouteBackportHelperDpTypeEnum, archs?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromBranch' is not null or undefined
            assertParamExists('getRouteBackportHelper', 'fromBranch', fromBranch)
            // verify required parameter 'intoBranch' is not null or undefined
            assertParamExists('getRouteBackportHelper', 'intoBranch', intoBranch)
            // verify required parameter 'packagesNames' is not null or undefined
            assertParamExists('getRouteBackportHelper', 'packagesNames', packagesNames)
            const localVarPath = `/dependencies/backport_helper`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromBranch !== undefined) {
                localVarQueryParameter['from_branch'] = fromBranch;
            }

            if (intoBranch !== undefined) {
                localVarQueryParameter['into_branch'] = intoBranch;
            }

            if (packagesNames) {
                localVarQueryParameter['packages_names'] = packagesNames.join(COLLECTION_FORMATS.csv);
            }

            if (dpType !== undefined) {
                localVarQueryParameter['dp_type'] = dpType;
            }

            if (archs) {
                localVarQueryParameter['archs'] = archs.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary package dependencies
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash: async (pkghash: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/dependencies/binary_package_dependencies/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source package build dependencies
         * @param {number} pkghash package hash
         * @param {string} branch packageset name
         * @param {number} [depth] dependency level limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash: async (pkghash: number, branch: string, depth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash', 'pkghash', pkghash)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash', 'branch', branch)
            const localVarPath = `/dependencies/source_package_dependencies/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fast search for dependencies by name (case sensitive)         including partial occurrence.
         * @param {string} branch packageset name
         * @param {string} dpName dependency name
         * @param {number} [limit] number of dependencies to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFastLookupDependenciesFastLookup: async (branch: string, dpName: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteFastLookupDependenciesFastLookup', 'branch', branch)
            // verify required parameter 'dpName' is not null or undefined
            assertParamExists('getRouteFastLookupDependenciesFastLookup', 'dpName', dpName)
            const localVarPath = `/dependencies/fast_lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (dpName !== undefined) {
                localVarQueryParameter['dp_name'] = dpName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get packages build dependencies by set of parameters
         * @param {string} name source package name
         * @param {string} branch packageset name
         * @param {GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum} [dpType] type of dependency [source|binary|both]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageBuildDependencyDependenciesWhatDependsSrc: async (name: string, branch: string, dpType?: GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackageBuildDependencyDependenciesWhatDependsSrc', 'name', name)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageBuildDependencyDependenciesWhatDependsSrc', 'branch', branch)
            const localVarPath = `/dependencies/what_depends_src`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (dpType !== undefined) {
                localVarQueryParameter['dp_type'] = dpType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary packages by dependency name and type
         * @param {string} branch packageset name
         * @param {string} dpName dependency name
         * @param {GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum} [dpType] type of dependency [all|provide|require|conflict|obsolete]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageDependsDependenciesPackagesByDependency: async (branch: string, dpName: string, dpType?: GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageDependsDependenciesPackagesByDependency', 'branch', branch)
            // verify required parameter 'dpName' is not null or undefined
            assertParamExists('getRoutePackageDependsDependenciesPackagesByDependency', 'dpName', dpName)
            const localVarPath = `/dependencies/packages_by_dependency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (dpName !== undefined) {
                localVarQueryParameter['dp_name'] = dpName;
            }

            if (dpType !== undefined) {
                localVarQueryParameter['dp_type'] = dpType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DependenciesApi - functional programming interface
 * @export
 */
export const DependenciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DependenciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Find packages required to backport too
         * @param {string} fromBranch packageset name where are packages backported from
         * @param {string} intoBranch packageset name where are packages backported to
         * @param {Array<string>} packagesNames source packages names
         * @param {GetRouteBackportHelperDpTypeEnum} [dpType] type of dependency [source|binary|both]
         * @param {Array<string>} [archs] architectures to show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBackportHelper(fromBranch: string, intoBranch: string, packagesNames: Array<string>, dpType?: GetRouteBackportHelperDpTypeEnum, archs?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BackportHelperModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBackportHelper(fromBranch, intoBranch, packagesNames, dpType, archs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DependenciesApi.getRouteBackportHelper']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary package dependencies
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash(pkghash: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependenciesPackageDependenciesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash(pkghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DependenciesApi.getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source package build dependencies
         * @param {number} pkghash package hash
         * @param {string} branch packageset name
         * @param {number} [depth] dependency level limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash(pkghash: number, branch: string, depth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependenciesPackageBuildDependenciesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash(pkghash, branch, depth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DependenciesApi.getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fast search for dependencies by name (case sensitive)         including partial occurrence.
         * @param {string} branch packageset name
         * @param {string} dpName dependency name
         * @param {number} [limit] number of dependencies to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFastLookupDependenciesFastLookup(branch: string, dpName: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FastDependencySearchModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFastLookupDependenciesFastLookup(branch, dpName, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DependenciesApi.getRouteFastLookupDependenciesFastLookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get packages build dependencies by set of parameters
         * @param {string} name source package name
         * @param {string} branch packageset name
         * @param {GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum} [dpType] type of dependency [source|binary|both]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageBuildDependencyDependenciesWhatDependsSrc(name: string, branch: string, dpType?: GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageBuildDependencyModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageBuildDependencyDependenciesWhatDependsSrc(name, branch, dpType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DependenciesApi.getRoutePackageBuildDependencyDependenciesWhatDependsSrc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary packages by dependency name and type
         * @param {string} branch packageset name
         * @param {string} dpName dependency name
         * @param {GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum} [dpType] type of dependency [all|provide|require|conflict|obsolete]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageDependsDependenciesPackagesByDependency(branch: string, dpName: string, dpType?: GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependenciesPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageDependsDependenciesPackagesByDependency(branch, dpName, dpType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DependenciesApi.getRoutePackageDependsDependenciesPackagesByDependency']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DependenciesApi - factory interface
 * @export
 */
export const DependenciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DependenciesApiFp(configuration)
    return {
        /**
         * Find packages required to backport too
         * @param {string} fromBranch packageset name where are packages backported from
         * @param {string} intoBranch packageset name where are packages backported to
         * @param {Array<string>} packagesNames source packages names
         * @param {GetRouteBackportHelperDpTypeEnum} [dpType] type of dependency [source|binary|both]
         * @param {Array<string>} [archs] architectures to show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBackportHelper(fromBranch: string, intoBranch: string, packagesNames: Array<string>, dpType?: GetRouteBackportHelperDpTypeEnum, archs?: Array<string>, options?: any): AxiosPromise<Array<BackportHelperModel>> {
            return localVarFp.getRouteBackportHelper(fromBranch, intoBranch, packagesNames, dpType, archs, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary package dependencies
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash(pkghash: number, options?: any): AxiosPromise<DependenciesPackageDependenciesModel> {
            return localVarFp.getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash(pkghash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get source package build dependencies
         * @param {number} pkghash package hash
         * @param {string} branch packageset name
         * @param {number} [depth] dependency level limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash(pkghash: number, branch: string, depth?: number, options?: any): AxiosPromise<DependenciesPackageBuildDependenciesModel> {
            return localVarFp.getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash(pkghash, branch, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * Fast search for dependencies by name (case sensitive)         including partial occurrence.
         * @param {string} branch packageset name
         * @param {string} dpName dependency name
         * @param {number} [limit] number of dependencies to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFastLookupDependenciesFastLookup(branch: string, dpName: string, limit?: number, options?: any): AxiosPromise<FastDependencySearchModel> {
            return localVarFp.getRouteFastLookupDependenciesFastLookup(branch, dpName, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get packages build dependencies by set of parameters
         * @param {string} name source package name
         * @param {string} branch packageset name
         * @param {GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum} [dpType] type of dependency [source|binary|both]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageBuildDependencyDependenciesWhatDependsSrc(name: string, branch: string, dpType?: GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum, options?: any): AxiosPromise<PackageBuildDependencyModel> {
            return localVarFp.getRoutePackageBuildDependencyDependenciesWhatDependsSrc(name, branch, dpType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary packages by dependency name and type
         * @param {string} branch packageset name
         * @param {string} dpName dependency name
         * @param {GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum} [dpType] type of dependency [all|provide|require|conflict|obsolete]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageDependsDependenciesPackagesByDependency(branch: string, dpName: string, dpType?: GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum, options?: any): AxiosPromise<DependenciesPackagesModel> {
            return localVarFp.getRoutePackageDependsDependenciesPackagesByDependency(branch, dpName, dpType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DependenciesApi - object-oriented interface
 * @export
 * @class DependenciesApi
 * @extends {BaseAPI}
 */
export class DependenciesApi extends BaseAPI {
    /**
     * Find packages required to backport too
     * @param {string} fromBranch packageset name where are packages backported from
     * @param {string} intoBranch packageset name where are packages backported to
     * @param {Array<string>} packagesNames source packages names
     * @param {GetRouteBackportHelperDpTypeEnum} [dpType] type of dependency [source|binary|both]
     * @param {Array<string>} [archs] architectures to show
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependenciesApi
     */
    public getRouteBackportHelper(fromBranch: string, intoBranch: string, packagesNames: Array<string>, dpType?: GetRouteBackportHelperDpTypeEnum, archs?: Array<string>, options?: RawAxiosRequestConfig) {
        return DependenciesApiFp(this.configuration).getRouteBackportHelper(fromBranch, intoBranch, packagesNames, dpType, archs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary package dependencies
     * @param {number} pkghash package hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependenciesApi
     */
    public getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash(pkghash: number, options?: RawAxiosRequestConfig) {
        return DependenciesApiFp(this.configuration).getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash(pkghash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source package build dependencies
     * @param {number} pkghash package hash
     * @param {string} branch packageset name
     * @param {number} [depth] dependency level limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependenciesApi
     */
    public getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash(pkghash: number, branch: string, depth?: number, options?: RawAxiosRequestConfig) {
        return DependenciesApiFp(this.configuration).getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash(pkghash, branch, depth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fast search for dependencies by name (case sensitive)         including partial occurrence.
     * @param {string} branch packageset name
     * @param {string} dpName dependency name
     * @param {number} [limit] number of dependencies to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependenciesApi
     */
    public getRouteFastLookupDependenciesFastLookup(branch: string, dpName: string, limit?: number, options?: RawAxiosRequestConfig) {
        return DependenciesApiFp(this.configuration).getRouteFastLookupDependenciesFastLookup(branch, dpName, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get packages build dependencies by set of parameters
     * @param {string} name source package name
     * @param {string} branch packageset name
     * @param {GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum} [dpType] type of dependency [source|binary|both]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependenciesApi
     */
    public getRoutePackageBuildDependencyDependenciesWhatDependsSrc(name: string, branch: string, dpType?: GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum, options?: RawAxiosRequestConfig) {
        return DependenciesApiFp(this.configuration).getRoutePackageBuildDependencyDependenciesWhatDependsSrc(name, branch, dpType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary packages by dependency name and type
     * @param {string} branch packageset name
     * @param {string} dpName dependency name
     * @param {GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum} [dpType] type of dependency [all|provide|require|conflict|obsolete]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DependenciesApi
     */
    public getRoutePackageDependsDependenciesPackagesByDependency(branch: string, dpName: string, dpType?: GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum, options?: RawAxiosRequestConfig) {
        return DependenciesApiFp(this.configuration).getRoutePackageDependsDependenciesPackagesByDependency(branch, dpName, dpType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRouteBackportHelperDpTypeEnum = {
    Both: 'both',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteBackportHelperDpTypeEnum = typeof GetRouteBackportHelperDpTypeEnum[keyof typeof GetRouteBackportHelperDpTypeEnum];
/**
 * @export
 */
export const GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum = {
    Both: 'both',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum = typeof GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum[keyof typeof GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum];
/**
 * @export
 */
export const GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum = {
    All: 'all',
    Provide: 'provide',
    Require: 'require',
    Conflict: 'conflict',
    Obsolete: 'obsolete'
} as const;
export type GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum = typeof GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum[keyof typeof GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum];


/**
 * ErrataApi - axios parameter creator
 * @export
 */
export const ErrataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of branches form errata history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteErrataBranchesErrataErrataBranches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/errata/errata_branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of valid Errata identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteErrataIdsErrataIds: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/errata/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find errata by ID, vulnerability ID or package name.
         * @param {Array<string>} [input] errata search arguments
         * @param {string} [branch] branch name
         * @param {GetRouteFindErratasErrataFindErratasTypeEnum} [type] errata type [packages|repository|bug|vuln]
         * @param {number} [page] number page
         * @param {number} [limit] number of records
         * @param {GetRouteFindErratasErrataFindErratasStateEnum} [state] errata state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindErratasErrataFindErratas: async (input?: Array<string>, branch?: string, type?: GetRouteFindErratasErrataFindErratasTypeEnum, page?: number, limit?: number, state?: GetRouteFindErratasErrataFindErratasStateEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/errata/find_erratas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input) {
                localVarQueryParameter['input'] = input.join(COLLECTION_FORMATS.csv);
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find errata by image UUID.
         * @param {string} uuid Image UUID
         * @param {string} branch branch name
         * @param {string} [component] Image component
         * @param {Array<string>} [input] errata search arguments
         * @param {GetRouteFindImageErratasErrataFindImageErratasTypeEnum} [type] errata type [packages|repository|bug|vuln]
         * @param {number} [page] number page
         * @param {number} [limit] number of records
         * @param {boolean} [isDiscarded] is errata discarded
         * @param {Array<string>} [sort] sort arguments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindImageErratasErrataFindImageErratas: async (uuid: string, branch: string, component?: string, input?: Array<string>, type?: GetRouteFindImageErratasErrataFindImageErratasTypeEnum, page?: number, limit?: number, isDiscarded?: boolean, sort?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRouteFindImageErratasErrataFindImageErratas', 'uuid', uuid)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteFindImageErratasErrataFindImageErratas', 'branch', branch)
            const localVarPath = `/errata/find_image_erratas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }

            if (input) {
                localVarQueryParameter['input'] = input.join(COLLECTION_FORMATS.csv);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isDiscarded !== undefined) {
                localVarQueryParameter['is_discarded'] = isDiscarded;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get branches with OVAL definitions export available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOvalExportBranchesErrataExportOvalBranches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/errata/export/oval/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OVAL definitions of closed issues of branch packages
         * @param {string} branch 
         * @param {string} [packageName] source or binary package name
         * @param {boolean} [oneFile] return OVAL definitions as one XML file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOvalExportErrataExportOvalStringBranch: async (branch: string, packageName?: string, oneFile?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteOvalExportErrataExportOvalStringBranch', 'branch', branch)
            const localVarPath = `/errata/export/oval/{branch}`
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (packageName !== undefined) {
                localVarQueryParameter['package_name'] = packageName;
            }

            if (oneFile !== undefined) {
                localVarQueryParameter['one_file'] = oneFile;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find erratas by given arguments
         * @param {string} [branch] branch name
         * @param {string} [name] source package name
         * @param {string} [vulnId] CVE, BDU or Bug ID
         * @param {string} [errataId] errata ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSearchErrataSearch: async (branch?: string, name?: string, vulnId?: string, errataId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/errata/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (vulnId !== undefined) {
                localVarQueryParameter['vuln_id'] = vulnId;
            }

            if (errataId !== undefined) {
                localVarQueryParameter['errata_id'] = errataId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about branch update erratas
         * @param {ErrataJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteBranchesUpdatesErrataBranchesUpdates: async (payload: ErrataJsonPostListModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRouteBranchesUpdatesErrataBranchesUpdates', 'payload', payload)
            const localVarPath = `/errata/branches_updates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about package update erratas
         * @param {ErrataJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRoutePackagesUpdatesErrataPackagesUpdates: async (payload: ErrataJsonPostListModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRoutePackagesUpdatesErrataPackagesUpdates', 'payload', payload)
            const localVarPath = `/errata/packages_updates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrataApi - functional programming interface
 * @export
 */
export const ErrataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ErrataApiAxiosParamCreator(configuration)
    return {
        /**
         * Get list of branches form errata history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteErrataBranchesErrataErrataBranches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrataBranchesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteErrataBranchesErrataErrataBranches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.getRouteErrataBranchesErrataErrataBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of valid Errata identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteErrataIdsErrataIds(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrataIdsListModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteErrataIdsErrataIds(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.getRouteErrataIdsErrataIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find errata by ID, vulnerability ID or package name.
         * @param {Array<string>} [input] errata search arguments
         * @param {string} [branch] branch name
         * @param {GetRouteFindErratasErrataFindErratasTypeEnum} [type] errata type [packages|repository|bug|vuln]
         * @param {number} [page] number page
         * @param {number} [limit] number of records
         * @param {GetRouteFindErratasErrataFindErratasStateEnum} [state] errata state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFindErratasErrataFindErratas(input?: Array<string>, branch?: string, type?: GetRouteFindErratasErrataFindErratasTypeEnum, page?: number, limit?: number, state?: GetRouteFindErratasErrataFindErratasStateEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrataLastChangedModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFindErratasErrataFindErratas(input, branch, type, page, limit, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.getRouteFindErratasErrataFindErratas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find errata by image UUID.
         * @param {string} uuid Image UUID
         * @param {string} branch branch name
         * @param {string} [component] Image component
         * @param {Array<string>} [input] errata search arguments
         * @param {GetRouteFindImageErratasErrataFindImageErratasTypeEnum} [type] errata type [packages|repository|bug|vuln]
         * @param {number} [page] number page
         * @param {number} [limit] number of records
         * @param {boolean} [isDiscarded] is errata discarded
         * @param {Array<string>} [sort] sort arguments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFindImageErratasErrataFindImageErratas(uuid: string, branch: string, component?: string, input?: Array<string>, type?: GetRouteFindImageErratasErrataFindImageErratasTypeEnum, page?: number, limit?: number, isDiscarded?: boolean, sort?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageErrataModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFindImageErratasErrataFindImageErratas(uuid, branch, component, input, type, page, limit, isDiscarded, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.getRouteFindImageErratasErrataFindImageErratas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get branches with OVAL definitions export available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteOvalExportBranchesErrataExportOvalBranches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OvalBranchesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteOvalExportBranchesErrataExportOvalBranches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.getRouteOvalExportBranchesErrataExportOvalBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get OVAL definitions of closed issues of branch packages
         * @param {string} branch 
         * @param {string} [packageName] source or binary package name
         * @param {boolean} [oneFile] return OVAL definitions as one XML file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteOvalExportErrataExportOvalStringBranch(branch: string, packageName?: string, oneFile?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteOvalExportErrataExportOvalStringBranch(branch, packageName, oneFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.getRouteOvalExportErrataExportOvalStringBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find erratas by given arguments
         * @param {string} [branch] branch name
         * @param {string} [name] source package name
         * @param {string} [vulnId] CVE, BDU or Bug ID
         * @param {string} [errataId] errata ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteSearchErrataSearch(branch?: string, name?: string, vulnId?: string, errataId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErratasModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteSearchErrataSearch(branch, name, vulnId, errataId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.getRouteSearchErrataSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about branch update erratas
         * @param {ErrataJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteBranchesUpdatesErrataBranchesUpdates(payload: ErrataJsonPostListModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrataBranchesUpdatesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteBranchesUpdatesErrataBranchesUpdates(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.postRouteBranchesUpdatesErrataBranchesUpdates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about package update erratas
         * @param {ErrataJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRoutePackagesUpdatesErrataPackagesUpdates(payload: ErrataJsonPostListModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrataPackagesUpdatesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRoutePackagesUpdatesErrataPackagesUpdates(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ErrataApi.postRoutePackagesUpdatesErrataPackagesUpdates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ErrataApi - factory interface
 * @export
 */
export const ErrataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ErrataApiFp(configuration)
    return {
        /**
         * Get list of branches form errata history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteErrataBranchesErrataErrataBranches(options?: any): AxiosPromise<ErrataBranchesModel> {
            return localVarFp.getRouteErrataBranchesErrataErrataBranches(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of valid Errata identifiers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteErrataIdsErrataIds(options?: any): AxiosPromise<ErrataIdsListModel> {
            return localVarFp.getRouteErrataIdsErrataIds(options).then((request) => request(axios, basePath));
        },
        /**
         * Find errata by ID, vulnerability ID or package name.
         * @param {Array<string>} [input] errata search arguments
         * @param {string} [branch] branch name
         * @param {GetRouteFindErratasErrataFindErratasTypeEnum} [type] errata type [packages|repository|bug|vuln]
         * @param {number} [page] number page
         * @param {number} [limit] number of records
         * @param {GetRouteFindErratasErrataFindErratasStateEnum} [state] errata state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindErratasErrataFindErratas(input?: Array<string>, branch?: string, type?: GetRouteFindErratasErrataFindErratasTypeEnum, page?: number, limit?: number, state?: GetRouteFindErratasErrataFindErratasStateEnum, options?: any): AxiosPromise<ErrataLastChangedModel> {
            return localVarFp.getRouteFindErratasErrataFindErratas(input, branch, type, page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Find errata by image UUID.
         * @param {string} uuid Image UUID
         * @param {string} branch branch name
         * @param {string} [component] Image component
         * @param {Array<string>} [input] errata search arguments
         * @param {GetRouteFindImageErratasErrataFindImageErratasTypeEnum} [type] errata type [packages|repository|bug|vuln]
         * @param {number} [page] number page
         * @param {number} [limit] number of records
         * @param {boolean} [isDiscarded] is errata discarded
         * @param {Array<string>} [sort] sort arguments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindImageErratasErrataFindImageErratas(uuid: string, branch: string, component?: string, input?: Array<string>, type?: GetRouteFindImageErratasErrataFindImageErratasTypeEnum, page?: number, limit?: number, isDiscarded?: boolean, sort?: Array<string>, options?: any): AxiosPromise<ImageErrataModel> {
            return localVarFp.getRouteFindImageErratasErrataFindImageErratas(uuid, branch, component, input, type, page, limit, isDiscarded, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get branches with OVAL definitions export available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOvalExportBranchesErrataExportOvalBranches(options?: any): AxiosPromise<OvalBranchesModel> {
            return localVarFp.getRouteOvalExportBranchesErrataExportOvalBranches(options).then((request) => request(axios, basePath));
        },
        /**
         * Get OVAL definitions of closed issues of branch packages
         * @param {string} branch 
         * @param {string} [packageName] source or binary package name
         * @param {boolean} [oneFile] return OVAL definitions as one XML file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteOvalExportErrataExportOvalStringBranch(branch: string, packageName?: string, oneFile?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getRouteOvalExportErrataExportOvalStringBranch(branch, packageName, oneFile, options).then((request) => request(axios, basePath));
        },
        /**
         * Find erratas by given arguments
         * @param {string} [branch] branch name
         * @param {string} [name] source package name
         * @param {string} [vulnId] CVE, BDU or Bug ID
         * @param {string} [errataId] errata ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSearchErrataSearch(branch?: string, name?: string, vulnId?: string, errataId?: string, options?: any): AxiosPromise<ErratasModel> {
            return localVarFp.getRouteSearchErrataSearch(branch, name, vulnId, errataId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about branch update erratas
         * @param {ErrataJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteBranchesUpdatesErrataBranchesUpdates(payload: ErrataJsonPostListModel, options?: any): AxiosPromise<ErrataBranchesUpdatesModel> {
            return localVarFp.postRouteBranchesUpdatesErrataBranchesUpdates(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about package update erratas
         * @param {ErrataJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRoutePackagesUpdatesErrataPackagesUpdates(payload: ErrataJsonPostListModel, options?: any): AxiosPromise<ErrataPackagesUpdatesModel> {
            return localVarFp.postRoutePackagesUpdatesErrataPackagesUpdates(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ErrataApi - object-oriented interface
 * @export
 * @class ErrataApi
 * @extends {BaseAPI}
 */
export class ErrataApi extends BaseAPI {
    /**
     * Get list of branches form errata history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public getRouteErrataBranchesErrataErrataBranches(options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).getRouteErrataBranchesErrataErrataBranches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of valid Errata identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public getRouteErrataIdsErrataIds(options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).getRouteErrataIdsErrataIds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find errata by ID, vulnerability ID or package name.
     * @param {Array<string>} [input] errata search arguments
     * @param {string} [branch] branch name
     * @param {GetRouteFindErratasErrataFindErratasTypeEnum} [type] errata type [packages|repository|bug|vuln]
     * @param {number} [page] number page
     * @param {number} [limit] number of records
     * @param {GetRouteFindErratasErrataFindErratasStateEnum} [state] errata state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public getRouteFindErratasErrataFindErratas(input?: Array<string>, branch?: string, type?: GetRouteFindErratasErrataFindErratasTypeEnum, page?: number, limit?: number, state?: GetRouteFindErratasErrataFindErratasStateEnum, options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).getRouteFindErratasErrataFindErratas(input, branch, type, page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find errata by image UUID.
     * @param {string} uuid Image UUID
     * @param {string} branch branch name
     * @param {string} [component] Image component
     * @param {Array<string>} [input] errata search arguments
     * @param {GetRouteFindImageErratasErrataFindImageErratasTypeEnum} [type] errata type [packages|repository|bug|vuln]
     * @param {number} [page] number page
     * @param {number} [limit] number of records
     * @param {boolean} [isDiscarded] is errata discarded
     * @param {Array<string>} [sort] sort arguments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public getRouteFindImageErratasErrataFindImageErratas(uuid: string, branch: string, component?: string, input?: Array<string>, type?: GetRouteFindImageErratasErrataFindImageErratasTypeEnum, page?: number, limit?: number, isDiscarded?: boolean, sort?: Array<string>, options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).getRouteFindImageErratasErrataFindImageErratas(uuid, branch, component, input, type, page, limit, isDiscarded, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get branches with OVAL definitions export available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public getRouteOvalExportBranchesErrataExportOvalBranches(options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).getRouteOvalExportBranchesErrataExportOvalBranches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OVAL definitions of closed issues of branch packages
     * @param {string} branch 
     * @param {string} [packageName] source or binary package name
     * @param {boolean} [oneFile] return OVAL definitions as one XML file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public getRouteOvalExportErrataExportOvalStringBranch(branch: string, packageName?: string, oneFile?: boolean, options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).getRouteOvalExportErrataExportOvalStringBranch(branch, packageName, oneFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find erratas by given arguments
     * @param {string} [branch] branch name
     * @param {string} [name] source package name
     * @param {string} [vulnId] CVE, BDU or Bug ID
     * @param {string} [errataId] errata ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public getRouteSearchErrataSearch(branch?: string, name?: string, vulnId?: string, errataId?: string, options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).getRouteSearchErrataSearch(branch, name, vulnId, errataId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about branch update erratas
     * @param {ErrataJsonPostListModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public postRouteBranchesUpdatesErrataBranchesUpdates(payload: ErrataJsonPostListModel, options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).postRouteBranchesUpdatesErrataBranchesUpdates(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about package update erratas
     * @param {ErrataJsonPostListModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrataApi
     */
    public postRoutePackagesUpdatesErrataPackagesUpdates(payload: ErrataJsonPostListModel, options?: RawAxiosRequestConfig) {
        return ErrataApiFp(this.configuration).postRoutePackagesUpdatesErrataPackagesUpdates(payload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRouteFindErratasErrataFindErratasTypeEnum = {
    Packages: 'packages',
    Repository: 'repository',
    Bug: 'bug',
    Vuln: 'vuln'
} as const;
export type GetRouteFindErratasErrataFindErratasTypeEnum = typeof GetRouteFindErratasErrataFindErratasTypeEnum[keyof typeof GetRouteFindErratasErrataFindErratasTypeEnum];
/**
 * @export
 */
export const GetRouteFindErratasErrataFindErratasStateEnum = {
    All: 'all',
    Active: 'active',
    Discarded: 'discarded'
} as const;
export type GetRouteFindErratasErrataFindErratasStateEnum = typeof GetRouteFindErratasErrataFindErratasStateEnum[keyof typeof GetRouteFindErratasErrataFindErratasStateEnum];
/**
 * @export
 */
export const GetRouteFindImageErratasErrataFindImageErratasTypeEnum = {
    Packages: 'packages',
    Repository: 'repository',
    Bug: 'bug',
    Vuln: 'vuln'
} as const;
export type GetRouteFindImageErratasErrataFindImageErratasTypeEnum = typeof GetRouteFindImageErratasErrataFindImageErratasTypeEnum[keyof typeof GetRouteFindImageErratasErrataFindImageErratasTypeEnum];


/**
 * ExportApi - axios parameter creator
 * @export
 */
export const ExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Branch tree info export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBranchTreeExportExportBranchTree: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/export/branch_tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get branch info export for Repology
         * @param {string} branch branch name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageInfoExportRepologyStringBranch: async (branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageInfoExportRepologyStringBranch', 'branch', branch)
            const localVarPath = `/export/repology/{branch}`
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get branch binary packages info
         * @param {string} branch branch name
         * @param {string} [arch] package architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch: async (branch: string, arch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch', 'branch', branch)
            const localVarPath = `/export/branch_binary_packages/{branch}`
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get branch source packages for sitemap
         * @param {string} branch branch name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSitemapPackagesExportSitemapPackagesStringBranch: async (branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteSitemapPackagesExportSitemapPackagesStringBranch', 'branch', branch)
            const localVarPath = `/export/sitemap_packages/{branch}`
                .replace(`{${"branch"}}`, encodeURIComponent(String(branch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an archive of PO files with package\'s summary and description for translation purpose
         * @param {Array<string>} branches list of package sets to filter result
         * @param {string} [fromDate] take packages of branch states from date (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTranslationExportExportTranslationPackagesPoFiles: async (branches: Array<string>, fromDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branches' is not null or undefined
            assertParamExists('getRouteTranslationExportExportTranslationPackagesPoFiles', 'branches', branches)
            const localVarPath = `/export/translation/packages_po_files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branches) {
                localVarQueryParameter['branches'] = branches.join(COLLECTION_FORMATS.csv);
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString().substring(0,10) :
                    fromDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportApiAxiosParamCreator(configuration)
    return {
        /**
         * Branch tree info export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBranchTreeExportExportBranchTree(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchTreeModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBranchTreeExportExportBranchTree(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.getRouteBranchTreeExportExportBranchTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get branch info export for Repology
         * @param {string} branch branch name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageInfoExportRepologyStringBranch(branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepologyExportModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageInfoExportRepologyStringBranch(branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.getRoutePackageInfoExportRepologyStringBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get branch binary packages info
         * @param {string} branch branch name
         * @param {string} [arch] package architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch(branch: string, arch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagesetPackagesExportModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch(branch, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get branch source packages for sitemap
         * @param {string} branch branch name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteSitemapPackagesExportSitemapPackagesStringBranch(branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitemapPackagesExportModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteSitemapPackagesExportSitemapPackagesStringBranch(branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.getRouteSitemapPackagesExportSitemapPackagesStringBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an archive of PO files with package\'s summary and description for translation purpose
         * @param {Array<string>} branches list of package sets to filter result
         * @param {string} [fromDate] take packages of branch states from date (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTranslationExportExportTranslationPackagesPoFiles(branches: Array<string>, fromDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTranslationExportExportTranslationPackagesPoFiles(branches, fromDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExportApi.getRouteTranslationExportExportTranslationPackagesPoFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportApiFp(configuration)
    return {
        /**
         * Branch tree info export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBranchTreeExportExportBranchTree(options?: any): AxiosPromise<BranchTreeModel> {
            return localVarFp.getRouteBranchTreeExportExportBranchTree(options).then((request) => request(axios, basePath));
        },
        /**
         * Get branch info export for Repology
         * @param {string} branch branch name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageInfoExportRepologyStringBranch(branch: string, options?: any): AxiosPromise<RepologyExportModel> {
            return localVarFp.getRoutePackageInfoExportRepologyStringBranch(branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get branch binary packages info
         * @param {string} branch branch name
         * @param {string} [arch] package architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch(branch: string, arch?: string, options?: any): AxiosPromise<PackagesetPackagesExportModel> {
            return localVarFp.getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch(branch, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get branch source packages for sitemap
         * @param {string} branch branch name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSitemapPackagesExportSitemapPackagesStringBranch(branch: string, options?: any): AxiosPromise<SitemapPackagesExportModel> {
            return localVarFp.getRouteSitemapPackagesExportSitemapPackagesStringBranch(branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an archive of PO files with package\'s summary and description for translation purpose
         * @param {Array<string>} branches list of package sets to filter result
         * @param {string} [fromDate] take packages of branch states from date (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTranslationExportExportTranslationPackagesPoFiles(branches: Array<string>, fromDate?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getRouteTranslationExportExportTranslationPackagesPoFiles(branches, fromDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * Branch tree info export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public getRouteBranchTreeExportExportBranchTree(options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).getRouteBranchTreeExportExportBranchTree(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get branch info export for Repology
     * @param {string} branch branch name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public getRoutePackageInfoExportRepologyStringBranch(branch: string, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).getRoutePackageInfoExportRepologyStringBranch(branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get branch binary packages info
     * @param {string} branch branch name
     * @param {string} [arch] package architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch(branch: string, arch?: string, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch(branch, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get branch source packages for sitemap
     * @param {string} branch branch name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public getRouteSitemapPackagesExportSitemapPackagesStringBranch(branch: string, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).getRouteSitemapPackagesExportSitemapPackagesStringBranch(branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an archive of PO files with package\'s summary and description for translation purpose
     * @param {Array<string>} branches list of package sets to filter result
     * @param {string} [fromDate] take packages of branch states from date (YYYY-MM-DD)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public getRouteTranslationExportExportTranslationPackagesPoFiles(branches: Array<string>, fromDate?: string, options?: RawAxiosRequestConfig) {
        return ExportApiFp(this.configuration).getRouteTranslationExportExportTranslationPackagesPoFiles(branches, fromDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fast search files by name (case sensitive) including partial occurrence.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {number} [limit] number of files to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFastLookupFileFastLookup: async (branch: string, fileName: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteFastLookupFileFastLookup', 'branch', branch)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getRouteFastLookupFileFastLookup', 'fileName', fileName)
            const localVarPath = `/file/fast_lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find files by name (case sensitive) including partial occurrence.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {number} [limit] number of files to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFileSearchFileSearch: async (branch: string, fileName: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteFileSearchFileSearch', 'branch', branch)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getRouteFileSearchFileSearch', 'fileName', fileName)
            const localVarPath = `/file/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of packages to which the specified file belongs to.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesByFileFilePackagesByFile: async (branch: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackagesByFileFilePackagesByFile', 'branch', branch)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getRoutePackagesByFileFilePackagesByFile', 'fileName', fileName)
            const localVarPath = `/file/packages_by_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Fast search files by name (case sensitive) including partial occurrence.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {number} [limit] number of files to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFastLookupFileFastLookup(branch: string, fileName: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FastFileSearchModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFastLookupFileFastLookup(branch, fileName, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getRouteFastLookupFileFastLookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find files by name (case sensitive) including partial occurrence.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {number} [limit] number of files to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFileSearchFileSearch(branch: string, fileName: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFileSearchFileSearch(branch, fileName, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getRouteFileSearchFileSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of packages to which the specified file belongs to.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesByFileFilePackagesByFile(branch: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilePackagesByFileModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesByFileFilePackagesByFile(branch, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.getRoutePackagesByFileFilePackagesByFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Fast search files by name (case sensitive) including partial occurrence.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {number} [limit] number of files to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFastLookupFileFastLookup(branch: string, fileName: string, limit?: number, options?: any): AxiosPromise<FastFileSearchModel> {
            return localVarFp.getRouteFastLookupFileFastLookup(branch, fileName, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Find files by name (case sensitive) including partial occurrence.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {number} [limit] number of files to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFileSearchFileSearch(branch: string, fileName: string, limit?: number, options?: any): AxiosPromise<FilesModel> {
            return localVarFp.getRouteFileSearchFileSearch(branch, fileName, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of packages to which the specified file belongs to.
         * @param {string} branch name of packageset
         * @param {string} fileName file name or directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesByFileFilePackagesByFile(branch: string, fileName: string, options?: any): AxiosPromise<FilePackagesByFileModel> {
            return localVarFp.getRoutePackagesByFileFilePackagesByFile(branch, fileName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Fast search files by name (case sensitive) including partial occurrence.
     * @param {string} branch name of packageset
     * @param {string} fileName file name or directory
     * @param {number} [limit] number of files to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getRouteFastLookupFileFastLookup(branch: string, fileName: string, limit?: number, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getRouteFastLookupFileFastLookup(branch, fileName, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find files by name (case sensitive) including partial occurrence.
     * @param {string} branch name of packageset
     * @param {string} fileName file name or directory
     * @param {number} [limit] number of files to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getRouteFileSearchFileSearch(branch: string, fileName: string, limit?: number, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getRouteFileSearchFileSearch(branch, fileName, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of packages to which the specified file belongs to.
     * @param {string} branch name of packageset
     * @param {string} fileName file name or directory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getRoutePackagesByFileFilePackagesByFile(branch: string, fileName: string, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).getRoutePackagesByFileFilePackagesByFile(branch, fileName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get active images for a given repository
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {string} [version] Image version
         * @param {string} [release] Image release type
         * @param {string} [variant] Image variant
         * @param {string} [type] Image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteActiveImagesImageActiveImages: async (branch?: string, edition?: string, version?: string, release?: string, variant?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/active_images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (edition !== undefined) {
                localVarQueryParameter['edition'] = edition;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (release !== undefined) {
                localVarQueryParameter['release'] = release;
            }

            if (variant !== undefined) {
                localVarQueryParameter['variant'] = variant;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all ISO images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllIsoImagesImageIsoAllImages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/iso/all_images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get images by package name for a given repository and edition
         * @param {string} pkgName package name
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum} [pkgType] packages type [source|binary]
         * @param {GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum} [imgShow] show images[active|all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindImagesByPackageImageFindImagesByPackageName: async (pkgName: string, branch?: string, edition?: string, pkgType?: GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum, imgShow?: GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkgName' is not null or undefined
            assertParamExists('getRouteFindImagesByPackageImageFindImagesByPackageName', 'pkgName', pkgName)
            const localVarPath = `/image/find_images_by_package_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (pkgName !== undefined) {
                localVarQueryParameter['pkg_name'] = pkgName;
            }

            if (edition !== undefined) {
                localVarQueryParameter['edition'] = edition;
            }

            if (pkgType !== undefined) {
                localVarQueryParameter['pkg_type'] = pkgType;
            }

            if (imgShow !== undefined) {
                localVarQueryParameter['img_show'] = imgShow;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of package categories with count for image
         * @param {string} uuid Image UUID
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageCategoriesCountImageImageCategoriesCount: async (uuid: string, component?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRouteImageCategoriesCountImageImageCategoriesCount', 'uuid', uuid)
            const localVarPath = `/image/image_categories_count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get branch images info
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {string} [version] Image version
         * @param {string} [release] Image release type
         * @param {string} [variant] Image variant
         * @param {string} [flavor] Image flavor
         * @param {string} [arch] Image architecture
         * @param {string} [component] Image component
         * @param {string} [platform] Image platform
         * @param {string} [type] Image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageInfoImageImageInfo: async (branch?: string, edition?: string, version?: string, release?: string, variant?: string, flavor?: string, arch?: string, component?: string, platform?: string, type?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/image_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (edition !== undefined) {
                localVarQueryParameter['edition'] = edition;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (release !== undefined) {
                localVarQueryParameter['release'] = release;
            }

            if (variant !== undefined) {
                localVarQueryParameter['variant'] = variant;
            }

            if (flavor !== undefined) {
                localVarQueryParameter['flavor'] = flavor;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of package sets which has an active images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImagePackageSetImageImagePackageset: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/image_packageset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of image packages in accordance to given parameters
         * @param {string} uuid Image UUID
         * @param {string} [group] package category
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImagePackagesImageImagePackages: async (uuid: string, group?: string, component?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRouteImagePackagesImageImagePackages', 'uuid', uuid)
            const localVarPath = `/image/image_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get image status into database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/image_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iso image status into database
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageTagStatus: async (branch?: string, edition?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image/image_tag_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (edition !== undefined) {
                localVarQueryParameter['edition'] = edition;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get image UUID by image tag
         * @param {string} tag Image tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageTagUuidImageImageUuidByTag: async (tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('getRouteImageTagUuidImageImageUuidByTag', 'tag', tag)
            const localVarPath = `/image/image_uuid_by_tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of last packages from image for given parameters
         * @param {string} branch name of packageset
         * @param {string} uuid Image UUID
         * @param {number} [packagesLimit] number of last packages to get
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastImagePackagesImageLastPackagesByImage: async (branch: string, uuid: string, packagesLimit?: number, component?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteLastImagePackagesImageLastPackagesByImage', 'branch', branch)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRouteLastImagePackagesImageLastPackagesByImage', 'uuid', uuid)
            const localVarPath = `/image/last_packages_by_image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (packagesLimit !== undefined) {
                localVarQueryParameter['packages_limit'] = packagesLimit;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about last packages with CVE fixes mentioned in changelog for given image
         * @param {string} branch name of packageset
         * @param {string} uuid Image UUID
         * @param {number} [packagesLimit] number of last packages to get
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed: async (branch: string, uuid: string, packagesLimit?: number, component?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed', 'branch', branch)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed', 'uuid', uuid)
            const localVarPath = `/image/last_packages_image_with_cve_fixed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (packagesLimit !== undefined) {
                localVarQueryParameter['packages_limit'] = packagesLimit;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect binary packages from regular distribution image
         * @param {ImagePackagesJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteCheckPackagesRegularImageInspectRegular: async (payload: ImagePackagesJSONModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRouteCheckPackagesRegularImageInspectRegular', 'payload', payload)
            const localVarPath = `/image/inspect/regular`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect binary packages from SP distribution image
         * @param {ImagePackagesJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteCheckPackagesSpImageInspectSp: async (payload: ImagePackagesJSONModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRouteCheckPackagesSpImageInspectSp', 'payload', payload)
            const localVarPath = `/image/inspect/sp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load image status into database
         * @param {ImageJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteImageStatus: async (payload: ImageJSONModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRouteImageStatus', 'payload', payload)
            const localVarPath = `/image/image_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load iso image status into database
         * @param {ImageTagJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteImageTagStatus: async (payload: ImageTagJSONModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRouteImageTagStatus', 'payload', payload)
            const localVarPath = `/image/image_tag_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * Get active images for a given repository
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {string} [version] Image version
         * @param {string} [release] Image release type
         * @param {string} [variant] Image variant
         * @param {string} [type] Image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteActiveImagesImageActiveImages(branch?: string, edition?: string, version?: string, release?: string, variant?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveImagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteActiveImagesImageActiveImages(branch, edition, version, release, variant, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteActiveImagesImageActiveImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all ISO images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAllIsoImagesImageIsoAllImages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageAllISOModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAllIsoImagesImageIsoAllImages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteAllIsoImagesImageIsoAllImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get images by package name for a given repository and edition
         * @param {string} pkgName package name
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum} [pkgType] packages type [source|binary]
         * @param {GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum} [imgShow] show images[active|all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFindImagesByPackageImageFindImagesByPackageName(pkgName: string, branch?: string, edition?: string, pkgType?: GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum, imgShow?: GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindImagesByPackageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFindImagesByPackageImageFindImagesByPackageName(pkgName, branch, edition, pkgType, imgShow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteFindImagesByPackageImageFindImagesByPackageName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of package categories with count for image
         * @param {string} uuid Image UUID
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteImageCategoriesCountImageImageCategoriesCount(uuid: string, component?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteImageCategoriesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteImageCategoriesCountImageImageCategoriesCount(uuid, component, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteImageCategoriesCountImageImageCategoriesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get branch images info
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {string} [version] Image version
         * @param {string} [release] Image release type
         * @param {string} [variant] Image variant
         * @param {string} [flavor] Image flavor
         * @param {string} [arch] Image architecture
         * @param {string} [component] Image component
         * @param {string} [platform] Image platform
         * @param {string} [type] Image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteImageInfoImageImageInfo(branch?: string, edition?: string, version?: string, release?: string, variant?: string, flavor?: string, arch?: string, component?: string, platform?: string, type?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteImageInfoImageImageInfo(branch, edition, version, release, variant, flavor, arch, component, platform, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteImageInfoImageImageInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of package sets which has an active images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteImagePackageSetImageImagePackageset(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagePackageSetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteImagePackageSetImageImagePackageset(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteImagePackageSetImageImagePackageset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of image packages in accordance to given parameters
         * @param {string} uuid Image UUID
         * @param {string} [group] package category
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteImagePackagesImageImagePackages(uuid: string, group?: string, component?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagePackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteImagePackagesImageImagePackages(uuid, group, component, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteImagePackagesImageImagePackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get image status into database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteImageStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageStatusGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteImageStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteImageStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get iso image status into database
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteImageTagStatus(branch?: string, edition?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTagStatusGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteImageTagStatus(branch, edition, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteImageTagStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get image UUID by image tag
         * @param {string} tag Image tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteImageTagUuidImageImageUuidByTag(tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTagUUIDModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteImageTagUuidImageImageUuidByTag(tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteImageTagUuidImageImageUuidByTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of last packages from image for given parameters
         * @param {string} branch name of packageset
         * @param {string} uuid Image UUID
         * @param {number} [packagesLimit] number of last packages to get
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLastImagePackagesImageLastPackagesByImage(branch: string, uuid: string, packagesLimit?: number, component?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastImagePackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLastImagePackagesImageLastPackagesByImage(branch, uuid, packagesLimit, component, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteLastImagePackagesImageLastPackagesByImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about last packages with CVE fixes mentioned in changelog for given image
         * @param {string} branch name of packageset
         * @param {string} uuid Image UUID
         * @param {number} [packagesLimit] number of last packages to get
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed(branch: string, uuid: string, packagesLimit?: number, component?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastImagePackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed(branch, uuid, packagesLimit, component, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inspect binary packages from regular distribution image
         * @param {ImagePackagesJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteCheckPackagesRegularImageInspectRegular(payload: ImagePackagesJSONModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagePackagesInspectRegularModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteCheckPackagesRegularImageInspectRegular(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postRouteCheckPackagesRegularImageInspectRegular']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inspect binary packages from SP distribution image
         * @param {ImagePackagesJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteCheckPackagesSpImageInspectSp(payload: ImagePackagesJSONModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImagePackagesInspectSPModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteCheckPackagesSpImageInspectSp(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postRouteCheckPackagesSpImageInspectSp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Load image status into database
         * @param {ImageJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteImageStatus(payload: ImageJSONModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteImageStatus(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postRouteImageStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Load iso image status into database
         * @param {ImageTagJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteImageTagStatus(payload: ImageTagJSONModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteImageTagStatus(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageApi.postRouteImageTagStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * Get active images for a given repository
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {string} [version] Image version
         * @param {string} [release] Image release type
         * @param {string} [variant] Image variant
         * @param {string} [type] Image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteActiveImagesImageActiveImages(branch?: string, edition?: string, version?: string, release?: string, variant?: string, type?: string, options?: any): AxiosPromise<ActiveImagesModel> {
            return localVarFp.getRouteActiveImagesImageActiveImages(branch, edition, version, release, variant, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all ISO images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllIsoImagesImageIsoAllImages(options?: any): AxiosPromise<ImageAllISOModel> {
            return localVarFp.getRouteAllIsoImagesImageIsoAllImages(options).then((request) => request(axios, basePath));
        },
        /**
         * Get images by package name for a given repository and edition
         * @param {string} pkgName package name
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum} [pkgType] packages type [source|binary]
         * @param {GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum} [imgShow] show images[active|all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindImagesByPackageImageFindImagesByPackageName(pkgName: string, branch?: string, edition?: string, pkgType?: GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum, imgShow?: GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum, options?: any): AxiosPromise<FindImagesByPackageModel> {
            return localVarFp.getRouteFindImagesByPackageImageFindImagesByPackageName(pkgName, branch, edition, pkgType, imgShow, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of package categories with count for image
         * @param {string} uuid Image UUID
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageCategoriesCountImageImageCategoriesCount(uuid: string, component?: string, options?: any): AxiosPromise<SiteImageCategoriesModel> {
            return localVarFp.getRouteImageCategoriesCountImageImageCategoriesCount(uuid, component, options).then((request) => request(axios, basePath));
        },
        /**
         * Get branch images info
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {string} [version] Image version
         * @param {string} [release] Image release type
         * @param {string} [variant] Image variant
         * @param {string} [flavor] Image flavor
         * @param {string} [arch] Image architecture
         * @param {string} [component] Image component
         * @param {string} [platform] Image platform
         * @param {string} [type] Image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageInfoImageImageInfo(branch?: string, edition?: string, version?: string, release?: string, variant?: string, flavor?: string, arch?: string, component?: string, platform?: string, type?: string, options?: any): AxiosPromise<ImageInfoModel> {
            return localVarFp.getRouteImageInfoImageImageInfo(branch, edition, version, release, variant, flavor, arch, component, platform, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of package sets which has an active images.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImagePackageSetImageImagePackageset(options?: any): AxiosPromise<ImagePackageSetModel> {
            return localVarFp.getRouteImagePackageSetImageImagePackageset(options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of image packages in accordance to given parameters
         * @param {string} uuid Image UUID
         * @param {string} [group] package category
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImagePackagesImageImagePackages(uuid: string, group?: string, component?: string, options?: any): AxiosPromise<ImagePackagesModel> {
            return localVarFp.getRouteImagePackagesImageImagePackages(uuid, group, component, options).then((request) => request(axios, basePath));
        },
        /**
         * Get image status into database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageStatus(options?: any): AxiosPromise<ImageStatusGetModel> {
            return localVarFp.getRouteImageStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get iso image status into database
         * @param {string} [branch] name of packageset
         * @param {string} [edition] Image edition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageTagStatus(branch?: string, edition?: string, options?: any): AxiosPromise<ImageTagStatusGetModel> {
            return localVarFp.getRouteImageTagStatus(branch, edition, options).then((request) => request(axios, basePath));
        },
        /**
         * Get image UUID by image tag
         * @param {string} tag Image tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteImageTagUuidImageImageUuidByTag(tag: string, options?: any): AxiosPromise<ImageTagUUIDModel> {
            return localVarFp.getRouteImageTagUuidImageImageUuidByTag(tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of last packages from image for given parameters
         * @param {string} branch name of packageset
         * @param {string} uuid Image UUID
         * @param {number} [packagesLimit] number of last packages to get
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastImagePackagesImageLastPackagesByImage(branch: string, uuid: string, packagesLimit?: number, component?: string, options?: any): AxiosPromise<LastImagePackagesModel> {
            return localVarFp.getRouteLastImagePackagesImageLastPackagesByImage(branch, uuid, packagesLimit, component, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about last packages with CVE fixes mentioned in changelog for given image
         * @param {string} branch name of packageset
         * @param {string} uuid Image UUID
         * @param {number} [packagesLimit] number of last packages to get
         * @param {string} [component] Image component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed(branch: string, uuid: string, packagesLimit?: number, component?: string, options?: any): AxiosPromise<LastImagePackagesModel> {
            return localVarFp.getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed(branch, uuid, packagesLimit, component, options).then((request) => request(axios, basePath));
        },
        /**
         * Inspect binary packages from regular distribution image
         * @param {ImagePackagesJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteCheckPackagesRegularImageInspectRegular(payload: ImagePackagesJSONModel, options?: any): AxiosPromise<ImagePackagesInspectRegularModel> {
            return localVarFp.postRouteCheckPackagesRegularImageInspectRegular(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Inspect binary packages from SP distribution image
         * @param {ImagePackagesJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteCheckPackagesSpImageInspectSp(payload: ImagePackagesJSONModel, options?: any): AxiosPromise<ImagePackagesInspectSPModel> {
            return localVarFp.postRouteCheckPackagesSpImageInspectSp(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Load image status into database
         * @param {ImageJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteImageStatus(payload: ImageJSONModel, options?: any): AxiosPromise<void> {
            return localVarFp.postRouteImageStatus(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Load iso image status into database
         * @param {ImageTagJSONModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteImageTagStatus(payload: ImageTagJSONModel, options?: any): AxiosPromise<void> {
            return localVarFp.postRouteImageTagStatus(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * Get active images for a given repository
     * @param {string} [branch] name of packageset
     * @param {string} [edition] Image edition
     * @param {string} [version] Image version
     * @param {string} [release] Image release type
     * @param {string} [variant] Image variant
     * @param {string} [type] Image type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteActiveImagesImageActiveImages(branch?: string, edition?: string, version?: string, release?: string, variant?: string, type?: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteActiveImagesImageActiveImages(branch, edition, version, release, variant, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all ISO images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteAllIsoImagesImageIsoAllImages(options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteAllIsoImagesImageIsoAllImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get images by package name for a given repository and edition
     * @param {string} pkgName package name
     * @param {string} [branch] name of packageset
     * @param {string} [edition] Image edition
     * @param {GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum} [pkgType] packages type [source|binary]
     * @param {GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum} [imgShow] show images[active|all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteFindImagesByPackageImageFindImagesByPackageName(pkgName: string, branch?: string, edition?: string, pkgType?: GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum, imgShow?: GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteFindImagesByPackageImageFindImagesByPackageName(pkgName, branch, edition, pkgType, imgShow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of package categories with count for image
     * @param {string} uuid Image UUID
     * @param {string} [component] Image component
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteImageCategoriesCountImageImageCategoriesCount(uuid: string, component?: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteImageCategoriesCountImageImageCategoriesCount(uuid, component, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get branch images info
     * @param {string} [branch] name of packageset
     * @param {string} [edition] Image edition
     * @param {string} [version] Image version
     * @param {string} [release] Image release type
     * @param {string} [variant] Image variant
     * @param {string} [flavor] Image flavor
     * @param {string} [arch] Image architecture
     * @param {string} [component] Image component
     * @param {string} [platform] Image platform
     * @param {string} [type] Image type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteImageInfoImageImageInfo(branch?: string, edition?: string, version?: string, release?: string, variant?: string, flavor?: string, arch?: string, component?: string, platform?: string, type?: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteImageInfoImageImageInfo(branch, edition, version, release, variant, flavor, arch, component, platform, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of package sets which has an active images.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteImagePackageSetImageImagePackageset(options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteImagePackageSetImageImagePackageset(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of image packages in accordance to given parameters
     * @param {string} uuid Image UUID
     * @param {string} [group] package category
     * @param {string} [component] Image component
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteImagePackagesImageImagePackages(uuid: string, group?: string, component?: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteImagePackagesImageImagePackages(uuid, group, component, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get image status into database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteImageStatus(options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteImageStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iso image status into database
     * @param {string} [branch] name of packageset
     * @param {string} [edition] Image edition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteImageTagStatus(branch?: string, edition?: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteImageTagStatus(branch, edition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get image UUID by image tag
     * @param {string} tag Image tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteImageTagUuidImageImageUuidByTag(tag: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteImageTagUuidImageImageUuidByTag(tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of last packages from image for given parameters
     * @param {string} branch name of packageset
     * @param {string} uuid Image UUID
     * @param {number} [packagesLimit] number of last packages to get
     * @param {string} [component] Image component
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteLastImagePackagesImageLastPackagesByImage(branch: string, uuid: string, packagesLimit?: number, component?: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteLastImagePackagesImageLastPackagesByImage(branch, uuid, packagesLimit, component, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about last packages with CVE fixes mentioned in changelog for given image
     * @param {string} branch name of packageset
     * @param {string} uuid Image UUID
     * @param {number} [packagesLimit] number of last packages to get
     * @param {string} [component] Image component
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed(branch: string, uuid: string, packagesLimit?: number, component?: string, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed(branch, uuid, packagesLimit, component, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inspect binary packages from regular distribution image
     * @param {ImagePackagesJSONModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postRouteCheckPackagesRegularImageInspectRegular(payload: ImagePackagesJSONModel, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postRouteCheckPackagesRegularImageInspectRegular(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inspect binary packages from SP distribution image
     * @param {ImagePackagesJSONModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postRouteCheckPackagesSpImageInspectSp(payload: ImagePackagesJSONModel, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postRouteCheckPackagesSpImageInspectSp(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Load image status into database
     * @param {ImageJSONModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postRouteImageStatus(payload: ImageJSONModel, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postRouteImageStatus(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Load iso image status into database
     * @param {ImageTagJSONModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postRouteImageTagStatus(payload: ImageTagJSONModel, options?: RawAxiosRequestConfig) {
        return ImageApiFp(this.configuration).postRouteImageTagStatus(payload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum = typeof GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum[keyof typeof GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum];
/**
 * @export
 */
export const GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum = {
    Active: 'active',
    All: 'all'
} as const;
export type GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum = typeof GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum[keyof typeof GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum];


/**
 * LicenseApi - axios parameter creator
 * @export
 */
export const LicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get license info by SPDX license ID
         * @param {string} license SPDX license id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLicenseInfoLicenseInfo: async (license: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'license' is not null or undefined
            assertParamExists('getRouteLicenseInfoLicenseInfo', 'license', license)
            const localVarPath = `/license/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (license !== undefined) {
                localVarQueryParameter['license'] = license;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get valid license tokens and SPDX license IDs
         * @param {string} license package license string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLicenseTokensLicenseTokens: async (license: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'license' is not null or undefined
            assertParamExists('getRouteLicenseTokensLicenseTokens', 'license', license)
            const localVarPath = `/license/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (license !== undefined) {
                localVarQueryParameter['license'] = license;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseApi - functional programming interface
 * @export
 */
export const LicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * Get license info by SPDX license ID
         * @param {string} license SPDX license id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLicenseInfoLicenseInfo(license: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLicenseInfoLicenseInfo(license, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.getRouteLicenseInfoLicenseInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get valid license tokens and SPDX license IDs
         * @param {string} license package license string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLicenseTokensLicenseTokens(license: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseTokensModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLicenseTokensLicenseTokens(license, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicenseApi.getRouteLicenseTokensLicenseTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicenseApi - factory interface
 * @export
 */
export const LicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseApiFp(configuration)
    return {
        /**
         * Get license info by SPDX license ID
         * @param {string} license SPDX license id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLicenseInfoLicenseInfo(license: string, options?: any): AxiosPromise<LicenseInfoModel> {
            return localVarFp.getRouteLicenseInfoLicenseInfo(license, options).then((request) => request(axios, basePath));
        },
        /**
         * Get valid license tokens and SPDX license IDs
         * @param {string} license package license string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLicenseTokensLicenseTokens(license: string, options?: any): AxiosPromise<LicenseTokensModel> {
            return localVarFp.getRouteLicenseTokensLicenseTokens(license, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseApi - object-oriented interface
 * @export
 * @class LicenseApi
 * @extends {BaseAPI}
 */
export class LicenseApi extends BaseAPI {
    /**
     * Get license info by SPDX license ID
     * @param {string} license SPDX license id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public getRouteLicenseInfoLicenseInfo(license: string, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).getRouteLicenseInfoLicenseInfo(license, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get valid license tokens and SPDX license IDs
     * @param {string} license package license string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseApi
     */
    public getRouteLicenseTokensLicenseTokens(license: string, options?: RawAxiosRequestConfig) {
        return LicenseApiFp(this.configuration).getRouteLicenseTokensLicenseTokens(license, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PackageApi - axios parameter creator
 * @export
 */
export const PackageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get package files by hash
         * @param {number} pkghash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBinPackageFilesPackagePackageFilesIntPkghash: async (pkghash: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRouteBinPackageFilesPackagePackageFilesIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/package/package_files/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about packages from package sets by given source packages list
         * @param {Array<string>} packages package or list of packages
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindPackagesetPackageFindPackageset: async (packages: Array<string>, branches?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packages' is not null or undefined
            assertParamExists('getRouteFindPackagesetPackageFindPackageset', 'packages', packages)
            const localVarPath = `/package/find_packageset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (packages) {
                localVarQueryParameter['packages'] = packages.join(COLLECTION_FORMATS.csv);
            }

            if (branches) {
                localVarQueryParameter['branches'] = branches.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get packages build dependencies by set of parameters
         * @param {Array<string>} packages package or list of packages
         * @param {string} branch name of packageset
         * @param {number} [depth] dependency depth
         * @param {GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum} [dptype] dependency type [source|binary|both]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [leaf] assembly dependency chain package
         * @param {boolean} [finitePackage] topological tree leaves packages
         * @param {Array<string>} [filterByPackage] filter result by dependency on binary packages
         * @param {string} [filterBySource] filter result by dependency on source package
         * @param {boolean} [oneandhalf] use dependency depth 1.5
         * @param {boolean} [useLastTasks] use repo state including last done tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageBuildDependencyPackageWhatDependsSrc: async (packages: Array<string>, branch: string, depth?: number, dptype?: GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum, archs?: Array<string>, leaf?: string, finitePackage?: boolean, filterByPackage?: Array<string>, filterBySource?: string, oneandhalf?: boolean, useLastTasks?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packages' is not null or undefined
            assertParamExists('getRoutePackageBuildDependencyPackageWhatDependsSrc', 'packages', packages)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageBuildDependencyPackageWhatDependsSrc', 'branch', branch)
            const localVarPath = `/package/what_depends_src`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (packages) {
                localVarQueryParameter['packages'] = packages.join(COLLECTION_FORMATS.csv);
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if (dptype !== undefined) {
                localVarQueryParameter['dptype'] = dptype;
            }

            if (archs) {
                localVarQueryParameter['archs'] = archs.join(COLLECTION_FORMATS.csv);
            }

            if (leaf !== undefined) {
                localVarQueryParameter['leaf'] = leaf;
            }

            if (finitePackage !== undefined) {
                localVarQueryParameter['finite_package'] = finitePackage;
            }

            if (filterByPackage) {
                localVarQueryParameter['filter_by_package'] = filterByPackage.join(COLLECTION_FORMATS.csv);
            }

            if (filterBySource !== undefined) {
                localVarQueryParameter['filter_by_source'] = filterBySource;
            }

            if (oneandhalf !== undefined) {
                localVarQueryParameter['oneandhalf'] = oneandhalf;
            }

            if (useLastTasks !== undefined) {
                localVarQueryParameter['use_last_tasks'] = useLastTasks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of packages required for build by given source packages list recursively
         * @param {string} branch name of packageset
         * @param {Array<string>} packages package or list of packages
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageBuildDependencySetPackageBuildDependencySet: async (branch: string, packages: Array<string>, arch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageBuildDependencySetPackageBuildDependencySet', 'branch', branch)
            // verify required parameter 'packages' is not null or undefined
            assertParamExists('getRoutePackageBuildDependencySetPackageBuildDependencySet', 'packages', packages)
            const localVarPath = `/package/build_dependency_set`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (packages) {
                localVarQueryParameter['packages'] = packages.join(COLLECTION_FORMATS.csv);
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about binary packages from  last package sets by given file MD5 checksum and package set name
         * @param {string} branch name of packageset
         * @param {string} md5 file MD5 checksum
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageByFileMd5PackagePackageByFileMd5: async (branch: string, md5: string, arch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageByFileMd5PackagePackageByFileMd5', 'branch', branch)
            // verify required parameter 'md5' is not null or undefined
            assertParamExists('getRoutePackageByFileMd5PackagePackageByFileMd5', 'md5', md5)
            const localVarPath = `/package/package_by_file_md5`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (md5 !== undefined) {
                localVarQueryParameter['md5'] = md5;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about binary packages from  last package sets by given file name and package set name. File name wildcars \'*\' is allowed.
         * @param {string} file file name
         * @param {string} branch name of packageset
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageByFileNamePackagePackageByFileName: async (file: string, branch: string, arch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('getRoutePackageByFileNamePackagePackageByFileName', 'file', file)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageByFileNamePackagePackageByFileName', 'branch', branch)
            const localVarPath = `/package/package_by_file_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (file !== undefined) {
                localVarQueryParameter['file'] = file;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for package by parameters from last packages
         * @param {string} [name] package name
         * @param {string} [version] package version
         * @param {string} [release] package release
         * @param {string} [arch] packages architecture
         * @param {boolean} [source] is source package
         * @param {string} [branch] name of packageset
         * @param {string} [disttag] package disttag
         * @param {string} [sha1] package SHA1 checksum
         * @param {string} [packager] package packager name
         * @param {string} [packagerEmail] package packager email
         * @param {boolean} [full] show full package information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageInfoPackagePackageInfo: async (name?: string, version?: string, release?: string, arch?: string, source?: boolean, branch?: string, disttag?: string, sha1?: string, packager?: string, packagerEmail?: string, full?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/package/package_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (release !== undefined) {
                localVarQueryParameter['release'] = release;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (disttag !== undefined) {
                localVarQueryParameter['disttag'] = disttag;
            }

            if (sha1 !== undefined) {
                localVarQueryParameter['sha1'] = sha1;
            }

            if (packager !== undefined) {
                localVarQueryParameter['packager'] = packager;
            }

            if (packagerEmail !== undefined) {
                localVarQueryParameter['packager_email'] = packagerEmail;
            }

            if (full !== undefined) {
                localVarQueryParameter['full'] = full;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get packages with conflicting files in packages that don\'t have a conflict in dependencies
         * @param {Array<string>} packages package or list of packages
         * @param {string} branch name of packageset
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageMisconflictPackagesPackageMisconflict: async (packages: Array<string>, branch: string, archs?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'packages' is not null or undefined
            assertParamExists('getRoutePackageMisconflictPackagesPackageMisconflict', 'packages', packages)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageMisconflictPackagesPackageMisconflict', 'branch', branch)
            const localVarPath = `/package/misconflict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (packages) {
                localVarQueryParameter['packages'] = packages.join(COLLECTION_FORMATS.csv);
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (archs) {
                localVarQueryParameter['archs'] = archs.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get repocop data by name, version and release
         * @param {string} branch name of packageset
         * @param {string} packageName source or binary package name
         * @param {string} [packageVersion] source or binary package version
         * @param {string} [packageRelease] source or binary package release
         * @param {string} [binPackageArch] binary package arch
         * @param {GetRoutePackageRepocopPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageRepocop: async (branch: string, packageName: string, packageVersion?: string, packageRelease?: string, binPackageArch?: string, packageType?: GetRoutePackageRepocopPackageTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageRepocop', 'branch', branch)
            // verify required parameter 'packageName' is not null or undefined
            assertParamExists('getRoutePackageRepocop', 'packageName', packageName)
            const localVarPath = `/package/repocop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (packageName !== undefined) {
                localVarQueryParameter['package_name'] = packageName;
            }

            if (packageVersion !== undefined) {
                localVarQueryParameter['package_version'] = packageVersion;
            }

            if (packageRelease !== undefined) {
                localVarQueryParameter['package_release'] = packageRelease;
            }

            if (binPackageArch !== undefined) {
                localVarQueryParameter['bin_package_arch'] = binPackageArch;
            }

            if (packageType !== undefined) {
                localVarQueryParameter['package_type'] = packageType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get spec file by source package hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash: async (pkghash: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/package/specfile_by_hash/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get spec file by source package name and branch
         * @param {string} branch name of packageset
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSpecfileByPackageNamePackageSpecfileByName: async (branch: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteSpecfileByPackageNamePackageSpecfileByName', 'branch', branch)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRouteSpecfileByPackageNamePackageSpecfileByName', 'name', name)
            const localVarPath = `/package/specfile_by_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about unpackaged directories by maintainer nickname
         * @param {string} branch name of packageset
         * @param {string} packager maintainer nickname
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteUnpackagedDirsPackageUnpackagedDirs: async (branch: string, packager: string, archs?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteUnpackagedDirsPackageUnpackagedDirs', 'branch', branch)
            // verify required parameter 'packager' is not null or undefined
            assertParamExists('getRouteUnpackagedDirsPackageUnpackagedDirs', 'packager', packager)
            const localVarPath = `/package/unpackaged_dirs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (packager !== undefined) {
                localVarQueryParameter['packager'] = packager;
            }

            if (archs) {
                localVarQueryParameter['archs'] = archs.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load repocop data into database
         * @param {RepocopJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRoutePackageRepocop: async (payload: RepocopJsonPostListModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRoutePackageRepocop', 'payload', payload)
            const localVarPath = `/package/repocop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about binary packages from  last package sets by given file names array and package set name. File name wildcars \'*\' is not allowed.
         * @param {PackagesByFileNamesJsonModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRoutePackagesByFileNamesPackagePackagesByFileNames: async (payload: PackagesByFileNamesJsonModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRoutePackagesByFileNamesPackagePackagesByFileNames', 'payload', payload)
            const localVarPath = `/package/packages_by_file_names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackageApi - functional programming interface
 * @export
 */
export const PackageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackageApiAxiosParamCreator(configuration)
    return {
        /**
         * Get package files by hash
         * @param {number} pkghash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBinPackageFilesPackagePackageFilesIntPkghash(pkghash: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageFilesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBinPackageFilesPackagePackageFilesIntPkghash(pkghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRouteBinPackageFilesPackagePackageFilesIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about packages from package sets by given source packages list
         * @param {Array<string>} packages package or list of packages
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFindPackagesetPackageFindPackageset(packages: Array<string>, branches?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageFindPackagesetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFindPackagesetPackageFindPackageset(packages, branches, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRouteFindPackagesetPackageFindPackageset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get packages build dependencies by set of parameters
         * @param {Array<string>} packages package or list of packages
         * @param {string} branch name of packageset
         * @param {number} [depth] dependency depth
         * @param {GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum} [dptype] dependency type [source|binary|both]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [leaf] assembly dependency chain package
         * @param {boolean} [finitePackage] topological tree leaves packages
         * @param {Array<string>} [filterByPackage] filter result by dependency on binary packages
         * @param {string} [filterBySource] filter result by dependency on source package
         * @param {boolean} [oneandhalf] use dependency depth 1.5
         * @param {boolean} [useLastTasks] use repo state including last done tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageBuildDependencyPackageWhatDependsSrc(packages: Array<string>, branch: string, depth?: number, dptype?: GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum, archs?: Array<string>, leaf?: string, finitePackage?: boolean, filterByPackage?: Array<string>, filterBySource?: string, oneandhalf?: boolean, useLastTasks?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageBuildDependencyModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageBuildDependencyPackageWhatDependsSrc(packages, branch, depth, dptype, archs, leaf, finitePackage, filterByPackage, filterBySource, oneandhalf, useLastTasks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRoutePackageBuildDependencyPackageWhatDependsSrc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of packages required for build by given source packages list recursively
         * @param {string} branch name of packageset
         * @param {Array<string>} packages package or list of packages
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageBuildDependencySetPackageBuildDependencySet(branch: string, packages: Array<string>, arch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildDependencySetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageBuildDependencySetPackageBuildDependencySet(branch, packages, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRoutePackageBuildDependencySetPackageBuildDependencySet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about binary packages from  last package sets by given file MD5 checksum and package set name
         * @param {string} branch name of packageset
         * @param {string} md5 file MD5 checksum
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageByFileMd5PackagePackageByFileMd5(branch: string, md5: string, arch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageByFileNameModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageByFileMd5PackagePackageByFileMd5(branch, md5, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRoutePackageByFileMd5PackagePackageByFileMd5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about binary packages from  last package sets by given file name and package set name. File name wildcars \'*\' is allowed.
         * @param {string} file file name
         * @param {string} branch name of packageset
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageByFileNamePackagePackageByFileName(file: string, branch: string, arch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageByFileNameModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageByFileNamePackagePackageByFileName(file, branch, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRoutePackageByFileNamePackagePackageByFileName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information for package by parameters from last packages
         * @param {string} [name] package name
         * @param {string} [version] package version
         * @param {string} [release] package release
         * @param {string} [arch] packages architecture
         * @param {boolean} [source] is source package
         * @param {string} [branch] name of packageset
         * @param {string} [disttag] package disttag
         * @param {string} [sha1] package SHA1 checksum
         * @param {string} [packager] package packager name
         * @param {string} [packagerEmail] package packager email
         * @param {boolean} [full] show full package information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageInfoPackagePackageInfo(name?: string, version?: string, release?: string, arch?: string, source?: boolean, branch?: string, disttag?: string, sha1?: string, packager?: string, packagerEmail?: string, full?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageInfoPackagePackageInfo(name, version, release, arch, source, branch, disttag, sha1, packager, packagerEmail, full, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRoutePackageInfoPackagePackageInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get packages with conflicting files in packages that don\'t have a conflict in dependencies
         * @param {Array<string>} packages package or list of packages
         * @param {string} branch name of packageset
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageMisconflictPackagesPackageMisconflict(packages: Array<string>, branch: string, archs?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageMisconflictPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageMisconflictPackagesPackageMisconflict(packages, branch, archs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRoutePackageMisconflictPackagesPackageMisconflict']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get repocop data by name, version and release
         * @param {string} branch name of packageset
         * @param {string} packageName source or binary package name
         * @param {string} [packageVersion] source or binary package version
         * @param {string} [packageRelease] source or binary package release
         * @param {string} [binPackageArch] binary package arch
         * @param {GetRoutePackageRepocopPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageRepocop(branch: string, packageName: string, packageVersion?: string, packageRelease?: string, binPackageArch?: string, packageType?: GetRoutePackageRepocopPackageTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepocopJsonGetListModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageRepocop(branch, packageName, packageVersion, packageRelease, binPackageArch, packageType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRoutePackageRepocop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get spec file by source package hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash(pkghash: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageSpecfileModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash(pkghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get spec file by source package name and branch
         * @param {string} branch name of packageset
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteSpecfileByPackageNamePackageSpecfileByName(branch: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageSpecfileModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteSpecfileByPackageNamePackageSpecfileByName(branch, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRouteSpecfileByPackageNamePackageSpecfileByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about unpackaged directories by maintainer nickname
         * @param {string} branch name of packageset
         * @param {string} packager maintainer nickname
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteUnpackagedDirsPackageUnpackagedDirs(branch: string, packager: string, archs?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnpackagedDirsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteUnpackagedDirsPackageUnpackagedDirs(branch, packager, archs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.getRouteUnpackagedDirsPackageUnpackagedDirs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Load repocop data into database
         * @param {RepocopJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRoutePackageRepocop(payload: RepocopJsonPostListModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRoutePackageRepocop(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.postRoutePackageRepocop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about binary packages from  last package sets by given file names array and package set name. File name wildcars \'*\' is not allowed.
         * @param {PackagesByFileNamesJsonModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRoutePackagesByFileNamesPackagePackagesByFileNames(payload: PackagesByFileNamesJsonModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageByFileNameModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRoutePackagesByFileNamesPackagePackagesByFileNames(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackageApi.postRoutePackagesByFileNamesPackagePackagesByFileNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PackageApi - factory interface
 * @export
 */
export const PackageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackageApiFp(configuration)
    return {
        /**
         * Get package files by hash
         * @param {number} pkghash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBinPackageFilesPackagePackageFilesIntPkghash(pkghash: number, options?: any): AxiosPromise<PackageFilesModel> {
            return localVarFp.getRouteBinPackageFilesPackagePackageFilesIntPkghash(pkghash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about packages from package sets by given source packages list
         * @param {Array<string>} packages package or list of packages
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindPackagesetPackageFindPackageset(packages: Array<string>, branches?: Array<string>, options?: any): AxiosPromise<PackageFindPackagesetModel> {
            return localVarFp.getRouteFindPackagesetPackageFindPackageset(packages, branches, options).then((request) => request(axios, basePath));
        },
        /**
         * Get packages build dependencies by set of parameters
         * @param {Array<string>} packages package or list of packages
         * @param {string} branch name of packageset
         * @param {number} [depth] dependency depth
         * @param {GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum} [dptype] dependency type [source|binary|both]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [leaf] assembly dependency chain package
         * @param {boolean} [finitePackage] topological tree leaves packages
         * @param {Array<string>} [filterByPackage] filter result by dependency on binary packages
         * @param {string} [filterBySource] filter result by dependency on source package
         * @param {boolean} [oneandhalf] use dependency depth 1.5
         * @param {boolean} [useLastTasks] use repo state including last done tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageBuildDependencyPackageWhatDependsSrc(packages: Array<string>, branch: string, depth?: number, dptype?: GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum, archs?: Array<string>, leaf?: string, finitePackage?: boolean, filterByPackage?: Array<string>, filterBySource?: string, oneandhalf?: boolean, useLastTasks?: boolean, options?: any): AxiosPromise<PackageBuildDependencyModel> {
            return localVarFp.getRoutePackageBuildDependencyPackageWhatDependsSrc(packages, branch, depth, dptype, archs, leaf, finitePackage, filterByPackage, filterBySource, oneandhalf, useLastTasks, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of packages required for build by given source packages list recursively
         * @param {string} branch name of packageset
         * @param {Array<string>} packages package or list of packages
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageBuildDependencySetPackageBuildDependencySet(branch: string, packages: Array<string>, arch?: string, options?: any): AxiosPromise<BuildDependencySetModel> {
            return localVarFp.getRoutePackageBuildDependencySetPackageBuildDependencySet(branch, packages, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about binary packages from  last package sets by given file MD5 checksum and package set name
         * @param {string} branch name of packageset
         * @param {string} md5 file MD5 checksum
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageByFileMd5PackagePackageByFileMd5(branch: string, md5: string, arch?: string, options?: any): AxiosPromise<PackageByFileNameModel> {
            return localVarFp.getRoutePackageByFileMd5PackagePackageByFileMd5(branch, md5, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about binary packages from  last package sets by given file name and package set name. File name wildcars \'*\' is allowed.
         * @param {string} file file name
         * @param {string} branch name of packageset
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageByFileNamePackagePackageByFileName(file: string, branch: string, arch?: string, options?: any): AxiosPromise<PackageByFileNameModel> {
            return localVarFp.getRoutePackageByFileNamePackagePackageByFileName(file, branch, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for package by parameters from last packages
         * @param {string} [name] package name
         * @param {string} [version] package version
         * @param {string} [release] package release
         * @param {string} [arch] packages architecture
         * @param {boolean} [source] is source package
         * @param {string} [branch] name of packageset
         * @param {string} [disttag] package disttag
         * @param {string} [sha1] package SHA1 checksum
         * @param {string} [packager] package packager name
         * @param {string} [packagerEmail] package packager email
         * @param {boolean} [full] show full package information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageInfoPackagePackageInfo(name?: string, version?: string, release?: string, arch?: string, source?: boolean, branch?: string, disttag?: string, sha1?: string, packager?: string, packagerEmail?: string, full?: boolean, options?: any): AxiosPromise<PackageInfoModel> {
            return localVarFp.getRoutePackageInfoPackagePackageInfo(name, version, release, arch, source, branch, disttag, sha1, packager, packagerEmail, full, options).then((request) => request(axios, basePath));
        },
        /**
         * Get packages with conflicting files in packages that don\'t have a conflict in dependencies
         * @param {Array<string>} packages package or list of packages
         * @param {string} branch name of packageset
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageMisconflictPackagesPackageMisconflict(packages: Array<string>, branch: string, archs?: Array<string>, options?: any): AxiosPromise<PackageMisconflictPackagesModel> {
            return localVarFp.getRoutePackageMisconflictPackagesPackageMisconflict(packages, branch, archs, options).then((request) => request(axios, basePath));
        },
        /**
         * Get repocop data by name, version and release
         * @param {string} branch name of packageset
         * @param {string} packageName source or binary package name
         * @param {string} [packageVersion] source or binary package version
         * @param {string} [packageRelease] source or binary package release
         * @param {string} [binPackageArch] binary package arch
         * @param {GetRoutePackageRepocopPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageRepocop(branch: string, packageName: string, packageVersion?: string, packageRelease?: string, binPackageArch?: string, packageType?: GetRoutePackageRepocopPackageTypeEnum, options?: any): AxiosPromise<RepocopJsonGetListModel> {
            return localVarFp.getRoutePackageRepocop(branch, packageName, packageVersion, packageRelease, binPackageArch, packageType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get spec file by source package hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash(pkghash: number, options?: any): AxiosPromise<PackageSpecfileModel> {
            return localVarFp.getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash(pkghash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get spec file by source package name and branch
         * @param {string} branch name of packageset
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSpecfileByPackageNamePackageSpecfileByName(branch: string, name: string, options?: any): AxiosPromise<PackageSpecfileModel> {
            return localVarFp.getRouteSpecfileByPackageNamePackageSpecfileByName(branch, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about unpackaged directories by maintainer nickname
         * @param {string} branch name of packageset
         * @param {string} packager maintainer nickname
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteUnpackagedDirsPackageUnpackagedDirs(branch: string, packager: string, archs?: Array<string>, options?: any): AxiosPromise<UnpackagedDirsModel> {
            return localVarFp.getRouteUnpackagedDirsPackageUnpackagedDirs(branch, packager, archs, options).then((request) => request(axios, basePath));
        },
        /**
         * Load repocop data into database
         * @param {RepocopJsonPostListModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRoutePackageRepocop(payload: RepocopJsonPostListModel, options?: any): AxiosPromise<void> {
            return localVarFp.postRoutePackageRepocop(payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about binary packages from  last package sets by given file names array and package set name. File name wildcars \'*\' is not allowed.
         * @param {PackagesByFileNamesJsonModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRoutePackagesByFileNamesPackagePackagesByFileNames(payload: PackagesByFileNamesJsonModel, options?: any): AxiosPromise<PackageByFileNameModel> {
            return localVarFp.postRoutePackagesByFileNamesPackagePackagesByFileNames(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackageApi - object-oriented interface
 * @export
 * @class PackageApi
 * @extends {BaseAPI}
 */
export class PackageApi extends BaseAPI {
    /**
     * Get package files by hash
     * @param {number} pkghash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRouteBinPackageFilesPackagePackageFilesIntPkghash(pkghash: number, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRouteBinPackageFilesPackagePackageFilesIntPkghash(pkghash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about packages from package sets by given source packages list
     * @param {Array<string>} packages package or list of packages
     * @param {Array<string>} [branches] list of package sets to filter result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRouteFindPackagesetPackageFindPackageset(packages: Array<string>, branches?: Array<string>, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRouteFindPackagesetPackageFindPackageset(packages, branches, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get packages build dependencies by set of parameters
     * @param {Array<string>} packages package or list of packages
     * @param {string} branch name of packageset
     * @param {number} [depth] dependency depth
     * @param {GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum} [dptype] dependency type [source|binary|both]
     * @param {Array<string>} [archs] list of packages architectures
     * @param {string} [leaf] assembly dependency chain package
     * @param {boolean} [finitePackage] topological tree leaves packages
     * @param {Array<string>} [filterByPackage] filter result by dependency on binary packages
     * @param {string} [filterBySource] filter result by dependency on source package
     * @param {boolean} [oneandhalf] use dependency depth 1.5
     * @param {boolean} [useLastTasks] use repo state including last done tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRoutePackageBuildDependencyPackageWhatDependsSrc(packages: Array<string>, branch: string, depth?: number, dptype?: GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum, archs?: Array<string>, leaf?: string, finitePackage?: boolean, filterByPackage?: Array<string>, filterBySource?: string, oneandhalf?: boolean, useLastTasks?: boolean, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRoutePackageBuildDependencyPackageWhatDependsSrc(packages, branch, depth, dptype, archs, leaf, finitePackage, filterByPackage, filterBySource, oneandhalf, useLastTasks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of packages required for build by given source packages list recursively
     * @param {string} branch name of packageset
     * @param {Array<string>} packages package or list of packages
     * @param {string} [arch] packages architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRoutePackageBuildDependencySetPackageBuildDependencySet(branch: string, packages: Array<string>, arch?: string, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRoutePackageBuildDependencySetPackageBuildDependencySet(branch, packages, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about binary packages from  last package sets by given file MD5 checksum and package set name
     * @param {string} branch name of packageset
     * @param {string} md5 file MD5 checksum
     * @param {string} [arch] packages architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRoutePackageByFileMd5PackagePackageByFileMd5(branch: string, md5: string, arch?: string, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRoutePackageByFileMd5PackagePackageByFileMd5(branch, md5, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about binary packages from  last package sets by given file name and package set name. File name wildcars \'*\' is allowed.
     * @param {string} file file name
     * @param {string} branch name of packageset
     * @param {string} [arch] packages architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRoutePackageByFileNamePackagePackageByFileName(file: string, branch: string, arch?: string, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRoutePackageByFileNamePackagePackageByFileName(file, branch, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for package by parameters from last packages
     * @param {string} [name] package name
     * @param {string} [version] package version
     * @param {string} [release] package release
     * @param {string} [arch] packages architecture
     * @param {boolean} [source] is source package
     * @param {string} [branch] name of packageset
     * @param {string} [disttag] package disttag
     * @param {string} [sha1] package SHA1 checksum
     * @param {string} [packager] package packager name
     * @param {string} [packagerEmail] package packager email
     * @param {boolean} [full] show full package information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRoutePackageInfoPackagePackageInfo(name?: string, version?: string, release?: string, arch?: string, source?: boolean, branch?: string, disttag?: string, sha1?: string, packager?: string, packagerEmail?: string, full?: boolean, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRoutePackageInfoPackagePackageInfo(name, version, release, arch, source, branch, disttag, sha1, packager, packagerEmail, full, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get packages with conflicting files in packages that don\'t have a conflict in dependencies
     * @param {Array<string>} packages package or list of packages
     * @param {string} branch name of packageset
     * @param {Array<string>} [archs] list of packages architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRoutePackageMisconflictPackagesPackageMisconflict(packages: Array<string>, branch: string, archs?: Array<string>, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRoutePackageMisconflictPackagesPackageMisconflict(packages, branch, archs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get repocop data by name, version and release
     * @param {string} branch name of packageset
     * @param {string} packageName source or binary package name
     * @param {string} [packageVersion] source or binary package version
     * @param {string} [packageRelease] source or binary package release
     * @param {string} [binPackageArch] binary package arch
     * @param {GetRoutePackageRepocopPackageTypeEnum} [packageType] packages type [source|binary]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRoutePackageRepocop(branch: string, packageName: string, packageVersion?: string, packageRelease?: string, binPackageArch?: string, packageType?: GetRoutePackageRepocopPackageTypeEnum, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRoutePackageRepocop(branch, packageName, packageVersion, packageRelease, binPackageArch, packageType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get spec file by source package hash
     * @param {number} pkghash package hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash(pkghash: number, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash(pkghash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get spec file by source package name and branch
     * @param {string} branch name of packageset
     * @param {string} name source package name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRouteSpecfileByPackageNamePackageSpecfileByName(branch: string, name: string, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRouteSpecfileByPackageNamePackageSpecfileByName(branch, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about unpackaged directories by maintainer nickname
     * @param {string} branch name of packageset
     * @param {string} packager maintainer nickname
     * @param {Array<string>} [archs] list of packages architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRouteUnpackagedDirsPackageUnpackagedDirs(branch: string, packager: string, archs?: Array<string>, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).getRouteUnpackagedDirsPackageUnpackagedDirs(branch, packager, archs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Load repocop data into database
     * @param {RepocopJsonPostListModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public postRoutePackageRepocop(payload: RepocopJsonPostListModel, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).postRoutePackageRepocop(payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about binary packages from  last package sets by given file names array and package set name. File name wildcars \'*\' is not allowed.
     * @param {PackagesByFileNamesJsonModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public postRoutePackagesByFileNamesPackagePackagesByFileNames(payload: PackagesByFileNamesJsonModel, options?: RawAxiosRequestConfig) {
        return PackageApiFp(this.configuration).postRoutePackagesByFileNamesPackagePackagesByFileNames(payload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum = {
    Both: 'both',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum = typeof GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum[keyof typeof GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum];
/**
 * @export
 */
export const GetRoutePackageRepocopPackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageRepocopPackageTypeEnum = typeof GetRoutePackageRepocopPackageTypeEnum[keyof typeof GetRoutePackageRepocopPackageTypeEnum];


/**
 * PackagesetApi - axios parameter creator
 * @export
 */
export const PackagesetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get list of active package sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteActivePackagesetsPackagesetActivePackagesets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/packageset/active_packagesets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get packages by packageset component and architecture.
         * @param {string} branch name of packageset
         * @param {string} arch architecture name
         * @param {string} component component name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesByComponentPackagesetPackagesByComponent: async (branch: string, arch: string, component: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackagesByComponentPackagesetPackagesByComponent', 'branch', branch)
            // verify required parameter 'arch' is not null or undefined
            assertParamExists('getRoutePackagesByComponentPackagesetPackagesByComponent', 'arch', arch)
            // verify required parameter 'component' is not null or undefined
            assertParamExists('getRoutePackagesByComponentPackagesetPackagesByComponent', 'component', component)
            const localVarPath = `/packageset/packages_by_component`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get packages by packageset component UUID
         * @param {string} uuid packageset component UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesByUuidPackagesetPackagesByUuid: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRoutePackagesByUuidPackagesetPackagesByUuid', 'uuid', uuid)
            const localVarPath = `/packageset/packages_by_uuid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get difference list of packages from two package sets
         * @param {string} pkgset1 first packageset name
         * @param {string} pkgset2 second packageset name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetComparePackagesetComparePackagesets: async (pkgset1: string, pkgset2: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkgset1' is not null or undefined
            assertParamExists('getRoutePackagesetComparePackagesetComparePackagesets', 'pkgset1', pkgset1)
            // verify required parameter 'pkgset2' is not null or undefined
            assertParamExists('getRoutePackagesetComparePackagesetComparePackagesets', 'pkgset2', pkgset2)
            const localVarPath = `/packageset/compare_packagesets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pkgset1 !== undefined) {
                localVarQueryParameter['pkgset1'] = pkgset1;
            }

            if (pkgset2 !== undefined) {
                localVarQueryParameter['pkgset2'] = pkgset2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of packageset packages. Architecture argument is actual only if type is \'binary\'.
         * @param {string} branch name of packageset
         * @param {GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPackagesPackagesetRepositoryPackages: async (branch: string, packageType?: GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum, archs?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackagesetPackagesPackagesetRepositoryPackages', 'branch', branch)
            const localVarPath = `/packageset/repository_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (packageType !== undefined) {
                localVarQueryParameter['package_type'] = packageType;
            }

            if (archs) {
                localVarQueryParameter['archs'] = archs.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get repository statistics
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteRepositoryStatisticsPackagesetRepositoryStatistics: async (branch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/packageset/repository_statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package set status into database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteRepositoryStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/packageset/pkgset_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Load package set status into database
         * @param {PackageSetStatusPostModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteRepositoryStatus: async (payload: PackageSetStatusPostModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRouteRepositoryStatus', 'payload', payload)
            const localVarPath = `/packageset/pkgset_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackagesetApi - functional programming interface
 * @export
 */
export const PackagesetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PackagesetApiAxiosParamCreator(configuration)
    return {
        /**
         * Get list of active package sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteActivePackagesetsPackagesetActivePackagesets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageSetActivePackageSetsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteActivePackagesetsPackagesetActivePackagesets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesetApi.getRouteActivePackagesetsPackagesetActivePackagesets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get packages by packageset component and architecture.
         * @param {string} branch name of packageset
         * @param {string} arch architecture name
         * @param {string} component component name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesByComponentPackagesetPackagesByComponent(branch: string, arch: string, component: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagesByUuidModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesByComponentPackagesetPackagesByComponent(branch, arch, component, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesetApi.getRoutePackagesByComponentPackagesetPackagesByComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get packages by packageset component UUID
         * @param {string} uuid packageset component UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesByUuidPackagesetPackagesByUuid(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagesByUuidModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesByUuidPackagesetPackagesByUuid(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesetApi.getRoutePackagesByUuidPackagesetPackagesByUuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get difference list of packages from two package sets
         * @param {string} pkgset1 first packageset name
         * @param {string} pkgset2 second packageset name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetComparePackagesetComparePackagesets(pkgset1: string, pkgset2: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagesetCompareModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetComparePackagesetComparePackagesets(pkgset1, pkgset2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesetApi.getRoutePackagesetComparePackagesetComparePackagesets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of packageset packages. Architecture argument is actual only if type is \'binary\'.
         * @param {string} branch name of packageset
         * @param {GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetPackagesPackagesetRepositoryPackages(branch: string, packageType?: GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum, archs?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagesetPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetPackagesPackagesetRepositoryPackages(branch, packageType, archs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesetApi.getRoutePackagesetPackagesPackagesetRepositoryPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get repository statistics
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteRepositoryStatisticsPackagesetRepositoryStatistics(branch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepositoryStatisticsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteRepositoryStatisticsPackagesetRepositoryStatistics(branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesetApi.getRouteRepositoryStatisticsPackagesetRepositoryStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package set status into database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteRepositoryStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageSetStatusGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteRepositoryStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesetApi.getRouteRepositoryStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Load package set status into database
         * @param {PackageSetStatusPostModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteRepositoryStatus(payload: PackageSetStatusPostModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteRepositoryStatus(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PackagesetApi.postRouteRepositoryStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PackagesetApi - factory interface
 * @export
 */
export const PackagesetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PackagesetApiFp(configuration)
    return {
        /**
         * Get list of active package sets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteActivePackagesetsPackagesetActivePackagesets(options?: any): AxiosPromise<PackageSetActivePackageSetsModel> {
            return localVarFp.getRouteActivePackagesetsPackagesetActivePackagesets(options).then((request) => request(axios, basePath));
        },
        /**
         * Get packages by packageset component and architecture.
         * @param {string} branch name of packageset
         * @param {string} arch architecture name
         * @param {string} component component name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesByComponentPackagesetPackagesByComponent(branch: string, arch: string, component: string, options?: any): AxiosPromise<PackagesByUuidModel> {
            return localVarFp.getRoutePackagesByComponentPackagesetPackagesByComponent(branch, arch, component, options).then((request) => request(axios, basePath));
        },
        /**
         * Get packages by packageset component UUID
         * @param {string} uuid packageset component UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesByUuidPackagesetPackagesByUuid(uuid: string, options?: any): AxiosPromise<PackagesByUuidModel> {
            return localVarFp.getRoutePackagesByUuidPackagesetPackagesByUuid(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get difference list of packages from two package sets
         * @param {string} pkgset1 first packageset name
         * @param {string} pkgset2 second packageset name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetComparePackagesetComparePackagesets(pkgset1: string, pkgset2: string, options?: any): AxiosPromise<PackagesetCompareModel> {
            return localVarFp.getRoutePackagesetComparePackagesetComparePackagesets(pkgset1, pkgset2, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of packageset packages. Architecture argument is actual only if type is \'binary\'.
         * @param {string} branch name of packageset
         * @param {GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPackagesPackagesetRepositoryPackages(branch: string, packageType?: GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum, archs?: Array<string>, options?: any): AxiosPromise<PackagesetPackagesModel> {
            return localVarFp.getRoutePackagesetPackagesPackagesetRepositoryPackages(branch, packageType, archs, options).then((request) => request(axios, basePath));
        },
        /**
         * Get repository statistics
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteRepositoryStatisticsPackagesetRepositoryStatistics(branch?: string, options?: any): AxiosPromise<RepositoryStatisticsModel> {
            return localVarFp.getRouteRepositoryStatisticsPackagesetRepositoryStatistics(branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get package set status into database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteRepositoryStatus(options?: any): AxiosPromise<PackageSetStatusGetModel> {
            return localVarFp.getRouteRepositoryStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Load package set status into database
         * @param {PackageSetStatusPostModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteRepositoryStatus(payload: PackageSetStatusPostModel, options?: any): AxiosPromise<void> {
            return localVarFp.postRouteRepositoryStatus(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PackagesetApi - object-oriented interface
 * @export
 * @class PackagesetApi
 * @extends {BaseAPI}
 */
export class PackagesetApi extends BaseAPI {
    /**
     * Get list of active package sets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesetApi
     */
    public getRouteActivePackagesetsPackagesetActivePackagesets(options?: RawAxiosRequestConfig) {
        return PackagesetApiFp(this.configuration).getRouteActivePackagesetsPackagesetActivePackagesets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get packages by packageset component and architecture.
     * @param {string} branch name of packageset
     * @param {string} arch architecture name
     * @param {string} component component name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesetApi
     */
    public getRoutePackagesByComponentPackagesetPackagesByComponent(branch: string, arch: string, component: string, options?: RawAxiosRequestConfig) {
        return PackagesetApiFp(this.configuration).getRoutePackagesByComponentPackagesetPackagesByComponent(branch, arch, component, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get packages by packageset component UUID
     * @param {string} uuid packageset component UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesetApi
     */
    public getRoutePackagesByUuidPackagesetPackagesByUuid(uuid: string, options?: RawAxiosRequestConfig) {
        return PackagesetApiFp(this.configuration).getRoutePackagesByUuidPackagesetPackagesByUuid(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get difference list of packages from two package sets
     * @param {string} pkgset1 first packageset name
     * @param {string} pkgset2 second packageset name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesetApi
     */
    public getRoutePackagesetComparePackagesetComparePackagesets(pkgset1: string, pkgset2: string, options?: RawAxiosRequestConfig) {
        return PackagesetApiFp(this.configuration).getRoutePackagesetComparePackagesetComparePackagesets(pkgset1, pkgset2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of packageset packages. Architecture argument is actual only if type is \'binary\'.
     * @param {string} branch name of packageset
     * @param {GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum} [packageType] packages type [source|binary|all]
     * @param {Array<string>} [archs] list of packages architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesetApi
     */
    public getRoutePackagesetPackagesPackagesetRepositoryPackages(branch: string, packageType?: GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum, archs?: Array<string>, options?: RawAxiosRequestConfig) {
        return PackagesetApiFp(this.configuration).getRoutePackagesetPackagesPackagesetRepositoryPackages(branch, packageType, archs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get repository statistics
     * @param {string} [branch] name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesetApi
     */
    public getRouteRepositoryStatisticsPackagesetRepositoryStatistics(branch?: string, options?: RawAxiosRequestConfig) {
        return PackagesetApiFp(this.configuration).getRouteRepositoryStatisticsPackagesetRepositoryStatistics(branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package set status into database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesetApi
     */
    public getRouteRepositoryStatus(options?: RawAxiosRequestConfig) {
        return PackagesetApiFp(this.configuration).getRouteRepositoryStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Load package set status into database
     * @param {PackageSetStatusPostModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackagesetApi
     */
    public postRouteRepositoryStatus(payload: PackageSetStatusPostModel, options?: RawAxiosRequestConfig) {
        return PackagesetApiFp(this.configuration).postRouteRepositoryStatus(payload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum = {
    All: 'all',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum = typeof GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum[keyof typeof GetRoutePackagesetPackagesPackagesetRepositoryPackagesPackageTypeEnum];


/**
 * SiteApi - axios parameter creator
 * @export
 */
export const SiteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get binary package archs list
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetArchsSiteAllPkgsetArchs: async (branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteAllPackagesetArchsSiteAllPkgsetArchs', 'branch', branch)
            const localVarPath = `/site/all_pkgset_archs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary package archs list with source packages count
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount: async (branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount', 'branch', branch)
            const localVarPath = `/site/all_pkgset_archs_with_src_count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package sets list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetsSiteAllPkgsets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/site/all_pkgsets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package sets list with source packages count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/site/all_pkgsets_with_src_count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package sets list with source packages count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetsSummarySiteAllPkgsetsSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/site/all_pkgsets_summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Beehive rebuild errors by the maintainer\'s nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer: async (branch: string, maintainerNickname: string, byAcl?: GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer', 'branch', branch)
            // verify required parameter 'maintainerNickname' is not null or undefined
            assertParamExists('getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer', 'maintainerNickname', maintainerNickname)
            const localVarPath = `/site/beehive_errors_by_maintainer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (maintainerNickname !== undefined) {
                localVarQueryParameter['maintainer_nickname'] = maintainerNickname;
            }

            if (byAcl !== undefined) {
                localVarQueryParameter['by_acl'] = byAcl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary package scripts
         * @param {number} pkghash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash: async (pkghash: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/site/binary_package_scripts/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary package download link
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {string} arch arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash: async (pkghash: number, branch: string, arch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash', 'pkghash', pkghash)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash', 'branch', branch)
            // verify required parameter 'arch' is not null or undefined
            assertParamExists('getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash', 'arch', arch)
            const localVarPath = `/site/package_downloads_bin/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary package build log link
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBinaryPackageLogSitePackageLogBinIntPkghash: async (pkghash: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRouteBinaryPackageLogSitePackageLogBinIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/site/package_log_bin/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get brief package info by hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash: async (pkghash: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/site/package_info_brief/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about package deleted from branch
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {string} [arch] arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteDeletedPackageInfoSiteDeletedPackageInfo: async (branch: string, name: string, packageType?: GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum, arch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteDeletedPackageInfoSiteDeletedPackageInfo', 'branch', branch)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRouteDeletedPackageInfoSiteDeletedPackageInfo', 'name', name)
            const localVarPath = `/site/deleted_package_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (packageType !== undefined) {
                localVarQueryParameter['package_type'] = packageType;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find source package in branch by binary package name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindSourcePackageSiteFindSourcePackage: async (branch: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteFindSourcePackageSiteFindSourcePackage', 'branch', branch)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRouteFindSourcePackageSiteFindSourcePackage', 'name', name)
            const localVarPath = `/site/find_source_package`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of last packages from branch for given parameters
         * @param {string} branch name of packageset
         * @param {number} packagesLimit number of last packages to get
         * @param {string} [packager] package packager\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastBranchPackagesSiteLastPackagesByBranch: async (branch: string, packagesLimit: number, packager?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteLastBranchPackagesSiteLastPackagesByBranch', 'branch', branch)
            // verify required parameter 'packagesLimit' is not null or undefined
            assertParamExists('getRouteLastBranchPackagesSiteLastPackagesByBranch', 'packagesLimit', packagesLimit)
            const localVarPath = `/site/last_packages_by_branch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (packagesLimit !== undefined) {
                localVarQueryParameter['packages_limit'] = packagesLimit;
            }

            if (packager !== undefined) {
                localVarQueryParameter['packager'] = packager;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about last packages with CVE fixes mentioned in changelog
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed: async (branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed', 'branch', branch)
            const localVarPath = `/site/last_packages_with_cve_fixed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of last packages from tasks for given parameters
         * @param {string} branch name of packageset
         * @param {number} tasksLimit number of last tasks to get
         * @param {string} [taskOwner] task owner\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastTaskPackagesSiteLastPackages: async (branch: string, tasksLimit: number, taskOwner?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteLastTaskPackagesSiteLastPackages', 'branch', branch)
            // verify required parameter 'tasksLimit' is not null or undefined
            assertParamExists('getRouteLastTaskPackagesSiteLastPackages', 'tasksLimit', tasksLimit)
            const localVarPath = `/site/last_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (tasksLimit !== undefined) {
                localVarQueryParameter['tasks_limit'] = tasksLimit;
            }

            if (taskOwner !== undefined) {
                localVarQueryParameter['task_owner'] = taskOwner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of last packages from tasks for given parameters
         * @param {string} branch name of packageset
         * @param {number} tasksLimit number of last tasks to get
         * @param {string} [taskOwner] task owner\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastTaskPackagesSiteLastPackagesByTasks: async (branch: string, tasksLimit: number, taskOwner?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteLastTaskPackagesSiteLastPackagesByTasks', 'branch', branch)
            // verify required parameter 'tasksLimit' is not null or undefined
            assertParamExists('getRouteLastTaskPackagesSiteLastPackagesByTasks', 'tasksLimit', tasksLimit)
            const localVarPath = `/site/last_packages_by_tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (tasksLimit !== undefined) {
                localVarQueryParameter['tasks_limit'] = tasksLimit;
            }

            if (taskOwner !== undefined) {
                localVarQueryParameter['task_owner'] = taskOwner;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Packages collected by the specified maintainer
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainerBranchesSiteMaintainerBranches: async (maintainerNickname: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'maintainerNickname' is not null or undefined
            assertParamExists('getRouteMaintainerBranchesSiteMaintainerBranches', 'maintainerNickname', maintainerNickname)
            const localVarPath = `/site/maintainer_branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maintainerNickname !== undefined) {
                localVarQueryParameter['maintainer_nickname'] = maintainerNickname;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Packages collected by the specified maintainer
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainerPackagesSiteMaintainerPackages: async (branch: string, maintainerNickname: string, byAcl?: GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteMaintainerPackagesSiteMaintainerPackages', 'branch', branch)
            // verify required parameter 'maintainerNickname' is not null or undefined
            assertParamExists('getRouteMaintainerPackagesSiteMaintainerPackages', 'maintainerNickname', maintainerNickname)
            const localVarPath = `/site/maintainer_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (maintainerNickname !== undefined) {
                localVarQueryParameter['maintainer_nickname'] = maintainerNickname;
            }

            if (byAcl !== undefined) {
                localVarQueryParameter['by_acl'] = byAcl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of maintainers in branch with nicknames and source packages count
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainersAll: async (branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteMaintainersAll', 'branch', branch)
            const localVarPath = `/site/all_maintainers_with_nicknames`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * alias for /all_maintainers_with_nicknames
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainersAllSiteAllMaintainers: async (branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteMaintainersAllSiteAllMaintainers', 'branch', branch)
            const localVarPath = `/site/all_maintainers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Maintainer information
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainersInfoSiteMaintainerInfo: async (branch: string, maintainerNickname: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteMaintainersInfoSiteMaintainerInfo', 'branch', branch)
            // verify required parameter 'maintainerNickname' is not null or undefined
            assertParamExists('getRouteMaintainersInfoSiteMaintainerInfo', 'maintainerNickname', maintainerNickname)
            const localVarPath = `/site/maintainer_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (maintainerNickname !== undefined) {
                localVarQueryParameter['maintainer_nickname'] = maintainerNickname;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package changelog history by hash
         * @param {number} pkghash package hash
         * @param {number} [changelogLast] changelog history length
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageChangelogSitePackageChangelogIntPkghash: async (pkghash: number, changelogLast?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRoutePackageChangelogSitePackageChangelogIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/site/package_changelog/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (changelogLast !== undefined) {
                localVarQueryParameter['changelog_last'] = changelogLast;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package download links by source package hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash: async (pkghash: number, branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash', 'pkghash', pkghash)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash', 'branch', branch)
            const localVarPath = `/site/package_downloads/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package download links by source package hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash: async (pkghash: number, branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash', 'pkghash', pkghash)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash', 'branch', branch)
            const localVarPath = `/site/package_downloads_src/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package info by hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {number} [changelogLast] changelog history length
         * @param {GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageInfoSitePackageInfoIntPkghash: async (pkghash: number, branch: string, changelogLast?: number, packageType?: GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRoutePackageInfoSitePackageInfoIntPkghash', 'pkghash', pkghash)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageInfoSitePackageInfoIntPkghash', 'branch', branch)
            const localVarPath = `/site/package_info/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (changelogLast !== undefined) {
                localVarQueryParameter['changelog_last'] = changelogLast;
            }

            if (packageType !== undefined) {
                localVarQueryParameter['package_type'] = packageType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary packages file conflicts by source package.
         * @param {number} pkghash source package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageMisconflictSitePackageMisconflictIntPkghash: async (pkghash: number, branch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRoutePackageMisconflictSitePackageMisconflictIntPkghash', 'pkghash', pkghash)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageMisconflictSitePackageMisconflictIntPkghash', 'branch', branch)
            const localVarPath = `/site/package_misconflict/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source package name from repology.
         * @param {string} branch name of packageset
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageNameFromRepologySitePackageNameFromRepology: async (branch: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageNameFromRepologySitePackageNameFromRepology', 'branch', branch)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackageNameFromRepologySitePackageNameFromRepology', 'name', name)
            const localVarPath = `/site/package_name_from_repology`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package name, version, release and type by hash. Check package name matching if provided.
         * @param {number} pkghash package hash
         * @param {string} [name] package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash: async (pkghash: number, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/site/package_nvr_by_hash/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary packages versions from images
         * @param {string} name package name
         * @param {string} branch image base branch
         * @param {string} edition image edition
         * @param {string} type image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageVersionsFromImagesSitePackageVersionsFromImages: async (name: string, branch: string, edition: string, type: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackageVersionsFromImagesSitePackageVersionsFromImages', 'name', name)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackageVersionsFromImagesSitePackageVersionsFromImages', 'branch', branch)
            // verify required parameter 'edition' is not null or undefined
            assertParamExists('getRoutePackageVersionsFromImagesSitePackageVersionsFromImages', 'edition', edition)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getRoutePackageVersionsFromImagesSitePackageVersionsFromImages', 'type', type)
            const localVarPath = `/site/package_versions_from_images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (edition !== undefined) {
                localVarQueryParameter['edition'] = edition;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source package versions from tasks
         * @param {string} name package name
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks: async (name: string, branch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks', 'name', name)
            const localVarPath = `/site/package_versions_from_tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source or binary package versions from last branches
         * @param {string} name source package name
         * @param {GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {string} [arch] arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageVersionsSitePackageVersions: async (name: string, packageType?: GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum, arch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackageVersionsSitePackageVersions', 'name', name)
            const localVarPath = `/site/package_versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (packageType !== undefined) {
                localVarQueryParameter['package_type'] = packageType;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary package archs and versions
         * @param {string} branch name of packageset
         * @param {string} name binary package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions: async (branch: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions', 'branch', branch)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions', 'name', name)
            const localVarPath = `/site/binary_package_archs_and_versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fast packages search by name
         * @param {Array<string>} name package or list of package names
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup: async (name: Array<string>, branch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup', 'name', name)
            const localVarPath = `/site/fast_packages_search_lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name) {
                localVarQueryParameter['name'] = name.join(COLLECTION_FORMATS.csv);
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find packages by name
         * @param {Array<string>} name package or list of package names
         * @param {string} [branch] name of packageset
         * @param {string} [arch] binary package arch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetFindPackagesSiteFindPackages: async (name: Array<string>, branch?: string, arch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackagesetFindPackagesSiteFindPackages', 'name', name)
            const localVarPath = `/site/find_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name) {
                localVarQueryParameter['name'] = name.join(COLLECTION_FORMATS.csv);
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get binary package hash by package name, arch and package set name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {string} arch package arch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName: async (branch: string, name: string, arch: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName', 'branch', branch)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName', 'name', name)
            // verify required parameter 'arch' is not null or undefined
            assertParamExists('getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName', 'arch', arch)
            const localVarPath = `/site/pkghash_by_binary_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source package hash by package name and package set name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPackageHashSitePkghashByName: async (branch: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackagesetPackageHashSitePkghashByName', 'branch', branch)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackagesetPackageHashSitePkghashByName', 'name', name)
            const localVarPath = `/site/pkghash_by_name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of packageset packages in accordance to given parameters
         * @param {string} branch name of packageset
         * @param {GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {string} [group] package category
         * @param {number} [buildtime] package buildtime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPackagesSiteRepositoryPackages: async (branch: string, packageType?: GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum, group?: string, buildtime?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackagesetPackagesSiteRepositoryPackages', 'branch', branch)
            const localVarPath = `/site/repository_packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (packageType !== undefined) {
                localVarQueryParameter['package_type'] = packageType;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (buildtime !== undefined) {
                localVarQueryParameter['buildtime'] = buildtime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source package hash by package name, version and release for specific branch
         * @param {string} name package name
         * @param {string} branch name of packageset
         * @param {string} version source package version
         * @param {string} release source package release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPkghashByNvrSitePkghashByNvr: async (name: string, branch: string, version: string, release: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRoutePackagesetPkghashByNvrSitePkghashByNvr', 'name', name)
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePackagesetPkghashByNvrSitePkghashByNvr', 'branch', branch)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getRoutePackagesetPkghashByNvrSitePkghashByNvr', 'version', version)
            // verify required parameter 'release' is not null or undefined
            assertParamExists('getRoutePackagesetPkghashByNvrSitePkghashByNvr', 'release', release)
            const localVarPath = `/site/pkghash_by_nvr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (release !== undefined) {
                localVarQueryParameter['release'] = release;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package sets list with source packages count and status info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/site/pkgsets_summary_status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get package set list by package hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash: async (pkghash: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pkghash' is not null or undefined
            assertParamExists('getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash', 'pkghash', pkghash)
            const localVarPath = `/site/packagesets_by_hash/{pkghash}`
                .replace(`{${"pkghash"}}`, encodeURIComponent(String(pkghash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of package categories with count for given package set
         * @param {string} branch name of packageset
         * @param {GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount: async (branch: string, packageType?: GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount', 'branch', branch)
            const localVarPath = `/site/pkgset_categories_count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (packageType !== undefined) {
                localVarQueryParameter['package_type'] = packageType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get repocop results by the maintainers nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteRepocopByMaintainerSiteRepocopByMaintainer: async (branch: string, maintainerNickname: string, byAcl?: GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteRepocopByMaintainerSiteRepocopByMaintainer', 'branch', branch)
            // verify required parameter 'maintainerNickname' is not null or undefined
            assertParamExists('getRouteRepocopByMaintainerSiteRepocopByMaintainer', 'maintainerNickname', maintainerNickname)
            const localVarPath = `/site/repocop_by_maintainer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (maintainerNickname !== undefined) {
                localVarQueryParameter['maintainer_nickname'] = maintainerNickname;
            }

            if (byAcl !== undefined) {
                localVarQueryParameter['by_acl'] = byAcl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get source package versions from last branches
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSourcePackageVersionsSiteSourcePackageVersions: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRouteSourcePackageVersionsSiteSourcePackageVersions', 'name', name)
            const localVarPath = `/site/source_package_versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tasks list by maintainer nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRouteTasksByMaintainerSiteTasksByMaintainer: async (branch: string, maintainerNickname: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteTasksByMaintainerSiteTasksByMaintainer', 'branch', branch)
            // verify required parameter 'maintainerNickname' is not null or undefined
            assertParamExists('getRouteTasksByMaintainerSiteTasksByMaintainer', 'maintainerNickname', maintainerNickname)
            const localVarPath = `/site/tasks_by_maintainer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (maintainerNickname !== undefined) {
                localVarQueryParameter['maintainer_nickname'] = maintainerNickname;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tasks list by source package name
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRouteTasksByPackageSiteTasksByPackage: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getRouteTasksByPackageSiteTasksByPackage', 'name', name)
            const localVarPath = `/site/tasks_by_package`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get history of done tasks for an active branches
         * @param {number} [taskId] Number of task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTasksHistorySiteTasksHistory: async (taskId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/site/tasks_history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get watch packages by the maintainer\'s nickname
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteWatchByMaintainerSiteWatchByMaintainer: async (maintainerNickname: string, byAcl?: GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'maintainerNickname' is not null or undefined
            assertParamExists('getRouteWatchByMaintainerSiteWatchByMaintainer', 'maintainerNickname', maintainerNickname)
            const localVarPath = `/site/watch_by_maintainer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maintainerNickname !== undefined) {
                localVarQueryParameter['maintainer_nickname'] = maintainerNickname;
            }

            if (byAcl !== undefined) {
                localVarQueryParameter['by_acl'] = byAcl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteApi - functional programming interface
 * @export
 */
export const SiteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SiteApiAxiosParamCreator(configuration)
    return {
        /**
         * Get binary package archs list
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAllPackagesetArchsSiteAllPkgsetArchs(branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteAllArchsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAllPackagesetArchsSiteAllPkgsetArchs(branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteAllPackagesetArchsSiteAllPkgsetArchs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary package archs list with source packages count
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount(branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteAllArchsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount(branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package sets list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAllPackagesetsSiteAllPkgsets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteAllPackagasetsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAllPackagesetsSiteAllPkgsets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteAllPackagesetsSiteAllPkgsets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package sets list with source packages count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteAllPackagasetsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package sets list with source packages count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAllPackagesetsSummarySiteAllPkgsetsSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteAllPackagesetsSummaryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAllPackagesetsSummarySiteAllPkgsetsSummary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteAllPackagesetsSummarySiteAllPkgsetsSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Beehive rebuild errors by the maintainer\'s nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer(branch: string, maintainerNickname: string, byAcl?: GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiteBeehiveByMaintainerModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer(branch, maintainerNickname, byAcl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary package scripts
         * @param {number} pkghash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash(pkghash: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteBinPackageScriptsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash(pkghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary package download link
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {string} arch arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash(pkghash: number, branch: string, arch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesDownloadsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash(pkghash, branch, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary package build log link
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBinaryPackageLogSitePackageLogBinIntPkghash(pkghash: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BinPackageLogElementModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBinaryPackageLogSitePackageLogBinIntPkghash(pkghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteBinaryPackageLogSitePackageLogBinIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get brief package info by hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash(pkghash: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteBriefPackageInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash(pkghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about package deleted from branch
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {string} [arch] arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteDeletedPackageInfoSiteDeletedPackageInfo(branch: string, name: string, packageType?: GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum, arch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteDeletedPackageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteDeletedPackageInfoSiteDeletedPackageInfo(branch, name, packageType, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteDeletedPackageInfoSiteDeletedPackageInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find source package in branch by binary package name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFindSourcePackageSiteFindSourcePackage(branch: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindSourcePackageInBranch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFindSourcePackageSiteFindSourcePackage(branch, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteFindSourcePackageSiteFindSourcePackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of last packages from branch for given parameters
         * @param {string} branch name of packageset
         * @param {number} packagesLimit number of last packages to get
         * @param {string} [packager] package packager\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLastBranchPackagesSiteLastPackagesByBranch(branch: string, packagesLimit: number, packager?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteLastBranchPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLastBranchPackagesSiteLastPackagesByBranch(branch, packagesLimit, packager, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteLastBranchPackagesSiteLastPackagesByBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about last packages with CVE fixes mentioned in changelog
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed(branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteLastPackagesWithCVEFixesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed(branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of last packages from tasks for given parameters
         * @param {string} branch name of packageset
         * @param {number} tasksLimit number of last tasks to get
         * @param {string} [taskOwner] task owner\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLastTaskPackagesSiteLastPackages(branch: string, tasksLimit: number, taskOwner?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteLastPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLastTaskPackagesSiteLastPackages(branch, tasksLimit, taskOwner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteLastTaskPackagesSiteLastPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of last packages from tasks for given parameters
         * @param {string} branch name of packageset
         * @param {number} tasksLimit number of last tasks to get
         * @param {string} [taskOwner] task owner\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLastTaskPackagesSiteLastPackagesByTasks(branch: string, tasksLimit: number, taskOwner?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteLastPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLastTaskPackagesSiteLastPackagesByTasks(branch, tasksLimit, taskOwner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteLastTaskPackagesSiteLastPackagesByTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Packages collected by the specified maintainer
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteMaintainerBranchesSiteMaintainerBranches(maintainerNickname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintainerBranchesModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteMaintainerBranchesSiteMaintainerBranches(maintainerNickname, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteMaintainerBranchesSiteMaintainerBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Packages collected by the specified maintainer
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteMaintainerPackagesSiteMaintainerPackages(branch: string, maintainerNickname: string, byAcl?: GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintainerPackagesModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteMaintainerPackagesSiteMaintainerPackages(branch, maintainerNickname, byAcl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteMaintainerPackagesSiteMaintainerPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List of maintainers in branch with nicknames and source packages count
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteMaintainersAll(branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllMaintainersModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteMaintainersAll(branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteMaintainersAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * alias for /all_maintainers_with_nicknames
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteMaintainersAllSiteAllMaintainers(branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AllMaintainersModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteMaintainersAllSiteAllMaintainers(branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteMaintainersAllSiteAllMaintainers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Maintainer information
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteMaintainersInfoSiteMaintainerInfo(branch: string, maintainerNickname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MaintainerInfoModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteMaintainersInfoSiteMaintainerInfo(branch, maintainerNickname, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteMaintainersInfoSiteMaintainerInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package changelog history by hash
         * @param {number} pkghash package hash
         * @param {number} [changelogLast] changelog history length
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageChangelogSitePackageChangelogIntPkghash(pkghash: number, changelogLast?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteChangelogModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageChangelogSitePackageChangelogIntPkghash(pkghash, changelogLast, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageChangelogSitePackageChangelogIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package download links by source package hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash(pkghash: number, branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesDownloadsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash(pkghash, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package download links by source package hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash(pkghash: number, branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesDownloadsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash(pkghash, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package info by hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {number} [changelogLast] changelog history length
         * @param {GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageInfoSitePackageInfoIntPkghash(pkghash: number, branch: string, changelogLast?: number, packageType?: GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackageInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageInfoSitePackageInfoIntPkghash(pkghash, branch, changelogLast, packageType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageInfoSitePackageInfoIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary packages file conflicts by source package.
         * @param {number} pkghash source package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageMisconflictSitePackageMisconflictIntPkghash(pkghash: number, branch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageMisconflictBySrcModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageMisconflictSitePackageMisconflictIntPkghash(pkghash, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageMisconflictSitePackageMisconflictIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source package name from repology.
         * @param {string} branch name of packageset
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageNameFromRepologySitePackageNameFromRepology(branch: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageNameFromRepologyModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageNameFromRepologySitePackageNameFromRepology(branch, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageNameFromRepologySitePackageNameFromRepology']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package name, version, release and type by hash. Check package name matching if provided.
         * @param {number} pkghash package hash
         * @param {string} [name] package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash(pkghash: number, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageNVRByHashModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash(pkghash, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary packages versions from images
         * @param {string} name package name
         * @param {string} branch image base branch
         * @param {string} edition image edition
         * @param {string} type image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageVersionsFromImagesSitePackageVersionsFromImages(name: string, branch: string, edition: string, type: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteImagePackageVersionsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageVersionsFromImagesSitePackageVersionsFromImages(name, branch, edition, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageVersionsFromImagesSitePackageVersionsFromImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source package versions from tasks
         * @param {string} name package name
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks(name: string, branch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SItePackagesVersionsFromTasksModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks(name, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source or binary package versions from last branches
         * @param {string} name source package name
         * @param {GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {string} [arch] arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackageVersionsSitePackageVersions(name: string, packageType?: GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum, arch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteSourcePackagesVersionsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackageVersionsSitePackageVersions(name, packageType, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackageVersionsSitePackageVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary package archs and versions
         * @param {string} branch name of packageset
         * @param {string} name binary package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions(branch: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesBinaryListModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions(branch, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fast packages search by name
         * @param {Array<string>} name package or list of package names
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup(name: Array<string>, branch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteFastPackagesSearchModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup(name, branch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find packages by name
         * @param {Array<string>} name package or list of package names
         * @param {string} [branch] name of packageset
         * @param {string} [arch] binary package arch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetFindPackagesSiteFindPackages(name: Array<string>, branch?: string, arch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteFingPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetFindPackagesSiteFindPackages(name, branch, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagesetFindPackagesSiteFindPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get binary package hash by package name, arch and package set name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {string} arch package arch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName(branch: string, name: string, arch: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesetPackageHashModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName(branch, name, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source package hash by package name and package set name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetPackageHashSitePkghashByName(branch: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesetPackageHashModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetPackageHashSitePkghashByName(branch, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagesetPackageHashSitePkghashByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of packageset packages in accordance to given parameters
         * @param {string} branch name of packageset
         * @param {GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {string} [group] package category
         * @param {number} [buildtime] package buildtime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetPackagesSiteRepositoryPackages(branch: string, packageType?: GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum, group?: string, buildtime?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetPackagesSiteRepositoryPackages(branch, packageType, group, buildtime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagesetPackagesSiteRepositoryPackages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source package hash by package name, version and release for specific branch
         * @param {string} name package name
         * @param {string} branch name of packageset
         * @param {string} version source package version
         * @param {string} release source package release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetPkghashByNvrSitePkghashByNvr(name: string, branch: string, version: string, release: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesetPackageHashByNameVersionRelease>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetPkghashByNvrSitePkghashByNvr(name, branch, version, release, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagesetPkghashByNvrSitePkghashByNvr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package sets list with source packages count and status info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesetsSummaryStatusModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get package set list by package hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash(pkghash: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesetsByHashModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash(pkghash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of package categories with count for given package set
         * @param {string} branch name of packageset
         * @param {GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount(branch: string, packageType?: GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SitePackagesetCategoriesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount(branch, packageType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get repocop results by the maintainers nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteRepocopByMaintainerSiteRepocopByMaintainer(branch: string, maintainerNickname: string, byAcl?: GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepocopByMaintainerModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteRepocopByMaintainerSiteRepocopByMaintainer(branch, maintainerNickname, byAcl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteRepocopByMaintainerSiteRepocopByMaintainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get source package versions from last branches
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteSourcePackageVersionsSiteSourcePackageVersions(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteSourcePackagesVersionsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteSourcePackageVersionsSiteSourcePackageVersions(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteSourcePackageVersionsSiteSourcePackageVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tasks list by maintainer nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRouteTasksByMaintainerSiteTasksByMaintainer(branch: string, maintainerNickname: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiteTaskByNameModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTasksByMaintainerSiteTasksByMaintainer(branch, maintainerNickname, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteTasksByMaintainerSiteTasksByMaintainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tasks list by source package name
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRouteTasksByPackageSiteTasksByPackage(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteTaskByNameModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTasksByPackageSiteTasksByPackage(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteTasksByPackageSiteTasksByPackage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get history of done tasks for an active branches
         * @param {number} [taskId] Number of task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTasksHistorySiteTasksHistory(taskId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteTasksHistoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTasksHistorySiteTasksHistory(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteTasksHistorySiteTasksHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get watch packages by the maintainer\'s nickname
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteWatchByMaintainerSiteWatchByMaintainer(maintainerNickname: string, byAcl?: GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiteWatchByMaintainerModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteWatchByMaintainerSiteWatchByMaintainer(maintainerNickname, byAcl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SiteApi.getRouteWatchByMaintainerSiteWatchByMaintainer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SiteApi - factory interface
 * @export
 */
export const SiteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SiteApiFp(configuration)
    return {
        /**
         * Get binary package archs list
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetArchsSiteAllPkgsetArchs(branch: string, options?: any): AxiosPromise<SiteAllArchsModel> {
            return localVarFp.getRouteAllPackagesetArchsSiteAllPkgsetArchs(branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary package archs list with source packages count
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount(branch: string, options?: any): AxiosPromise<SiteAllArchsModel> {
            return localVarFp.getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount(branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get package sets list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetsSiteAllPkgsets(options?: any): AxiosPromise<SiteAllPackagasetsModel> {
            return localVarFp.getRouteAllPackagesetsSiteAllPkgsets(options).then((request) => request(axios, basePath));
        },
        /**
         * Get package sets list with source packages count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount(options?: any): AxiosPromise<SiteAllPackagasetsModel> {
            return localVarFp.getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount(options).then((request) => request(axios, basePath));
        },
        /**
         * Get package sets list with source packages count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllPackagesetsSummarySiteAllPkgsetsSummary(options?: any): AxiosPromise<SiteAllPackagesetsSummaryModel> {
            return localVarFp.getRouteAllPackagesetsSummarySiteAllPkgsetsSummary(options).then((request) => request(axios, basePath));
        },
        /**
         * Get Beehive rebuild errors by the maintainer\'s nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer(branch: string, maintainerNickname: string, byAcl?: GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum, options?: any): AxiosPromise<Array<SiteBeehiveByMaintainerModel>> {
            return localVarFp.getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer(branch, maintainerNickname, byAcl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary package scripts
         * @param {number} pkghash 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash(pkghash: number, options?: any): AxiosPromise<SiteBinPackageScriptsModel> {
            return localVarFp.getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash(pkghash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary package download link
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {string} arch arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash(pkghash: number, branch: string, arch: string, options?: any): AxiosPromise<SitePackagesDownloadsModel> {
            return localVarFp.getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash(pkghash, branch, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary package build log link
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBinaryPackageLogSitePackageLogBinIntPkghash(pkghash: number, options?: any): AxiosPromise<BinPackageLogElementModel> {
            return localVarFp.getRouteBinaryPackageLogSitePackageLogBinIntPkghash(pkghash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get brief package info by hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash(pkghash: number, options?: any): AxiosPromise<SiteBriefPackageInfoModel> {
            return localVarFp.getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash(pkghash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about package deleted from branch
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {string} [arch] arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteDeletedPackageInfoSiteDeletedPackageInfo(branch: string, name: string, packageType?: GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum, arch?: string, options?: any): AxiosPromise<SiteDeletedPackageModel> {
            return localVarFp.getRouteDeletedPackageInfoSiteDeletedPackageInfo(branch, name, packageType, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Find source package in branch by binary package name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindSourcePackageSiteFindSourcePackage(branch: string, name: string, options?: any): AxiosPromise<FindSourcePackageInBranch> {
            return localVarFp.getRouteFindSourcePackageSiteFindSourcePackage(branch, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of last packages from branch for given parameters
         * @param {string} branch name of packageset
         * @param {number} packagesLimit number of last packages to get
         * @param {string} [packager] package packager\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastBranchPackagesSiteLastPackagesByBranch(branch: string, packagesLimit: number, packager?: string, options?: any): AxiosPromise<SiteLastBranchPackagesModel> {
            return localVarFp.getRouteLastBranchPackagesSiteLastPackagesByBranch(branch, packagesLimit, packager, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about last packages with CVE fixes mentioned in changelog
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed(branch: string, options?: any): AxiosPromise<SiteLastPackagesWithCVEFixesModel> {
            return localVarFp.getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed(branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of last packages from tasks for given parameters
         * @param {string} branch name of packageset
         * @param {number} tasksLimit number of last tasks to get
         * @param {string} [taskOwner] task owner\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastTaskPackagesSiteLastPackages(branch: string, tasksLimit: number, taskOwner?: string, options?: any): AxiosPromise<SiteLastPackagesModel> {
            return localVarFp.getRouteLastTaskPackagesSiteLastPackages(branch, tasksLimit, taskOwner, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of last packages from tasks for given parameters
         * @param {string} branch name of packageset
         * @param {number} tasksLimit number of last tasks to get
         * @param {string} [taskOwner] task owner\&#39;s nickname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastTaskPackagesSiteLastPackagesByTasks(branch: string, tasksLimit: number, taskOwner?: string, options?: any): AxiosPromise<SiteLastPackagesModel> {
            return localVarFp.getRouteLastTaskPackagesSiteLastPackagesByTasks(branch, tasksLimit, taskOwner, options).then((request) => request(axios, basePath));
        },
        /**
         * Packages collected by the specified maintainer
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainerBranchesSiteMaintainerBranches(maintainerNickname: string, options?: any): AxiosPromise<Array<MaintainerBranchesModel>> {
            return localVarFp.getRouteMaintainerBranchesSiteMaintainerBranches(maintainerNickname, options).then((request) => request(axios, basePath));
        },
        /**
         * Packages collected by the specified maintainer
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainerPackagesSiteMaintainerPackages(branch: string, maintainerNickname: string, byAcl?: GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum, options?: any): AxiosPromise<Array<MaintainerPackagesModel>> {
            return localVarFp.getRouteMaintainerPackagesSiteMaintainerPackages(branch, maintainerNickname, byAcl, options).then((request) => request(axios, basePath));
        },
        /**
         * List of maintainers in branch with nicknames and source packages count
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainersAll(branch: string, options?: any): AxiosPromise<Array<AllMaintainersModel>> {
            return localVarFp.getRouteMaintainersAll(branch, options).then((request) => request(axios, basePath));
        },
        /**
         * alias for /all_maintainers_with_nicknames
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainersAllSiteAllMaintainers(branch: string, options?: any): AxiosPromise<Array<AllMaintainersModel>> {
            return localVarFp.getRouteMaintainersAllSiteAllMaintainers(branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Maintainer information
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteMaintainersInfoSiteMaintainerInfo(branch: string, maintainerNickname: string, options?: any): AxiosPromise<Array<MaintainerInfoModel>> {
            return localVarFp.getRouteMaintainersInfoSiteMaintainerInfo(branch, maintainerNickname, options).then((request) => request(axios, basePath));
        },
        /**
         * Get package changelog history by hash
         * @param {number} pkghash package hash
         * @param {number} [changelogLast] changelog history length
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageChangelogSitePackageChangelogIntPkghash(pkghash: number, changelogLast?: number, options?: any): AxiosPromise<SiteChangelogModel> {
            return localVarFp.getRoutePackageChangelogSitePackageChangelogIntPkghash(pkghash, changelogLast, options).then((request) => request(axios, basePath));
        },
        /**
         * Get package download links by source package hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash(pkghash: number, branch: string, options?: any): AxiosPromise<SitePackagesDownloadsModel> {
            return localVarFp.getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash(pkghash, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get package download links by source package hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash(pkghash: number, branch: string, options?: any): AxiosPromise<SitePackagesDownloadsModel> {
            return localVarFp.getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash(pkghash, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get package info by hash
         * @param {number} pkghash package hash
         * @param {string} branch name of packageset
         * @param {number} [changelogLast] changelog history length
         * @param {GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageInfoSitePackageInfoIntPkghash(pkghash: number, branch: string, changelogLast?: number, packageType?: GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum, options?: any): AxiosPromise<SitePackageInfoModel> {
            return localVarFp.getRoutePackageInfoSitePackageInfoIntPkghash(pkghash, branch, changelogLast, packageType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary packages file conflicts by source package.
         * @param {number} pkghash source package hash
         * @param {string} branch name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageMisconflictSitePackageMisconflictIntPkghash(pkghash: number, branch: string, options?: any): AxiosPromise<PackageMisconflictBySrcModel> {
            return localVarFp.getRoutePackageMisconflictSitePackageMisconflictIntPkghash(pkghash, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get source package name from repology.
         * @param {string} branch name of packageset
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageNameFromRepologySitePackageNameFromRepology(branch: string, name: string, options?: any): AxiosPromise<PackageNameFromRepologyModel> {
            return localVarFp.getRoutePackageNameFromRepologySitePackageNameFromRepology(branch, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get package name, version, release and type by hash. Check package name matching if provided.
         * @param {number} pkghash package hash
         * @param {string} [name] package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash(pkghash: number, name?: string, options?: any): AxiosPromise<PackageNVRByHashModel> {
            return localVarFp.getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash(pkghash, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary packages versions from images
         * @param {string} name package name
         * @param {string} branch image base branch
         * @param {string} edition image edition
         * @param {string} type image type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageVersionsFromImagesSitePackageVersionsFromImages(name: string, branch: string, edition: string, type: string, options?: any): AxiosPromise<SiteImagePackageVersionsModel> {
            return localVarFp.getRoutePackageVersionsFromImagesSitePackageVersionsFromImages(name, branch, edition, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Get source package versions from tasks
         * @param {string} name package name
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks(name: string, branch?: string, options?: any): AxiosPromise<SItePackagesVersionsFromTasksModel> {
            return localVarFp.getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks(name, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get source or binary package versions from last branches
         * @param {string} name source package name
         * @param {GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum} [packageType] packages type [source|binary]
         * @param {string} [arch] arch of binary packages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackageVersionsSitePackageVersions(name: string, packageType?: GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum, arch?: string, options?: any): AxiosPromise<SiteSourcePackagesVersionsModel> {
            return localVarFp.getRoutePackageVersionsSitePackageVersions(name, packageType, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary package archs and versions
         * @param {string} branch name of packageset
         * @param {string} name binary package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions(branch: string, name: string, options?: any): AxiosPromise<SitePackagesBinaryListModel> {
            return localVarFp.getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions(branch, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Fast packages search by name
         * @param {Array<string>} name package or list of package names
         * @param {string} [branch] name of packageset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup(name: Array<string>, branch?: string, options?: any): AxiosPromise<SiteFastPackagesSearchModel> {
            return localVarFp.getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup(name, branch, options).then((request) => request(axios, basePath));
        },
        /**
         * Find packages by name
         * @param {Array<string>} name package or list of package names
         * @param {string} [branch] name of packageset
         * @param {string} [arch] binary package arch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetFindPackagesSiteFindPackages(name: Array<string>, branch?: string, arch?: string, options?: any): AxiosPromise<SiteFingPackagesModel> {
            return localVarFp.getRoutePackagesetFindPackagesSiteFindPackages(name, branch, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get binary package hash by package name, arch and package set name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {string} arch package arch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName(branch: string, name: string, arch: string, options?: any): AxiosPromise<SitePackagesetPackageHashModel> {
            return localVarFp.getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName(branch, name, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get source package hash by package name and package set name
         * @param {string} branch name of packageset
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPackageHashSitePkghashByName(branch: string, name: string, options?: any): AxiosPromise<SitePackagesetPackageHashModel> {
            return localVarFp.getRoutePackagesetPackageHashSitePkghashByName(branch, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of packageset packages in accordance to given parameters
         * @param {string} branch name of packageset
         * @param {GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {string} [group] package category
         * @param {number} [buildtime] package buildtime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPackagesSiteRepositoryPackages(branch: string, packageType?: GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum, group?: string, buildtime?: number, options?: any): AxiosPromise<SitePackagesModel> {
            return localVarFp.getRoutePackagesetPackagesSiteRepositoryPackages(branch, packageType, group, buildtime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get source package hash by package name, version and release for specific branch
         * @param {string} name package name
         * @param {string} branch name of packageset
         * @param {string} version source package version
         * @param {string} release source package release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetPkghashByNvrSitePkghashByNvr(name: string, branch: string, version: string, release: string, options?: any): AxiosPromise<SitePackagesetPackageHashByNameVersionRelease> {
            return localVarFp.getRoutePackagesetPkghashByNvrSitePkghashByNvr(name, branch, version, release, options).then((request) => request(axios, basePath));
        },
        /**
         * Get package sets list with source packages count and status info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus(options?: any): AxiosPromise<SitePackagesetsSummaryStatusModel> {
            return localVarFp.getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Get package set list by package hash
         * @param {number} pkghash package hash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash(pkghash: number, options?: any): AxiosPromise<SitePackagesetsByHashModel> {
            return localVarFp.getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash(pkghash, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of package categories with count for given package set
         * @param {string} branch name of packageset
         * @param {GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum} [packageType] packages type [source|binary|all]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount(branch: string, packageType?: GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum, options?: any): AxiosPromise<SitePackagesetCategoriesModel> {
            return localVarFp.getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount(branch, packageType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get repocop results by the maintainers nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteRepocopByMaintainerSiteRepocopByMaintainer(branch: string, maintainerNickname: string, byAcl?: GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum, options?: any): AxiosPromise<Array<RepocopByMaintainerModel>> {
            return localVarFp.getRouteRepocopByMaintainerSiteRepocopByMaintainer(branch, maintainerNickname, byAcl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get source package versions from last branches
         * @param {string} name source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteSourcePackageVersionsSiteSourcePackageVersions(name: string, options?: any): AxiosPromise<SiteSourcePackagesVersionsModel> {
            return localVarFp.getRouteSourcePackageVersionsSiteSourcePackageVersions(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tasks list by maintainer nickname
         * @param {string} branch name of packageset
         * @param {string} maintainerNickname nickname of maintainer
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRouteTasksByMaintainerSiteTasksByMaintainer(branch: string, maintainerNickname: string, options?: any): AxiosPromise<Array<SiteTaskByNameModel>> {
            return localVarFp.getRouteTasksByMaintainerSiteTasksByMaintainer(branch, maintainerNickname, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tasks list by source package name
         * @param {string} name package name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRouteTasksByPackageSiteTasksByPackage(name: string, options?: any): AxiosPromise<SiteTaskByNameModel> {
            return localVarFp.getRouteTasksByPackageSiteTasksByPackage(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get history of done tasks for an active branches
         * @param {number} [taskId] Number of task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTasksHistorySiteTasksHistory(taskId?: number, options?: any): AxiosPromise<SiteTasksHistoryModel> {
            return localVarFp.getRouteTasksHistorySiteTasksHistory(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get watch packages by the maintainer\'s nickname
         * @param {string} maintainerNickname nickname of maintainer
         * @param {GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteWatchByMaintainerSiteWatchByMaintainer(maintainerNickname: string, byAcl?: GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum, options?: any): AxiosPromise<Array<SiteWatchByMaintainerModel>> {
            return localVarFp.getRouteWatchByMaintainerSiteWatchByMaintainer(maintainerNickname, byAcl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SiteApi - object-oriented interface
 * @export
 * @class SiteApi
 * @extends {BaseAPI}
 */
export class SiteApi extends BaseAPI {
    /**
     * Get binary package archs list
     * @param {string} branch name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteAllPackagesetArchsSiteAllPkgsetArchs(branch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteAllPackagesetArchsSiteAllPkgsetArchs(branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary package archs list with source packages count
     * @param {string} branch name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount(branch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount(branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package sets list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteAllPackagesetsSiteAllPkgsets(options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteAllPackagesetsSiteAllPkgsets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package sets list with source packages count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount(options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package sets list with source packages count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteAllPackagesetsSummarySiteAllPkgsetsSummary(options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteAllPackagesetsSummarySiteAllPkgsetsSummary(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Beehive rebuild errors by the maintainer\'s nickname
     * @param {string} branch name of packageset
     * @param {string} maintainerNickname nickname of maintainer
     * @param {GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer(branch: string, maintainerNickname: string, byAcl?: GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer(branch, maintainerNickname, byAcl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary package scripts
     * @param {number} pkghash 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash(pkghash: number, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash(pkghash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary package download link
     * @param {number} pkghash package hash
     * @param {string} branch name of packageset
     * @param {string} arch arch of binary packages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash(pkghash: number, branch: string, arch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash(pkghash, branch, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary package build log link
     * @param {number} pkghash package hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteBinaryPackageLogSitePackageLogBinIntPkghash(pkghash: number, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteBinaryPackageLogSitePackageLogBinIntPkghash(pkghash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get brief package info by hash
     * @param {number} pkghash package hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash(pkghash: number, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash(pkghash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about package deleted from branch
     * @param {string} branch name of packageset
     * @param {string} name package name
     * @param {GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum} [packageType] packages type [source|binary]
     * @param {string} [arch] arch of binary packages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteDeletedPackageInfoSiteDeletedPackageInfo(branch: string, name: string, packageType?: GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum, arch?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteDeletedPackageInfoSiteDeletedPackageInfo(branch, name, packageType, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find source package in branch by binary package name
     * @param {string} branch name of packageset
     * @param {string} name package name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteFindSourcePackageSiteFindSourcePackage(branch: string, name: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteFindSourcePackageSiteFindSourcePackage(branch, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of last packages from branch for given parameters
     * @param {string} branch name of packageset
     * @param {number} packagesLimit number of last packages to get
     * @param {string} [packager] package packager\&#39;s nickname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteLastBranchPackagesSiteLastPackagesByBranch(branch: string, packagesLimit: number, packager?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteLastBranchPackagesSiteLastPackagesByBranch(branch, packagesLimit, packager, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about last packages with CVE fixes mentioned in changelog
     * @param {string} branch name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed(branch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed(branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of last packages from tasks for given parameters
     * @param {string} branch name of packageset
     * @param {number} tasksLimit number of last tasks to get
     * @param {string} [taskOwner] task owner\&#39;s nickname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteLastTaskPackagesSiteLastPackages(branch: string, tasksLimit: number, taskOwner?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteLastTaskPackagesSiteLastPackages(branch, tasksLimit, taskOwner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of last packages from tasks for given parameters
     * @param {string} branch name of packageset
     * @param {number} tasksLimit number of last tasks to get
     * @param {string} [taskOwner] task owner\&#39;s nickname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteLastTaskPackagesSiteLastPackagesByTasks(branch: string, tasksLimit: number, taskOwner?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteLastTaskPackagesSiteLastPackagesByTasks(branch, tasksLimit, taskOwner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Packages collected by the specified maintainer
     * @param {string} maintainerNickname nickname of maintainer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteMaintainerBranchesSiteMaintainerBranches(maintainerNickname: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteMaintainerBranchesSiteMaintainerBranches(maintainerNickname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Packages collected by the specified maintainer
     * @param {string} branch name of packageset
     * @param {string} maintainerNickname nickname of maintainer
     * @param {GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteMaintainerPackagesSiteMaintainerPackages(branch: string, maintainerNickname: string, byAcl?: GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteMaintainerPackagesSiteMaintainerPackages(branch, maintainerNickname, byAcl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of maintainers in branch with nicknames and source packages count
     * @param {string} branch name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteMaintainersAll(branch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteMaintainersAll(branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * alias for /all_maintainers_with_nicknames
     * @param {string} branch name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteMaintainersAllSiteAllMaintainers(branch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteMaintainersAllSiteAllMaintainers(branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Maintainer information
     * @param {string} branch name of packageset
     * @param {string} maintainerNickname nickname of maintainer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteMaintainersInfoSiteMaintainerInfo(branch: string, maintainerNickname: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteMaintainersInfoSiteMaintainerInfo(branch, maintainerNickname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package changelog history by hash
     * @param {number} pkghash package hash
     * @param {number} [changelogLast] changelog history length
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageChangelogSitePackageChangelogIntPkghash(pkghash: number, changelogLast?: number, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageChangelogSitePackageChangelogIntPkghash(pkghash, changelogLast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package download links by source package hash
     * @param {number} pkghash package hash
     * @param {string} branch name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash(pkghash: number, branch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash(pkghash, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package download links by source package hash
     * @param {number} pkghash package hash
     * @param {string} branch name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash(pkghash: number, branch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash(pkghash, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package info by hash
     * @param {number} pkghash package hash
     * @param {string} branch name of packageset
     * @param {number} [changelogLast] changelog history length
     * @param {GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum} [packageType] packages type [source|binary]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageInfoSitePackageInfoIntPkghash(pkghash: number, branch: string, changelogLast?: number, packageType?: GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageInfoSitePackageInfoIntPkghash(pkghash, branch, changelogLast, packageType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary packages file conflicts by source package.
     * @param {number} pkghash source package hash
     * @param {string} branch name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageMisconflictSitePackageMisconflictIntPkghash(pkghash: number, branch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageMisconflictSitePackageMisconflictIntPkghash(pkghash, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source package name from repology.
     * @param {string} branch name of packageset
     * @param {string} name source package name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageNameFromRepologySitePackageNameFromRepology(branch: string, name: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageNameFromRepologySitePackageNameFromRepology(branch, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package name, version, release and type by hash. Check package name matching if provided.
     * @param {number} pkghash package hash
     * @param {string} [name] package name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash(pkghash: number, name?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash(pkghash, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary packages versions from images
     * @param {string} name package name
     * @param {string} branch image base branch
     * @param {string} edition image edition
     * @param {string} type image type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageVersionsFromImagesSitePackageVersionsFromImages(name: string, branch: string, edition: string, type: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageVersionsFromImagesSitePackageVersionsFromImages(name, branch, edition, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source package versions from tasks
     * @param {string} name package name
     * @param {string} [branch] name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks(name: string, branch?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks(name, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source or binary package versions from last branches
     * @param {string} name source package name
     * @param {GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum} [packageType] packages type [source|binary]
     * @param {string} [arch] arch of binary packages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackageVersionsSitePackageVersions(name: string, packageType?: GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum, arch?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackageVersionsSitePackageVersions(name, packageType, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary package archs and versions
     * @param {string} branch name of packageset
     * @param {string} name binary package name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions(branch: string, name: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions(branch, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fast packages search by name
     * @param {Array<string>} name package or list of package names
     * @param {string} [branch] name of packageset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup(name: Array<string>, branch?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup(name, branch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find packages by name
     * @param {Array<string>} name package or list of package names
     * @param {string} [branch] name of packageset
     * @param {string} [arch] binary package arch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagesetFindPackagesSiteFindPackages(name: Array<string>, branch?: string, arch?: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagesetFindPackagesSiteFindPackages(name, branch, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get binary package hash by package name, arch and package set name
     * @param {string} branch name of packageset
     * @param {string} name package name
     * @param {string} arch package arch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName(branch: string, name: string, arch: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName(branch, name, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source package hash by package name and package set name
     * @param {string} branch name of packageset
     * @param {string} name package name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagesetPackageHashSitePkghashByName(branch: string, name: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagesetPackageHashSitePkghashByName(branch, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of packageset packages in accordance to given parameters
     * @param {string} branch name of packageset
     * @param {GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum} [packageType] packages type [source|binary|all]
     * @param {string} [group] package category
     * @param {number} [buildtime] package buildtime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagesetPackagesSiteRepositoryPackages(branch: string, packageType?: GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum, group?: string, buildtime?: number, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagesetPackagesSiteRepositoryPackages(branch, packageType, group, buildtime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source package hash by package name, version and release for specific branch
     * @param {string} name package name
     * @param {string} branch name of packageset
     * @param {string} version source package version
     * @param {string} release source package release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagesetPkghashByNvrSitePkghashByNvr(name: string, branch: string, version: string, release: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagesetPkghashByNvrSitePkghashByNvr(name, branch, version, release, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package sets list with source packages count and status info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus(options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get package set list by package hash
     * @param {number} pkghash package hash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash(pkghash: number, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash(pkghash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of package categories with count for given package set
     * @param {string} branch name of packageset
     * @param {GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum} [packageType] packages type [source|binary|all]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount(branch: string, packageType?: GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount(branch, packageType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get repocop results by the maintainers nickname
     * @param {string} branch name of packageset
     * @param {string} maintainerNickname nickname of maintainer
     * @param {GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteRepocopByMaintainerSiteRepocopByMaintainer(branch: string, maintainerNickname: string, byAcl?: GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteRepocopByMaintainerSiteRepocopByMaintainer(branch, maintainerNickname, byAcl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get source package versions from last branches
     * @param {string} name source package name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteSourcePackageVersionsSiteSourcePackageVersions(name: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteSourcePackageVersionsSiteSourcePackageVersions(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tasks list by maintainer nickname
     * @param {string} branch name of packageset
     * @param {string} maintainerNickname nickname of maintainer
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteTasksByMaintainerSiteTasksByMaintainer(branch: string, maintainerNickname: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteTasksByMaintainerSiteTasksByMaintainer(branch, maintainerNickname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tasks list by source package name
     * @param {string} name package name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteTasksByPackageSiteTasksByPackage(name: string, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteTasksByPackageSiteTasksByPackage(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get history of done tasks for an active branches
     * @param {number} [taskId] Number of task id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteTasksHistorySiteTasksHistory(taskId?: number, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteTasksHistorySiteTasksHistory(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get watch packages by the maintainer\'s nickname
     * @param {string} maintainerNickname nickname of maintainer
     * @param {GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum} [byAcl] search maintainer\&#39;s packages by ACL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteApi
     */
    public getRouteWatchByMaintainerSiteWatchByMaintainer(maintainerNickname: string, byAcl?: GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum, options?: RawAxiosRequestConfig) {
        return SiteApiFp(this.configuration).getRouteWatchByMaintainerSiteWatchByMaintainer(maintainerNickname, byAcl, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum = typeof GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum[keyof typeof GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum];
/**
 * @export
 */
export const GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum = typeof GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum[keyof typeof GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum];
/**
 * @export
 */
export const GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum = typeof GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum[keyof typeof GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum];
/**
 * @export
 */
export const GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum = typeof GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum[keyof typeof GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum];
/**
 * @export
 */
export const GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum = typeof GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum[keyof typeof GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum];
/**
 * @export
 */
export const GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum = {
    All: 'all',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum = typeof GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum[keyof typeof GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum];
/**
 * @export
 */
export const GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum = {
    All: 'all',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum = typeof GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum[keyof typeof GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum];
/**
 * @export
 */
export const GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum = typeof GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum[keyof typeof GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum];
/**
 * @export
 */
export const GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum = typeof GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum[keyof typeof GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum];


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the newest images which contain binary packages with the same names as binaries from a task with one of the following states: EPERM, TESTED or DONE. Listed only active images for task\'s branch.
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindImagesTaskFindImagesIntId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteFindImagesTaskFindImagesIntId', 'id', id)
            const localVarPath = `/task/find_images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get EPERM tasks which require approval
         * @param {GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum} aclGroup ACL-group from which approval is required
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {string} [before] show tasks\&#39; info before specified datetime (YYYY-MM-DD[ HH:MM:SS])
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteNeedsApprovalTaskNeedsApproval: async (aclGroup: GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum, branches?: Array<string>, before?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aclGroup' is not null or undefined
            assertParamExists('getRouteNeedsApprovalTaskNeedsApproval', 'aclGroup', aclGroup)
            const localVarPath = `/task/needs_approval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (aclGroup !== undefined) {
                localVarQueryParameter['acl_group'] = aclGroup;
            }

            if (branches) {
                localVarQueryParameter['branches'] = branches.join(COLLECTION_FORMATS.csv);
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of packages required for build by source packages from task recursively
         * @param {number} id task ID
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskBuildDependencySetTaskBuildDependencySetIntId: async (id: number, arch?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskBuildDependencySetTaskBuildDependencySetIntId', 'id', id)
            const localVarPath = `/task/build_dependency_set/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (arch !== undefined) {
                localVarQueryParameter['arch'] = arch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get packages build dependencies
         * @param {number} id task ID
         * @param {number} [depth] dependency depth
         * @param {GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum} [dptype] dependency type [source|binary|both]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [leaf] assembly dependency chain package
         * @param {boolean} [finitePackage] topological tree leaves packages
         * @param {Array<string>} [filterByPackage] filter result by dependency on binary packages
         * @param {string} [filterBySource] filter result by dependency on source package
         * @param {boolean} [oneandhalf] use dependency depth 1.5
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskBuildDependencyTaskWhatDependsSrcIntId: async (id: number, depth?: number, dptype?: GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum, archs?: Array<string>, leaf?: string, finitePackage?: boolean, filterByPackage?: Array<string>, filterBySource?: string, oneandhalf?: boolean, noCache?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskBuildDependencyTaskWhatDependsSrcIntId', 'id', id)
            const localVarPath = `/task/what_depends_src/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if (dptype !== undefined) {
                localVarQueryParameter['dptype'] = dptype;
            }

            if (archs) {
                localVarQueryParameter['archs'] = archs.join(COLLECTION_FORMATS.csv);
            }

            if (leaf !== undefined) {
                localVarQueryParameter['leaf'] = leaf;
            }

            if (finitePackage !== undefined) {
                localVarQueryParameter['finite_package'] = finitePackage;
            }

            if (filterByPackage) {
                localVarQueryParameter['filter_by_package'] = filterByPackage.join(COLLECTION_FORMATS.csv);
            }

            if (filterBySource !== undefined) {
                localVarQueryParameter['filter_by_source'] = filterBySource;
            }

            if (oneandhalf !== undefined) {
                localVarQueryParameter['oneandhalf'] = oneandhalf;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['no_cache'] = noCache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get task difference by ID
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskDiffTaskTaskDiffIntId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskDiffTaskTaskDiffIntId', 'id', id)
            const localVarPath = `/task/task_diff/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about packages from package sets by list of source packages from task
         * @param {number} id task ID
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskFindPackagesetTaskFindPackagesetIntId: async (id: number, branches?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskFindPackagesetTaskFindPackagesetIntId', 'id', id)
            const localVarPath = `/task/find_packageset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branches) {
                localVarQueryParameter['branches'] = branches.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get done tasks history for branch
         * @param {string} branch name of packageset
         * @param {number} [startTask] start task ID
         * @param {number} [endTask] end task ID
         * @param {string} [startDate] task history start date (YYYY-MM-DD)
         * @param {string} [endDate] task history end date (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskHistoryTaskTaskHistory: async (branch: string, startTask?: number, endTask?: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'branch' is not null or undefined
            assertParamExists('getRouteTaskHistoryTaskTaskHistory', 'branch', branch)
            const localVarPath = `/task/task_history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (startTask !== undefined) {
                localVarQueryParameter['start_task'] = startTask;
            }

            if (endTask !== undefined) {
                localVarQueryParameter['end_task'] = endTask;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for task by ID
         * @param {number} id task ID
         * @param {number} [_try] task try
         * @param {number} [iteration] task iteration
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {Array<string>} [states] Filter task states by given list (valid values is &#x60;DONE&#x60;, &#x60;EPERM&#x60; and &#x60;TESTED&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskInfoTaskTaskInfoIntId: async (id: number, _try?: number, iteration?: number, noCache?: string, states?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskInfoTaskTaskInfoIntId', 'id', id)
            const localVarPath = `/task/task_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (_try !== undefined) {
                localVarQueryParameter['try'] = _try;
            }

            if (iteration !== undefined) {
                localVarQueryParameter['iteration'] = iteration;
            }

            if (noCache !== undefined) {
                localVarQueryParameter['no_cache'] = noCache;
            }

            if (states) {
                localVarQueryParameter['states'] = states.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get packages with conflicting files in packages from task that do not have a conflict in dependencies
         * @param {number} id task ID
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskMisconflictPackagesTaskMisconflictIntId: async (id: number, archs?: Array<string>, noCache?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskMisconflictPackagesTaskMisconflictIntId', 'id', id)
            const localVarPath = `/task/misconflict/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (archs) {
                localVarQueryParameter['archs'] = archs.join(COLLECTION_FORMATS.csv);
            }

            if (noCache !== undefined) {
                localVarQueryParameter['no_cache'] = noCache;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about packages from task
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskPackagesTaskPackagesIntId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskPackagesTaskPackagesIntId', 'id', id)
            const localVarPath = `/task/packages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get repository state by ID
         * @param {number} id task ID
         * @param {boolean} [includeTaskPackages] include task packages in repository state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskRepoTaskTaskRepoIntId: async (id: number, includeTaskPackages?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskRepoTaskTaskRepoIntId', 'id', id)
            const localVarPath = `/task/task_repo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeTaskPackages !== undefined) {
                localVarQueryParameter['include_task_packages'] = includeTaskPackages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Description Get relation between images and binary packages: - if some packages from a task are in images, they will be in **in_images** list. - if some packages from a task aren\'t in any image, they will be in **not_in_images** list.  ## Arguments - Allowed task\'s states: **EPERM**, **TESTED** or **DONE**. - If parameter **packages_names** (list of binary packages names) is set, it will show only specified binary packages. - You can provide multiple filters for images. If an image matches at least one filter, it will be shown.  ## Examples Show information about all of the binary packages inside images: ```json {     \"task_id\": 327143 } ``` Show information about all of the binary packages inside images which edition is \'alt-kworkstation\', type is \'iso\' and version is \'10.1.*\': ```json {     \"task_id\": 327143,     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"types\": [\"iso\"],             \"versions\": [\"10.1\"]         }     ] } ``` Show information about **liblash** binary package inside images which edition is \'alt-kworkstation\' with version \'10.1.*\' or edition \'slinux\' with version \'10.2.*\'. ```json {     \"task_id\": 312990,     \"packages_names\": [         \"liblash\"     ],     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"versions\": [\"10.1\"]         },         {             \"editions\": [\"slinux\"],             \"versions\": [\"10.2\"]         }     ] } ```
         * @param {CheckImagesInputModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteCheckImagesTaskCheckImages: async (payload: CheckImagesInputModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('postRouteCheckImagesTaskCheckImages', 'payload', payload)
            const localVarPath = `/task/check_images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the newest images which contain binary packages with the same names as binaries from a task with one of the following states: EPERM, TESTED or DONE. Listed only active images for task\'s branch.
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFindImagesTaskFindImagesIntId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindImagesByTaskModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFindImagesTaskFindImagesIntId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteFindImagesTaskFindImagesIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get EPERM tasks which require approval
         * @param {GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum} aclGroup ACL-group from which approval is required
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {string} [before] show tasks\&#39; info before specified datetime (YYYY-MM-DD[ HH:MM:SS])
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteNeedsApprovalTaskNeedsApproval(aclGroup: GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum, branches?: Array<string>, before?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NeedsApprovalModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteNeedsApprovalTaskNeedsApproval(aclGroup, branches, before, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteNeedsApprovalTaskNeedsApproval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of packages required for build by source packages from task recursively
         * @param {number} id task ID
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskBuildDependencySetTaskBuildDependencySetIntId(id: number, arch?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildDependencySetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskBuildDependencySetTaskBuildDependencySetIntId(id, arch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskBuildDependencySetTaskBuildDependencySetIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get packages build dependencies
         * @param {number} id task ID
         * @param {number} [depth] dependency depth
         * @param {GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum} [dptype] dependency type [source|binary|both]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [leaf] assembly dependency chain package
         * @param {boolean} [finitePackage] topological tree leaves packages
         * @param {Array<string>} [filterByPackage] filter result by dependency on binary packages
         * @param {string} [filterBySource] filter result by dependency on source package
         * @param {boolean} [oneandhalf] use dependency depth 1.5
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskBuildDependencyTaskWhatDependsSrcIntId(id: number, depth?: number, dptype?: GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum, archs?: Array<string>, leaf?: string, finitePackage?: boolean, filterByPackage?: Array<string>, filterBySource?: string, oneandhalf?: boolean, noCache?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskBuildDependencyModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskBuildDependencyTaskWhatDependsSrcIntId(id, depth, dptype, archs, leaf, finitePackage, filterByPackage, filterBySource, oneandhalf, noCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskBuildDependencyTaskWhatDependsSrcIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get task difference by ID
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskDiffTaskTaskDiffIntId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDiffModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskDiffTaskTaskDiffIntId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskDiffTaskTaskDiffIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about packages from package sets by list of source packages from task
         * @param {number} id task ID
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskFindPackagesetTaskFindPackagesetIntId(id: number, branches?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskFindPackagesetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskFindPackagesetTaskFindPackagesetIntId(id, branches, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskFindPackagesetTaskFindPackagesetIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get done tasks history for branch
         * @param {string} branch name of packageset
         * @param {number} [startTask] start task ID
         * @param {number} [endTask] end task ID
         * @param {string} [startDate] task history start date (YYYY-MM-DD)
         * @param {string} [endDate] task history end date (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskHistoryTaskTaskHistory(branch: string, startTask?: number, endTask?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskHistoryModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskHistoryTaskTaskHistory(branch, startTask, endTask, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskHistoryTaskTaskHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information for task by ID
         * @param {number} id task ID
         * @param {number} [_try] task try
         * @param {number} [iteration] task iteration
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {Array<string>} [states] Filter task states by given list (valid values is &#x60;DONE&#x60;, &#x60;EPERM&#x60; and &#x60;TESTED&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskInfoTaskTaskInfoIntId(id: number, _try?: number, iteration?: number, noCache?: string, states?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskInfoTaskTaskInfoIntId(id, _try, iteration, noCache, states, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskInfoTaskTaskInfoIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get packages with conflicting files in packages from task that do not have a conflict in dependencies
         * @param {number} id task ID
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskMisconflictPackagesTaskMisconflictIntId(id: number, archs?: Array<string>, noCache?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskMisconflictPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskMisconflictPackagesTaskMisconflictIntId(id, archs, noCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskMisconflictPackagesTaskMisconflictIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about packages from task
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskPackagesTaskPackagesIntId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskPackagesTaskPackagesIntId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskPackagesTaskPackagesIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get repository state by ID
         * @param {number} id task ID
         * @param {boolean} [includeTaskPackages] include task packages in repository state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskRepoTaskTaskRepoIntId(id: number, includeTaskPackages?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRepoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskRepoTaskTaskRepoIntId(id, includeTaskPackages, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.getRouteTaskRepoTaskTaskRepoIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ## Description Get relation between images and binary packages: - if some packages from a task are in images, they will be in **in_images** list. - if some packages from a task aren\'t in any image, they will be in **not_in_images** list.  ## Arguments - Allowed task\'s states: **EPERM**, **TESTED** or **DONE**. - If parameter **packages_names** (list of binary packages names) is set, it will show only specified binary packages. - You can provide multiple filters for images. If an image matches at least one filter, it will be shown.  ## Examples Show information about all of the binary packages inside images: ```json {     \"task_id\": 327143 } ``` Show information about all of the binary packages inside images which edition is \'alt-kworkstation\', type is \'iso\' and version is \'10.1.*\': ```json {     \"task_id\": 327143,     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"types\": [\"iso\"],             \"versions\": [\"10.1\"]         }     ] } ``` Show information about **liblash** binary package inside images which edition is \'alt-kworkstation\' with version \'10.1.*\' or edition \'slinux\' with version \'10.2.*\'. ```json {     \"task_id\": 312990,     \"packages_names\": [         \"liblash\"     ],     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"versions\": [\"10.1\"]         },         {             \"editions\": [\"slinux\"],             \"versions\": [\"10.2\"]         }     ] } ```
         * @param {CheckImagesInputModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRouteCheckImagesTaskCheckImages(payload: CheckImagesInputModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckImagesOutputModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRouteCheckImagesTaskCheckImages(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskApi.postRouteCheckImagesTaskCheckImages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * Get the newest images which contain binary packages with the same names as binaries from a task with one of the following states: EPERM, TESTED or DONE. Listed only active images for task\'s branch.
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindImagesTaskFindImagesIntId(id: number, options?: any): AxiosPromise<FindImagesByTaskModel> {
            return localVarFp.getRouteFindImagesTaskFindImagesIntId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get EPERM tasks which require approval
         * @param {GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum} aclGroup ACL-group from which approval is required
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {string} [before] show tasks\&#39; info before specified datetime (YYYY-MM-DD[ HH:MM:SS])
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteNeedsApprovalTaskNeedsApproval(aclGroup: GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum, branches?: Array<string>, before?: string, options?: any): AxiosPromise<NeedsApprovalModel> {
            return localVarFp.getRouteNeedsApprovalTaskNeedsApproval(aclGroup, branches, before, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of packages required for build by source packages from task recursively
         * @param {number} id task ID
         * @param {string} [arch] packages architecture
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskBuildDependencySetTaskBuildDependencySetIntId(id: number, arch?: string, options?: any): AxiosPromise<BuildDependencySetModel> {
            return localVarFp.getRouteTaskBuildDependencySetTaskBuildDependencySetIntId(id, arch, options).then((request) => request(axios, basePath));
        },
        /**
         * Get packages build dependencies
         * @param {number} id task ID
         * @param {number} [depth] dependency depth
         * @param {GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum} [dptype] dependency type [source|binary|both]
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [leaf] assembly dependency chain package
         * @param {boolean} [finitePackage] topological tree leaves packages
         * @param {Array<string>} [filterByPackage] filter result by dependency on binary packages
         * @param {string} [filterBySource] filter result by dependency on source package
         * @param {boolean} [oneandhalf] use dependency depth 1.5
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskBuildDependencyTaskWhatDependsSrcIntId(id: number, depth?: number, dptype?: GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum, archs?: Array<string>, leaf?: string, finitePackage?: boolean, filterByPackage?: Array<string>, filterBySource?: string, oneandhalf?: boolean, noCache?: string, options?: any): AxiosPromise<TaskBuildDependencyModel> {
            return localVarFp.getRouteTaskBuildDependencyTaskWhatDependsSrcIntId(id, depth, dptype, archs, leaf, finitePackage, filterByPackage, filterBySource, oneandhalf, noCache, options).then((request) => request(axios, basePath));
        },
        /**
         * Get task difference by ID
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskDiffTaskTaskDiffIntId(id: number, options?: any): AxiosPromise<TaskDiffModel> {
            return localVarFp.getRouteTaskDiffTaskTaskDiffIntId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about packages from package sets by list of source packages from task
         * @param {number} id task ID
         * @param {Array<string>} [branches] list of package sets to filter result
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskFindPackagesetTaskFindPackagesetIntId(id: number, branches?: Array<string>, options?: any): AxiosPromise<TaskFindPackagesetModel> {
            return localVarFp.getRouteTaskFindPackagesetTaskFindPackagesetIntId(id, branches, options).then((request) => request(axios, basePath));
        },
        /**
         * Get done tasks history for branch
         * @param {string} branch name of packageset
         * @param {number} [startTask] start task ID
         * @param {number} [endTask] end task ID
         * @param {string} [startDate] task history start date (YYYY-MM-DD)
         * @param {string} [endDate] task history end date (YYYY-MM-DD)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskHistoryTaskTaskHistory(branch: string, startTask?: number, endTask?: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<TaskHistoryModel> {
            return localVarFp.getRouteTaskHistoryTaskTaskHistory(branch, startTask, endTask, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for task by ID
         * @param {number} id task ID
         * @param {number} [_try] task try
         * @param {number} [iteration] task iteration
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {Array<string>} [states] Filter task states by given list (valid values is &#x60;DONE&#x60;, &#x60;EPERM&#x60; and &#x60;TESTED&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskInfoTaskTaskInfoIntId(id: number, _try?: number, iteration?: number, noCache?: string, states?: Array<string>, options?: any): AxiosPromise<TaskInfoModel> {
            return localVarFp.getRouteTaskInfoTaskTaskInfoIntId(id, _try, iteration, noCache, states, options).then((request) => request(axios, basePath));
        },
        /**
         * Get packages with conflicting files in packages from task that do not have a conflict in dependencies
         * @param {number} id task ID
         * @param {Array<string>} [archs] list of packages architectures
         * @param {string} [noCache] cache override value, not affect on request results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskMisconflictPackagesTaskMisconflictIntId(id: number, archs?: Array<string>, noCache?: string, options?: any): AxiosPromise<TaskMisconflictPackagesModel> {
            return localVarFp.getRouteTaskMisconflictPackagesTaskMisconflictIntId(id, archs, noCache, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about packages from task
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskPackagesTaskPackagesIntId(id: number, options?: any): AxiosPromise<TaskPackagesModel> {
            return localVarFp.getRouteTaskPackagesTaskPackagesIntId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get repository state by ID
         * @param {number} id task ID
         * @param {boolean} [includeTaskPackages] include task packages in repository state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskRepoTaskTaskRepoIntId(id: number, includeTaskPackages?: boolean, options?: any): AxiosPromise<TaskRepoModel> {
            return localVarFp.getRouteTaskRepoTaskTaskRepoIntId(id, includeTaskPackages, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Description Get relation between images and binary packages: - if some packages from a task are in images, they will be in **in_images** list. - if some packages from a task aren\'t in any image, they will be in **not_in_images** list.  ## Arguments - Allowed task\'s states: **EPERM**, **TESTED** or **DONE**. - If parameter **packages_names** (list of binary packages names) is set, it will show only specified binary packages. - You can provide multiple filters for images. If an image matches at least one filter, it will be shown.  ## Examples Show information about all of the binary packages inside images: ```json {     \"task_id\": 327143 } ``` Show information about all of the binary packages inside images which edition is \'alt-kworkstation\', type is \'iso\' and version is \'10.1.*\': ```json {     \"task_id\": 327143,     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"types\": [\"iso\"],             \"versions\": [\"10.1\"]         }     ] } ``` Show information about **liblash** binary package inside images which edition is \'alt-kworkstation\' with version \'10.1.*\' or edition \'slinux\' with version \'10.2.*\'. ```json {     \"task_id\": 312990,     \"packages_names\": [         \"liblash\"     ],     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"versions\": [\"10.1\"]         },         {             \"editions\": [\"slinux\"],             \"versions\": [\"10.2\"]         }     ] } ```
         * @param {CheckImagesInputModel} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRouteCheckImagesTaskCheckImages(payload: CheckImagesInputModel, options?: any): AxiosPromise<CheckImagesOutputModel> {
            return localVarFp.postRouteCheckImagesTaskCheckImages(payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * Get the newest images which contain binary packages with the same names as binaries from a task with one of the following states: EPERM, TESTED or DONE. Listed only active images for task\'s branch.
     * @param {number} id task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteFindImagesTaskFindImagesIntId(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteFindImagesTaskFindImagesIntId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get EPERM tasks which require approval
     * @param {GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum} aclGroup ACL-group from which approval is required
     * @param {Array<string>} [branches] list of package sets to filter result
     * @param {string} [before] show tasks\&#39; info before specified datetime (YYYY-MM-DD[ HH:MM:SS])
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteNeedsApprovalTaskNeedsApproval(aclGroup: GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum, branches?: Array<string>, before?: string, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteNeedsApprovalTaskNeedsApproval(aclGroup, branches, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of packages required for build by source packages from task recursively
     * @param {number} id task ID
     * @param {string} [arch] packages architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskBuildDependencySetTaskBuildDependencySetIntId(id: number, arch?: string, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskBuildDependencySetTaskBuildDependencySetIntId(id, arch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get packages build dependencies
     * @param {number} id task ID
     * @param {number} [depth] dependency depth
     * @param {GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum} [dptype] dependency type [source|binary|both]
     * @param {Array<string>} [archs] list of packages architectures
     * @param {string} [leaf] assembly dependency chain package
     * @param {boolean} [finitePackage] topological tree leaves packages
     * @param {Array<string>} [filterByPackage] filter result by dependency on binary packages
     * @param {string} [filterBySource] filter result by dependency on source package
     * @param {boolean} [oneandhalf] use dependency depth 1.5
     * @param {string} [noCache] cache override value, not affect on request results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskBuildDependencyTaskWhatDependsSrcIntId(id: number, depth?: number, dptype?: GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum, archs?: Array<string>, leaf?: string, finitePackage?: boolean, filterByPackage?: Array<string>, filterBySource?: string, oneandhalf?: boolean, noCache?: string, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskBuildDependencyTaskWhatDependsSrcIntId(id, depth, dptype, archs, leaf, finitePackage, filterByPackage, filterBySource, oneandhalf, noCache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get task difference by ID
     * @param {number} id task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskDiffTaskTaskDiffIntId(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskDiffTaskTaskDiffIntId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about packages from package sets by list of source packages from task
     * @param {number} id task ID
     * @param {Array<string>} [branches] list of package sets to filter result
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskFindPackagesetTaskFindPackagesetIntId(id: number, branches?: Array<string>, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskFindPackagesetTaskFindPackagesetIntId(id, branches, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get done tasks history for branch
     * @param {string} branch name of packageset
     * @param {number} [startTask] start task ID
     * @param {number} [endTask] end task ID
     * @param {string} [startDate] task history start date (YYYY-MM-DD)
     * @param {string} [endDate] task history end date (YYYY-MM-DD)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskHistoryTaskTaskHistory(branch: string, startTask?: number, endTask?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskHistoryTaskTaskHistory(branch, startTask, endTask, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for task by ID
     * @param {number} id task ID
     * @param {number} [_try] task try
     * @param {number} [iteration] task iteration
     * @param {string} [noCache] cache override value, not affect on request results
     * @param {Array<string>} [states] Filter task states by given list (valid values is &#x60;DONE&#x60;, &#x60;EPERM&#x60; and &#x60;TESTED&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskInfoTaskTaskInfoIntId(id: number, _try?: number, iteration?: number, noCache?: string, states?: Array<string>, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskInfoTaskTaskInfoIntId(id, _try, iteration, noCache, states, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get packages with conflicting files in packages from task that do not have a conflict in dependencies
     * @param {number} id task ID
     * @param {Array<string>} [archs] list of packages architectures
     * @param {string} [noCache] cache override value, not affect on request results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskMisconflictPackagesTaskMisconflictIntId(id: number, archs?: Array<string>, noCache?: string, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskMisconflictPackagesTaskMisconflictIntId(id, archs, noCache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about packages from task
     * @param {number} id task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskPackagesTaskPackagesIntId(id: number, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskPackagesTaskPackagesIntId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get repository state by ID
     * @param {number} id task ID
     * @param {boolean} [includeTaskPackages] include task packages in repository state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRouteTaskRepoTaskTaskRepoIntId(id: number, includeTaskPackages?: boolean, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).getRouteTaskRepoTaskTaskRepoIntId(id, includeTaskPackages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Description Get relation between images and binary packages: - if some packages from a task are in images, they will be in **in_images** list. - if some packages from a task aren\'t in any image, they will be in **not_in_images** list.  ## Arguments - Allowed task\'s states: **EPERM**, **TESTED** or **DONE**. - If parameter **packages_names** (list of binary packages names) is set, it will show only specified binary packages. - You can provide multiple filters for images. If an image matches at least one filter, it will be shown.  ## Examples Show information about all of the binary packages inside images: ```json {     \"task_id\": 327143 } ``` Show information about all of the binary packages inside images which edition is \'alt-kworkstation\', type is \'iso\' and version is \'10.1.*\': ```json {     \"task_id\": 327143,     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"types\": [\"iso\"],             \"versions\": [\"10.1\"]         }     ] } ``` Show information about **liblash** binary package inside images which edition is \'alt-kworkstation\' with version \'10.1.*\' or edition \'slinux\' with version \'10.2.*\'. ```json {     \"task_id\": 312990,     \"packages_names\": [         \"liblash\"     ],     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"versions\": [\"10.1\"]         },         {             \"editions\": [\"slinux\"],             \"versions\": [\"10.2\"]         }     ] } ```
     * @param {CheckImagesInputModel} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public postRouteCheckImagesTaskCheckImages(payload: CheckImagesInputModel, options?: RawAxiosRequestConfig) {
        return TaskApiFp(this.configuration).postRouteCheckImagesTaskCheckImages(payload, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum = {
    Maint: 'maint',
    Tester: 'tester'
} as const;
export type GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum = typeof GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum[keyof typeof GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum];
/**
 * @export
 */
export const GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum = {
    Both: 'both',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum = typeof GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum[keyof typeof GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum];


/**
 * TaskProgressApi - axios parameter creator
 * @export
 */
export const TaskProgressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get branches list for last tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllTasksBranches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/progress/all_tasks_branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alias for \'all_tasks_branches\' for compatibility
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRouteAllTasksBranchesTaskProgressAllPackagesets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/progress/all_packagesets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Task search by ID, owner, repo, state and component.
         * @param {Array<string>} input task search arguments
         * @param {string} [branch] name of packageset
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindTasksLookupTaskProgressFindTasksLookup: async (input: Array<string>, branch?: string, tasksLimit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'input' is not null or undefined
            assertParamExists('getRouteFindTasksLookupTaskProgressFindTasksLookup', 'input', input)
            const localVarPath = `/task/progress/find_tasks_lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input) {
                localVarQueryParameter['input'] = input.join(COLLECTION_FORMATS.csv);
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (tasksLimit !== undefined) {
                localVarQueryParameter['tasks_limit'] = tasksLimit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Task search by ID, task owner or component.
         * @param {Array<string>} input task search arguments
         * @param {string} [owner] task owner
         * @param {string} [branch] name of packageset
         * @param {Array<string>} [state] task state
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {boolean} [byPackage] find tasks by source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindTasksTaskProgressFindTasks: async (input: Array<string>, owner?: string, branch?: string, state?: Array<string>, tasksLimit?: number, byPackage?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'input' is not null or undefined
            assertParamExists('getRouteFindTasksTaskProgressFindTasks', 'input', input)
            const localVarPath = `/task/progress/find_tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (input) {
                localVarQueryParameter['input'] = input.join(COLLECTION_FORMATS.csv);
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (state) {
                localVarQueryParameter['state'] = state.join(COLLECTION_FORMATS.csv);
            }

            if (tasksLimit !== undefined) {
                localVarQueryParameter['tasks_limit'] = tasksLimit;
            }

            if (byPackage !== undefined) {
                localVarQueryParameter['by_package'] = byPackage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the latest tasks changes
         * @param {string} [branch] name of packageset
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastTasksTaskProgressLastTasks: async (branch?: string, tasksLimit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/task/progress/last_tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (branch !== undefined) {
                localVarQueryParameter['branch'] = branch;
            }

            if (tasksLimit !== undefined) {
                localVarQueryParameter['tasks_limit'] = tasksLimit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for task by ID
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskInfoTaskProgressTaskInfoIntId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskInfoTaskProgressTaskInfoIntId', 'id', id)
            const localVarPath = `/task/progress/task_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskProgressApi - functional programming interface
 * @export
 */
export const TaskProgressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskProgressApiAxiosParamCreator(configuration)
    return {
        /**
         * Get branches list for last tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAllTasksBranches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTasksBranchesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAllTasksBranches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskProgressApi.getRouteAllTasksBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Alias for \'all_tasks_branches\' for compatibility
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getRouteAllTasksBranchesTaskProgressAllPackagesets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTasksBranchesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteAllTasksBranchesTaskProgressAllPackagesets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskProgressApi.getRouteAllTasksBranchesTaskProgressAllPackagesets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Task search by ID, owner, repo, state and component.
         * @param {Array<string>} input task search arguments
         * @param {string} [branch] name of packageset
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFindTasksLookupTaskProgressFindTasksLookup(input: Array<string>, branch?: string, tasksLimit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindTasksModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFindTasksLookupTaskProgressFindTasksLookup(input, branch, tasksLimit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskProgressApi.getRouteFindTasksLookupTaskProgressFindTasksLookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Task search by ID, task owner or component.
         * @param {Array<string>} input task search arguments
         * @param {string} [owner] task owner
         * @param {string} [branch] name of packageset
         * @param {Array<string>} [state] task state
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {boolean} [byPackage] find tasks by source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteFindTasksTaskProgressFindTasks(input: Array<string>, owner?: string, branch?: string, state?: Array<string>, tasksLimit?: number, byPackage?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksListModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteFindTasksTaskProgressFindTasks(input, owner, branch, state, tasksLimit, byPackage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskProgressApi.getRouteFindTasksTaskProgressFindTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the latest tasks changes
         * @param {string} [branch] name of packageset
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteLastTasksTaskProgressLastTasks(branch?: string, tasksLimit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksListModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteLastTasksTaskProgressLastTasks(branch, tasksLimit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskProgressApi.getRouteLastTasksTaskProgressLastTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information for task by ID
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskInfoTaskProgressTaskInfoIntId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskProgressTaskInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskInfoTaskProgressTaskInfoIntId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskProgressApi.getRouteTaskInfoTaskProgressTaskInfoIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TaskProgressApi - factory interface
 * @export
 */
export const TaskProgressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskProgressApiFp(configuration)
    return {
        /**
         * Get branches list for last tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAllTasksBranches(options?: any): AxiosPromise<AllTasksBranchesModel> {
            return localVarFp.getRouteAllTasksBranches(options).then((request) => request(axios, basePath));
        },
        /**
         * Alias for \'all_tasks_branches\' for compatibility
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getRouteAllTasksBranchesTaskProgressAllPackagesets(options?: any): AxiosPromise<AllTasksBranchesModel> {
            return localVarFp.getRouteAllTasksBranchesTaskProgressAllPackagesets(options).then((request) => request(axios, basePath));
        },
        /**
         * Task search by ID, owner, repo, state and component.
         * @param {Array<string>} input task search arguments
         * @param {string} [branch] name of packageset
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindTasksLookupTaskProgressFindTasksLookup(input: Array<string>, branch?: string, tasksLimit?: number, options?: any): AxiosPromise<FindTasksModel> {
            return localVarFp.getRouteFindTasksLookupTaskProgressFindTasksLookup(input, branch, tasksLimit, options).then((request) => request(axios, basePath));
        },
        /**
         * Task search by ID, task owner or component.
         * @param {Array<string>} input task search arguments
         * @param {string} [owner] task owner
         * @param {string} [branch] name of packageset
         * @param {Array<string>} [state] task state
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {boolean} [byPackage] find tasks by source package name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteFindTasksTaskProgressFindTasks(input: Array<string>, owner?: string, branch?: string, state?: Array<string>, tasksLimit?: number, byPackage?: boolean, options?: any): AxiosPromise<TasksListModel> {
            return localVarFp.getRouteFindTasksTaskProgressFindTasks(input, owner, branch, state, tasksLimit, byPackage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the latest tasks changes
         * @param {string} [branch] name of packageset
         * @param {number} [tasksLimit] number of last tasks to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteLastTasksTaskProgressLastTasks(branch?: string, tasksLimit?: number, options?: any): AxiosPromise<TasksListModel> {
            return localVarFp.getRouteLastTasksTaskProgressLastTasks(branch, tasksLimit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for task by ID
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskInfoTaskProgressTaskInfoIntId(id: number, options?: any): AxiosPromise<TaskProgressTaskInfoModel> {
            return localVarFp.getRouteTaskInfoTaskProgressTaskInfoIntId(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskProgressApi - object-oriented interface
 * @export
 * @class TaskProgressApi
 * @extends {BaseAPI}
 */
export class TaskProgressApi extends BaseAPI {
    /**
     * Get branches list for last tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskProgressApi
     */
    public getRouteAllTasksBranches(options?: RawAxiosRequestConfig) {
        return TaskProgressApiFp(this.configuration).getRouteAllTasksBranches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alias for \'all_tasks_branches\' for compatibility
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TaskProgressApi
     */
    public getRouteAllTasksBranchesTaskProgressAllPackagesets(options?: RawAxiosRequestConfig) {
        return TaskProgressApiFp(this.configuration).getRouteAllTasksBranchesTaskProgressAllPackagesets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Task search by ID, owner, repo, state and component.
     * @param {Array<string>} input task search arguments
     * @param {string} [branch] name of packageset
     * @param {number} [tasksLimit] number of last tasks to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskProgressApi
     */
    public getRouteFindTasksLookupTaskProgressFindTasksLookup(input: Array<string>, branch?: string, tasksLimit?: number, options?: RawAxiosRequestConfig) {
        return TaskProgressApiFp(this.configuration).getRouteFindTasksLookupTaskProgressFindTasksLookup(input, branch, tasksLimit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Task search by ID, task owner or component.
     * @param {Array<string>} input task search arguments
     * @param {string} [owner] task owner
     * @param {string} [branch] name of packageset
     * @param {Array<string>} [state] task state
     * @param {number} [tasksLimit] number of last tasks to get
     * @param {boolean} [byPackage] find tasks by source package name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskProgressApi
     */
    public getRouteFindTasksTaskProgressFindTasks(input: Array<string>, owner?: string, branch?: string, state?: Array<string>, tasksLimit?: number, byPackage?: boolean, options?: RawAxiosRequestConfig) {
        return TaskProgressApiFp(this.configuration).getRouteFindTasksTaskProgressFindTasks(input, owner, branch, state, tasksLimit, byPackage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the latest tasks changes
     * @param {string} [branch] name of packageset
     * @param {number} [tasksLimit] number of last tasks to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskProgressApi
     */
    public getRouteLastTasksTaskProgressLastTasks(branch?: string, tasksLimit?: number, options?: RawAxiosRequestConfig) {
        return TaskProgressApiFp(this.configuration).getRouteLastTasksTaskProgressLastTasks(branch, tasksLimit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for task by ID
     * @param {number} id task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskProgressApi
     */
    public getRouteTaskInfoTaskProgressTaskInfoIntId(id: number, options?: RawAxiosRequestConfig) {
        return TaskProgressApiFp(this.configuration).getRouteTaskInfoTaskProgressTaskInfoIntId(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VulnApi - axios parameter creator
 * @export
 */
export const VulnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get BDU information
         * @param {string} vulnId BDU id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBduInfoVulnBdu: async (vulnId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vulnId' is not null or undefined
            assertParamExists('getRouteBduInfoVulnBdu', 'vulnId', vulnId)
            const localVarPath = `/vuln/bdu`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vulnId !== undefined) {
                localVarQueryParameter['vuln_id'] = vulnId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CVE information
         * @param {string} vulnId CVE id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteCveInfoVulnCve: async (vulnId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vulnId' is not null or undefined
            assertParamExists('getRouteCveInfoVulnCve', 'vulnId', vulnId)
            const localVarPath = `/vuln/cve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vulnId !== undefined) {
                localVarQueryParameter['vuln_id'] = vulnId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of fixed CVEs from an task with one of the following states: EPERM, TESTED, or DONE.
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskVulnerabilitiesVulnTaskIntId: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRouteTaskVulnerabilitiesVulnTaskIntId', 'id', id)
            const localVarPath = `/vuln/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of packages in which the specified BDU vulnerability is closed.
         * @param {string} vulnId BDU id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteVulnerableBduFixesVulnBduFixes: async (vulnId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vulnId' is not null or undefined
            assertParamExists('getRouteVulnerableBduFixesVulnBduFixes', 'vulnId', vulnId)
            const localVarPath = `/vuln/bdu/fixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vulnId !== undefined) {
                localVarQueryParameter['vuln_id'] = vulnId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of packages in which the specified CVE vulnerability is closed.
         * @param {string} vulnId CVE id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteVulnerableCveFixesVulnCveFixes: async (vulnId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vulnId' is not null or undefined
            assertParamExists('getRouteVulnerableCveFixesVulnCveFixes', 'vulnId', vulnId)
            const localVarPath = `/vuln/cve/fixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vulnId !== undefined) {
                localVarQueryParameter['vuln_id'] = vulnId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VulnApi - functional programming interface
 * @export
 */
export const VulnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VulnApiAxiosParamCreator(configuration)
    return {
        /**
         * Get BDU information
         * @param {string} vulnId BDU id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteBduInfoVulnBdu(vulnId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VulnerabilityInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteBduInfoVulnBdu(vulnId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VulnApi.getRouteBduInfoVulnBdu']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get CVE information
         * @param {string} vulnId CVE id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteCveInfoVulnCve(vulnId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VulnerabilityInfoModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteCveInfoVulnCve(vulnId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VulnApi.getRouteCveInfoVulnCve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of fixed CVEs from an task with one of the following states: EPERM, TESTED, or DONE.
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteTaskVulnerabilitiesVulnTaskIntId(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CveVulnerableTaskModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteTaskVulnerabilitiesVulnTaskIntId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VulnApi.getRouteTaskVulnerabilitiesVulnTaskIntId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of packages in which the specified BDU vulnerability is closed.
         * @param {string} vulnId BDU id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteVulnerableBduFixesVulnBduFixes(vulnId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VulnFixesPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteVulnerableBduFixesVulnBduFixes(vulnId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VulnApi.getRouteVulnerableBduFixesVulnBduFixes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of packages in which the specified CVE vulnerability is closed.
         * @param {string} vulnId CVE id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteVulnerableCveFixesVulnCveFixes(vulnId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VulnFixesPackagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRouteVulnerableCveFixesVulnCveFixes(vulnId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VulnApi.getRouteVulnerableCveFixesVulnCveFixes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VulnApi - factory interface
 * @export
 */
export const VulnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VulnApiFp(configuration)
    return {
        /**
         * Get BDU information
         * @param {string} vulnId BDU id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteBduInfoVulnBdu(vulnId: string, options?: any): AxiosPromise<VulnerabilityInfoModel> {
            return localVarFp.getRouteBduInfoVulnBdu(vulnId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CVE information
         * @param {string} vulnId CVE id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteCveInfoVulnCve(vulnId: string, options?: any): AxiosPromise<VulnerabilityInfoModel> {
            return localVarFp.getRouteCveInfoVulnCve(vulnId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of fixed CVEs from an task with one of the following states: EPERM, TESTED, or DONE.
         * @param {number} id task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteTaskVulnerabilitiesVulnTaskIntId(id: number, options?: any): AxiosPromise<CveVulnerableTaskModel> {
            return localVarFp.getRouteTaskVulnerabilitiesVulnTaskIntId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of packages in which the specified BDU vulnerability is closed.
         * @param {string} vulnId BDU id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteVulnerableBduFixesVulnBduFixes(vulnId: string, options?: any): AxiosPromise<VulnFixesPackagesModel> {
            return localVarFp.getRouteVulnerableBduFixesVulnBduFixes(vulnId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of packages in which the specified CVE vulnerability is closed.
         * @param {string} vulnId CVE id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteVulnerableCveFixesVulnCveFixes(vulnId: string, options?: any): AxiosPromise<VulnFixesPackagesModel> {
            return localVarFp.getRouteVulnerableCveFixesVulnCveFixes(vulnId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VulnApi - object-oriented interface
 * @export
 * @class VulnApi
 * @extends {BaseAPI}
 */
export class VulnApi extends BaseAPI {
    /**
     * Get BDU information
     * @param {string} vulnId BDU id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VulnApi
     */
    public getRouteBduInfoVulnBdu(vulnId: string, options?: RawAxiosRequestConfig) {
        return VulnApiFp(this.configuration).getRouteBduInfoVulnBdu(vulnId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CVE information
     * @param {string} vulnId CVE id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VulnApi
     */
    public getRouteCveInfoVulnCve(vulnId: string, options?: RawAxiosRequestConfig) {
        return VulnApiFp(this.configuration).getRouteCveInfoVulnCve(vulnId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of fixed CVEs from an task with one of the following states: EPERM, TESTED, or DONE.
     * @param {number} id task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VulnApi
     */
    public getRouteTaskVulnerabilitiesVulnTaskIntId(id: number, options?: RawAxiosRequestConfig) {
        return VulnApiFp(this.configuration).getRouteTaskVulnerabilitiesVulnTaskIntId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of packages in which the specified BDU vulnerability is closed.
     * @param {string} vulnId BDU id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VulnApi
     */
    public getRouteVulnerableBduFixesVulnBduFixes(vulnId: string, options?: RawAxiosRequestConfig) {
        return VulnApiFp(this.configuration).getRouteVulnerableBduFixesVulnBduFixes(vulnId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of packages in which the specified CVE vulnerability is closed.
     * @param {string} vulnId CVE id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VulnApi
     */
    public getRouteVulnerableCveFixesVulnCveFixes(vulnId: string, options?: RawAxiosRequestConfig) {
        return VulnApiFp(this.configuration).getRouteVulnerableCveFixesVulnCveFixes(vulnId, options).then((request) => request(this.axios, this.basePath));
    }
}



