/* tslint:disable */
/* eslint-disable */
/**
 * ALTRepo API
 * altrepo API v1
 *
 * The version of the OpenAPI document: 1.19.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BackportHelperModel,
  DependenciesPackageBuildDependenciesModel,
  DependenciesPackageDependenciesModel,
  DependenciesPackagesModel,
  FastDependencySearchModel,
  PackageBuildDependencyModel,
} from '../models/index';
import {
    BackportHelperModelFromJSON,
    BackportHelperModelToJSON,
    DependenciesPackageBuildDependenciesModelFromJSON,
    DependenciesPackageBuildDependenciesModelToJSON,
    DependenciesPackageDependenciesModelFromJSON,
    DependenciesPackageDependenciesModelToJSON,
    DependenciesPackagesModelFromJSON,
    DependenciesPackagesModelToJSON,
    FastDependencySearchModelFromJSON,
    FastDependencySearchModelToJSON,
    PackageBuildDependencyModelFromJSON,
    PackageBuildDependencyModelToJSON,
} from '../models/index';

export interface GetRouteBackportHelperRequest {
    fromBranch: string;
    intoBranch: string;
    packagesNames: Array<string>;
    dpType?: GetRouteBackportHelperDpTypeEnum;
    archs?: Array<string>;
}

export interface GetRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghashRequest {
    pkghash: number;
}

export interface GetRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghashRequest {
    pkghash: number;
    branch: string;
    depth?: number;
}

export interface GetRouteFastLookupDependenciesFastLookupRequest {
    branch: string;
    dpName: string;
    limit?: number;
}

export interface GetRoutePackageBuildDependencyDependenciesWhatDependsSrcRequest {
    name: string;
    branch: string;
    dpType?: GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum;
}

export interface GetRoutePackageDependsDependenciesPackagesByDependencyRequest {
    branch: string;
    dpName: string;
    dpType?: GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum;
}

/**
 * 
 */
export class DependenciesApi extends runtime.BaseAPI {

    /**
     * Find packages required to backport too
     */
    async getRouteBackportHelperRaw(requestParameters: GetRouteBackportHelperRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BackportHelperModel>>> {
        if (requestParameters['fromBranch'] == null) {
            throw new runtime.RequiredError(
                'fromBranch',
                'Required parameter "fromBranch" was null or undefined when calling getRouteBackportHelper().'
            );
        }

        if (requestParameters['intoBranch'] == null) {
            throw new runtime.RequiredError(
                'intoBranch',
                'Required parameter "intoBranch" was null or undefined when calling getRouteBackportHelper().'
            );
        }

        if (requestParameters['packagesNames'] == null) {
            throw new runtime.RequiredError(
                'packagesNames',
                'Required parameter "packagesNames" was null or undefined when calling getRouteBackportHelper().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromBranch'] != null) {
            queryParameters['from_branch'] = requestParameters['fromBranch'];
        }

        if (requestParameters['intoBranch'] != null) {
            queryParameters['into_branch'] = requestParameters['intoBranch'];
        }

        if (requestParameters['packagesNames'] != null) {
            queryParameters['packages_names'] = requestParameters['packagesNames']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['dpType'] != null) {
            queryParameters['dp_type'] = requestParameters['dpType'];
        }

        if (requestParameters['archs'] != null) {
            queryParameters['archs'] = requestParameters['archs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/dependencies/backport_helper`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BackportHelperModelFromJSON));
    }

    /**
     * Find packages required to backport too
     */
    async getRouteBackportHelper(requestParameters: GetRouteBackportHelperRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BackportHelperModel>> {
        const response = await this.getRouteBackportHelperRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary package dependencies
     */
    async getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghashRaw(requestParameters: GetRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DependenciesPackageDependenciesModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/dependencies/binary_package_dependencies/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DependenciesPackageDependenciesModelFromJSON(jsonValue));
    }

    /**
     * Get binary package dependencies
     */
    async getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghash(requestParameters: GetRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DependenciesPackageDependenciesModel> {
        const response = await this.getRouteDependsBinPackageDependenciesBinaryPackageDependenciesIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get source package build dependencies
     */
    async getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghashRaw(requestParameters: GetRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DependenciesPackageBuildDependenciesModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['depth'] != null) {
            queryParameters['depth'] = requestParameters['depth'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/dependencies/source_package_dependencies/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DependenciesPackageBuildDependenciesModelFromJSON(jsonValue));
    }

    /**
     * Get source package build dependencies
     */
    async getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghash(requestParameters: GetRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DependenciesPackageBuildDependenciesModel> {
        const response = await this.getRouteDependsSrcPackageDependenciesSourcePackageDependenciesIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fast search for dependencies by name (case sensitive)         including partial occurrence.
     */
    async getRouteFastLookupDependenciesFastLookupRaw(requestParameters: GetRouteFastLookupDependenciesFastLookupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FastDependencySearchModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteFastLookupDependenciesFastLookup().'
            );
        }

        if (requestParameters['dpName'] == null) {
            throw new runtime.RequiredError(
                'dpName',
                'Required parameter "dpName" was null or undefined when calling getRouteFastLookupDependenciesFastLookup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['dpName'] != null) {
            queryParameters['dp_name'] = requestParameters['dpName'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/dependencies/fast_lookup`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FastDependencySearchModelFromJSON(jsonValue));
    }

    /**
     * Fast search for dependencies by name (case sensitive)         including partial occurrence.
     */
    async getRouteFastLookupDependenciesFastLookup(requestParameters: GetRouteFastLookupDependenciesFastLookupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FastDependencySearchModel> {
        const response = await this.getRouteFastLookupDependenciesFastLookupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get packages build dependencies by set of parameters
     */
    async getRoutePackageBuildDependencyDependenciesWhatDependsSrcRaw(requestParameters: GetRoutePackageBuildDependencyDependenciesWhatDependsSrcRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageBuildDependencyModel>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackageBuildDependencyDependenciesWhatDependsSrc().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageBuildDependencyDependenciesWhatDependsSrc().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['dpType'] != null) {
            queryParameters['dp_type'] = requestParameters['dpType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/dependencies/what_depends_src`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageBuildDependencyModelFromJSON(jsonValue));
    }

    /**
     * Get packages build dependencies by set of parameters
     */
    async getRoutePackageBuildDependencyDependenciesWhatDependsSrc(requestParameters: GetRoutePackageBuildDependencyDependenciesWhatDependsSrcRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageBuildDependencyModel> {
        const response = await this.getRoutePackageBuildDependencyDependenciesWhatDependsSrcRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary packages by dependency name and type
     */
    async getRoutePackageDependsDependenciesPackagesByDependencyRaw(requestParameters: GetRoutePackageDependsDependenciesPackagesByDependencyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DependenciesPackagesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageDependsDependenciesPackagesByDependency().'
            );
        }

        if (requestParameters['dpName'] == null) {
            throw new runtime.RequiredError(
                'dpName',
                'Required parameter "dpName" was null or undefined when calling getRoutePackageDependsDependenciesPackagesByDependency().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['dpName'] != null) {
            queryParameters['dp_name'] = requestParameters['dpName'];
        }

        if (requestParameters['dpType'] != null) {
            queryParameters['dp_type'] = requestParameters['dpType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/dependencies/packages_by_dependency`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DependenciesPackagesModelFromJSON(jsonValue));
    }

    /**
     * Get binary packages by dependency name and type
     */
    async getRoutePackageDependsDependenciesPackagesByDependency(requestParameters: GetRoutePackageDependsDependenciesPackagesByDependencyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DependenciesPackagesModel> {
        const response = await this.getRoutePackageDependsDependenciesPackagesByDependencyRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetRouteBackportHelperDpTypeEnum = {
    Both: 'both',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteBackportHelperDpTypeEnum = typeof GetRouteBackportHelperDpTypeEnum[keyof typeof GetRouteBackportHelperDpTypeEnum];
/**
 * @export
 */
export const GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum = {
    Both: 'both',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum = typeof GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum[keyof typeof GetRoutePackageBuildDependencyDependenciesWhatDependsSrcDpTypeEnum];
/**
 * @export
 */
export const GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum = {
    All: 'all',
    Provide: 'provide',
    Require: 'require',
    Conflict: 'conflict',
    Obsolete: 'obsolete'
} as const;
export type GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum = typeof GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum[keyof typeof GetRoutePackageDependsDependenciesPackagesByDependencyDpTypeEnum];
