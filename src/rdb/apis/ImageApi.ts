/* tslint:disable */
/* eslint-disable */
/**
 * ALTRepo API
 * altrepo API v1
 *
 * The version of the OpenAPI document: 1.19.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ActiveImagesModel,
  FindImagesByPackageModel,
  ImageAllISOModel,
  ImageInfoModel,
  ImageJSONModel,
  ImagePackageSetModel,
  ImagePackagesInspectRegularModel,
  ImagePackagesInspectSPModel,
  ImagePackagesJSONModel,
  ImagePackagesModel,
  ImageStatusGetModel,
  ImageTagJSONModel,
  ImageTagStatusGetModel,
  ImageTagUUIDModel,
  LastImagePackagesModel,
  SiteImageCategoriesModel,
} from '../models/index';
import {
    ActiveImagesModelFromJSON,
    ActiveImagesModelToJSON,
    FindImagesByPackageModelFromJSON,
    FindImagesByPackageModelToJSON,
    ImageAllISOModelFromJSON,
    ImageAllISOModelToJSON,
    ImageInfoModelFromJSON,
    ImageInfoModelToJSON,
    ImageJSONModelFromJSON,
    ImageJSONModelToJSON,
    ImagePackageSetModelFromJSON,
    ImagePackageSetModelToJSON,
    ImagePackagesInspectRegularModelFromJSON,
    ImagePackagesInspectRegularModelToJSON,
    ImagePackagesInspectSPModelFromJSON,
    ImagePackagesInspectSPModelToJSON,
    ImagePackagesJSONModelFromJSON,
    ImagePackagesJSONModelToJSON,
    ImagePackagesModelFromJSON,
    ImagePackagesModelToJSON,
    ImageStatusGetModelFromJSON,
    ImageStatusGetModelToJSON,
    ImageTagJSONModelFromJSON,
    ImageTagJSONModelToJSON,
    ImageTagStatusGetModelFromJSON,
    ImageTagStatusGetModelToJSON,
    ImageTagUUIDModelFromJSON,
    ImageTagUUIDModelToJSON,
    LastImagePackagesModelFromJSON,
    LastImagePackagesModelToJSON,
    SiteImageCategoriesModelFromJSON,
    SiteImageCategoriesModelToJSON,
} from '../models/index';

export interface GetRouteActiveImagesImageActiveImagesRequest {
    branch?: string;
    edition?: string;
    version?: string;
    release?: string;
    variant?: string;
    type?: string;
}

export interface GetRouteFindImagesByPackageImageFindImagesByPackageNameRequest {
    pkgName: string;
    branch?: string;
    edition?: string;
    pkgType?: GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum;
    imgShow?: GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum;
}

export interface GetRouteImageCategoriesCountImageImageCategoriesCountRequest {
    uuid: string;
    component?: string;
}

export interface GetRouteImageInfoImageImageInfoRequest {
    branch?: string;
    edition?: string;
    version?: string;
    release?: string;
    variant?: string;
    flavor?: string;
    arch?: string;
    component?: string;
    platform?: string;
    type?: string;
}

export interface GetRouteImagePackagesImageImagePackagesRequest {
    uuid: string;
    group?: string;
    component?: string;
}

export interface GetRouteImageTagStatusRequest {
    branch?: string;
    edition?: string;
}

export interface GetRouteImageTagUuidImageImageUuidByTagRequest {
    tag: string;
}

export interface GetRouteLastImagePackagesImageLastPackagesByImageRequest {
    branch: string;
    uuid: string;
    packagesLimit?: number;
    component?: string;
}

export interface GetRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixedRequest {
    branch: string;
    uuid: string;
    packagesLimit?: number;
    component?: string;
}

export interface PostRouteCheckPackagesRegularImageInspectRegularRequest {
    payload: ImagePackagesJSONModel;
}

export interface PostRouteCheckPackagesSpImageInspectSpRequest {
    payload: ImagePackagesJSONModel;
}

export interface PostRouteImageStatusRequest {
    payload: ImageJSONModel;
}

export interface PostRouteImageTagStatusRequest {
    payload: ImageTagJSONModel;
}

/**
 * 
 */
export class ImageApi extends runtime.BaseAPI {

    /**
     * Get active images for a given repository
     */
    async getRouteActiveImagesImageActiveImagesRaw(requestParameters: GetRouteActiveImagesImageActiveImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ActiveImagesModel>> {
        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['edition'] != null) {
            queryParameters['edition'] = requestParameters['edition'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        if (requestParameters['release'] != null) {
            queryParameters['release'] = requestParameters['release'];
        }

        if (requestParameters['variant'] != null) {
            queryParameters['variant'] = requestParameters['variant'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/active_images`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ActiveImagesModelFromJSON(jsonValue));
    }

    /**
     * Get active images for a given repository
     */
    async getRouteActiveImagesImageActiveImages(requestParameters: GetRouteActiveImagesImageActiveImagesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ActiveImagesModel> {
        const response = await this.getRouteActiveImagesImageActiveImagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all ISO images
     */
    async getRouteAllIsoImagesImageIsoAllImagesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageAllISOModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/iso/all_images`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageAllISOModelFromJSON(jsonValue));
    }

    /**
     * Get all ISO images
     */
    async getRouteAllIsoImagesImageIsoAllImages(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageAllISOModel> {
        const response = await this.getRouteAllIsoImagesImageIsoAllImagesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get images by package name for a given repository and edition
     */
    async getRouteFindImagesByPackageImageFindImagesByPackageNameRaw(requestParameters: GetRouteFindImagesByPackageImageFindImagesByPackageNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindImagesByPackageModel>> {
        if (requestParameters['pkgName'] == null) {
            throw new runtime.RequiredError(
                'pkgName',
                'Required parameter "pkgName" was null or undefined when calling getRouteFindImagesByPackageImageFindImagesByPackageName().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['pkgName'] != null) {
            queryParameters['pkg_name'] = requestParameters['pkgName'];
        }

        if (requestParameters['edition'] != null) {
            queryParameters['edition'] = requestParameters['edition'];
        }

        if (requestParameters['pkgType'] != null) {
            queryParameters['pkg_type'] = requestParameters['pkgType'];
        }

        if (requestParameters['imgShow'] != null) {
            queryParameters['img_show'] = requestParameters['imgShow'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/find_images_by_package_name`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FindImagesByPackageModelFromJSON(jsonValue));
    }

    /**
     * Get images by package name for a given repository and edition
     */
    async getRouteFindImagesByPackageImageFindImagesByPackageName(requestParameters: GetRouteFindImagesByPackageImageFindImagesByPackageNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindImagesByPackageModel> {
        const response = await this.getRouteFindImagesByPackageImageFindImagesByPackageNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of package categories with count for image
     */
    async getRouteImageCategoriesCountImageImageCategoriesCountRaw(requestParameters: GetRouteImageCategoriesCountImageImageCategoriesCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteImageCategoriesModel>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling getRouteImageCategoriesCountImageImageCategoriesCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['uuid'] != null) {
            queryParameters['uuid'] = requestParameters['uuid'];
        }

        if (requestParameters['component'] != null) {
            queryParameters['component'] = requestParameters['component'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/image_categories_count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteImageCategoriesModelFromJSON(jsonValue));
    }

    /**
     * Get list of package categories with count for image
     */
    async getRouteImageCategoriesCountImageImageCategoriesCount(requestParameters: GetRouteImageCategoriesCountImageImageCategoriesCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteImageCategoriesModel> {
        const response = await this.getRouteImageCategoriesCountImageImageCategoriesCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get branch images info
     */
    async getRouteImageInfoImageImageInfoRaw(requestParameters: GetRouteImageInfoImageImageInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageInfoModel>> {
        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['edition'] != null) {
            queryParameters['edition'] = requestParameters['edition'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        if (requestParameters['release'] != null) {
            queryParameters['release'] = requestParameters['release'];
        }

        if (requestParameters['variant'] != null) {
            queryParameters['variant'] = requestParameters['variant'];
        }

        if (requestParameters['flavor'] != null) {
            queryParameters['flavor'] = requestParameters['flavor'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        if (requestParameters['component'] != null) {
            queryParameters['component'] = requestParameters['component'];
        }

        if (requestParameters['platform'] != null) {
            queryParameters['platform'] = requestParameters['platform'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/image_info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageInfoModelFromJSON(jsonValue));
    }

    /**
     * Get branch images info
     */
    async getRouteImageInfoImageImageInfo(requestParameters: GetRouteImageInfoImageImageInfoRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageInfoModel> {
        const response = await this.getRouteImageInfoImageImageInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of package sets which has an active images.
     */
    async getRouteImagePackageSetImageImagePackagesetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagePackageSetModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/image_packageset`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagePackageSetModelFromJSON(jsonValue));
    }

    /**
     * Get a list of package sets which has an active images.
     */
    async getRouteImagePackageSetImageImagePackageset(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagePackageSetModel> {
        const response = await this.getRouteImagePackageSetImageImagePackagesetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get list of image packages in accordance to given parameters
     */
    async getRouteImagePackagesImageImagePackagesRaw(requestParameters: GetRouteImagePackagesImageImagePackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagePackagesModel>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling getRouteImagePackagesImageImagePackages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['uuid'] != null) {
            queryParameters['uuid'] = requestParameters['uuid'];
        }

        if (requestParameters['group'] != null) {
            queryParameters['group'] = requestParameters['group'];
        }

        if (requestParameters['component'] != null) {
            queryParameters['component'] = requestParameters['component'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/image_packages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagePackagesModelFromJSON(jsonValue));
    }

    /**
     * Get list of image packages in accordance to given parameters
     */
    async getRouteImagePackagesImageImagePackages(requestParameters: GetRouteImagePackagesImageImagePackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagePackagesModel> {
        const response = await this.getRouteImagePackagesImageImagePackagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get image status into database
     */
    async getRouteImageStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageStatusGetModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/image_status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageStatusGetModelFromJSON(jsonValue));
    }

    /**
     * Get image status into database
     */
    async getRouteImageStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageStatusGetModel> {
        const response = await this.getRouteImageStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get iso image status into database
     */
    async getRouteImageTagStatusRaw(requestParameters: GetRouteImageTagStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageTagStatusGetModel>> {
        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['edition'] != null) {
            queryParameters['edition'] = requestParameters['edition'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/image_tag_status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageTagStatusGetModelFromJSON(jsonValue));
    }

    /**
     * Get iso image status into database
     */
    async getRouteImageTagStatus(requestParameters: GetRouteImageTagStatusRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageTagStatusGetModel> {
        const response = await this.getRouteImageTagStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get image UUID by image tag
     */
    async getRouteImageTagUuidImageImageUuidByTagRaw(requestParameters: GetRouteImageTagUuidImageImageUuidByTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageTagUUIDModel>> {
        if (requestParameters['tag'] == null) {
            throw new runtime.RequiredError(
                'tag',
                'Required parameter "tag" was null or undefined when calling getRouteImageTagUuidImageImageUuidByTag().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['tag'] != null) {
            queryParameters['tag'] = requestParameters['tag'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/image_uuid_by_tag`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageTagUUIDModelFromJSON(jsonValue));
    }

    /**
     * Get image UUID by image tag
     */
    async getRouteImageTagUuidImageImageUuidByTag(requestParameters: GetRouteImageTagUuidImageImageUuidByTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageTagUUIDModel> {
        const response = await this.getRouteImageTagUuidImageImageUuidByTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of last packages from image for given parameters
     */
    async getRouteLastImagePackagesImageLastPackagesByImageRaw(requestParameters: GetRouteLastImagePackagesImageLastPackagesByImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LastImagePackagesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteLastImagePackagesImageLastPackagesByImage().'
            );
        }

        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling getRouteLastImagePackagesImageLastPackagesByImage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['uuid'] != null) {
            queryParameters['uuid'] = requestParameters['uuid'];
        }

        if (requestParameters['packagesLimit'] != null) {
            queryParameters['packages_limit'] = requestParameters['packagesLimit'];
        }

        if (requestParameters['component'] != null) {
            queryParameters['component'] = requestParameters['component'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/last_packages_by_image`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LastImagePackagesModelFromJSON(jsonValue));
    }

    /**
     * Get list of last packages from image for given parameters
     */
    async getRouteLastImagePackagesImageLastPackagesByImage(requestParameters: GetRouteLastImagePackagesImageLastPackagesByImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LastImagePackagesModel> {
        const response = await this.getRouteLastImagePackagesImageLastPackagesByImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about last packages with CVE fixes mentioned in changelog for given image
     */
    async getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixedRaw(requestParameters: GetRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LastImagePackagesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed().'
            );
        }

        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['uuid'] != null) {
            queryParameters['uuid'] = requestParameters['uuid'];
        }

        if (requestParameters['packagesLimit'] != null) {
            queryParameters['packages_limit'] = requestParameters['packagesLimit'];
        }

        if (requestParameters['component'] != null) {
            queryParameters['component'] = requestParameters['component'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/image/last_packages_image_with_cve_fixed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LastImagePackagesModelFromJSON(jsonValue));
    }

    /**
     * Get information about last packages with CVE fixes mentioned in changelog for given image
     */
    async getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixed(requestParameters: GetRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LastImagePackagesModel> {
        const response = await this.getRouteLastImagePackagesWithCveFixImageLastPackagesImageWithCveFixedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inspect binary packages from regular distribution image
     */
    async postRouteCheckPackagesRegularImageInspectRegularRaw(requestParameters: PostRouteCheckPackagesRegularImageInspectRegularRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagePackagesInspectRegularModel>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling postRouteCheckPackagesRegularImageInspectRegular().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/image/inspect/regular`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImagePackagesJSONModelToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagePackagesInspectRegularModelFromJSON(jsonValue));
    }

    /**
     * Inspect binary packages from regular distribution image
     */
    async postRouteCheckPackagesRegularImageInspectRegular(requestParameters: PostRouteCheckPackagesRegularImageInspectRegularRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagePackagesInspectRegularModel> {
        const response = await this.postRouteCheckPackagesRegularImageInspectRegularRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inspect binary packages from SP distribution image
     */
    async postRouteCheckPackagesSpImageInspectSpRaw(requestParameters: PostRouteCheckPackagesSpImageInspectSpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagePackagesInspectSPModel>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling postRouteCheckPackagesSpImageInspectSp().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/image/inspect/sp`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImagePackagesJSONModelToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagePackagesInspectSPModelFromJSON(jsonValue));
    }

    /**
     * Inspect binary packages from SP distribution image
     */
    async postRouteCheckPackagesSpImageInspectSp(requestParameters: PostRouteCheckPackagesSpImageInspectSpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagePackagesInspectSPModel> {
        const response = await this.postRouteCheckPackagesSpImageInspectSpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load image status into database
     */
    async postRouteImageStatusRaw(requestParameters: PostRouteImageStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling postRouteImageStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/image/image_status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImageJSONModelToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Load image status into database
     */
    async postRouteImageStatus(requestParameters: PostRouteImageStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postRouteImageStatusRaw(requestParameters, initOverrides);
    }

    /**
     * Load iso image status into database
     */
    async postRouteImageTagStatusRaw(requestParameters: PostRouteImageTagStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling postRouteImageTagStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/image/image_tag_status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImageTagJSONModelToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Load iso image status into database
     */
    async postRouteImageTagStatus(requestParameters: PostRouteImageTagStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postRouteImageTagStatusRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum = typeof GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum[keyof typeof GetRouteFindImagesByPackageImageFindImagesByPackageNamePkgTypeEnum];
/**
 * @export
 */
export const GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum = {
    Active: 'active',
    All: 'all'
} as const;
export type GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum = typeof GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum[keyof typeof GetRouteFindImagesByPackageImageFindImagesByPackageNameImgShowEnum];
