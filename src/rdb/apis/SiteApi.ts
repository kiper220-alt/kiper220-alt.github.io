/* tslint:disable */
/* eslint-disable */
/**
 * ALTRepo API
 * altrepo API v1
 *
 * The version of the OpenAPI document: 1.19.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AllMaintainersModel,
  BinPackageLogElementModel,
  FindSourcePackageInBranch,
  MaintainerBranchesModel,
  MaintainerInfoModel,
  MaintainerPackagesModel,
  PackageMisconflictBySrcModel,
  PackageNVRByHashModel,
  PackageNameFromRepologyModel,
  RepocopByMaintainerModel,
  SItePackagesVersionsFromTasksModel,
  SiteAllArchsModel,
  SiteAllPackagasetsModel,
  SiteAllPackagesetsSummaryModel,
  SiteBeehiveByMaintainerModel,
  SiteBinPackageScriptsModel,
  SiteBriefPackageInfoModel,
  SiteChangelogModel,
  SiteDeletedPackageModel,
  SiteFastPackagesSearchModel,
  SiteFingPackagesModel,
  SiteImagePackageVersionsModel,
  SiteLastBranchPackagesModel,
  SiteLastPackagesModel,
  SiteLastPackagesWithCVEFixesModel,
  SitePackageInfoModel,
  SitePackagesBinaryListModel,
  SitePackagesDownloadsModel,
  SitePackagesModel,
  SitePackagesetCategoriesModel,
  SitePackagesetPackageHashByNameVersionRelease,
  SitePackagesetPackageHashModel,
  SitePackagesetsByHashModel,
  SitePackagesetsSummaryStatusModel,
  SiteSourcePackagesVersionsModel,
  SiteTaskByNameModel,
  SiteTasksHistoryModel,
  SiteWatchByMaintainerModel,
} from '../models/index';
import {
    AllMaintainersModelFromJSON,
    AllMaintainersModelToJSON,
    BinPackageLogElementModelFromJSON,
    BinPackageLogElementModelToJSON,
    FindSourcePackageInBranchFromJSON,
    FindSourcePackageInBranchToJSON,
    MaintainerBranchesModelFromJSON,
    MaintainerBranchesModelToJSON,
    MaintainerInfoModelFromJSON,
    MaintainerInfoModelToJSON,
    MaintainerPackagesModelFromJSON,
    MaintainerPackagesModelToJSON,
    PackageMisconflictBySrcModelFromJSON,
    PackageMisconflictBySrcModelToJSON,
    PackageNVRByHashModelFromJSON,
    PackageNVRByHashModelToJSON,
    PackageNameFromRepologyModelFromJSON,
    PackageNameFromRepologyModelToJSON,
    RepocopByMaintainerModelFromJSON,
    RepocopByMaintainerModelToJSON,
    SItePackagesVersionsFromTasksModelFromJSON,
    SItePackagesVersionsFromTasksModelToJSON,
    SiteAllArchsModelFromJSON,
    SiteAllArchsModelToJSON,
    SiteAllPackagasetsModelFromJSON,
    SiteAllPackagasetsModelToJSON,
    SiteAllPackagesetsSummaryModelFromJSON,
    SiteAllPackagesetsSummaryModelToJSON,
    SiteBeehiveByMaintainerModelFromJSON,
    SiteBeehiveByMaintainerModelToJSON,
    SiteBinPackageScriptsModelFromJSON,
    SiteBinPackageScriptsModelToJSON,
    SiteBriefPackageInfoModelFromJSON,
    SiteBriefPackageInfoModelToJSON,
    SiteChangelogModelFromJSON,
    SiteChangelogModelToJSON,
    SiteDeletedPackageModelFromJSON,
    SiteDeletedPackageModelToJSON,
    SiteFastPackagesSearchModelFromJSON,
    SiteFastPackagesSearchModelToJSON,
    SiteFingPackagesModelFromJSON,
    SiteFingPackagesModelToJSON,
    SiteImagePackageVersionsModelFromJSON,
    SiteImagePackageVersionsModelToJSON,
    SiteLastBranchPackagesModelFromJSON,
    SiteLastBranchPackagesModelToJSON,
    SiteLastPackagesModelFromJSON,
    SiteLastPackagesModelToJSON,
    SiteLastPackagesWithCVEFixesModelFromJSON,
    SiteLastPackagesWithCVEFixesModelToJSON,
    SitePackageInfoModelFromJSON,
    SitePackageInfoModelToJSON,
    SitePackagesBinaryListModelFromJSON,
    SitePackagesBinaryListModelToJSON,
    SitePackagesDownloadsModelFromJSON,
    SitePackagesDownloadsModelToJSON,
    SitePackagesModelFromJSON,
    SitePackagesModelToJSON,
    SitePackagesetCategoriesModelFromJSON,
    SitePackagesetCategoriesModelToJSON,
    SitePackagesetPackageHashByNameVersionReleaseFromJSON,
    SitePackagesetPackageHashByNameVersionReleaseToJSON,
    SitePackagesetPackageHashModelFromJSON,
    SitePackagesetPackageHashModelToJSON,
    SitePackagesetsByHashModelFromJSON,
    SitePackagesetsByHashModelToJSON,
    SitePackagesetsSummaryStatusModelFromJSON,
    SitePackagesetsSummaryStatusModelToJSON,
    SiteSourcePackagesVersionsModelFromJSON,
    SiteSourcePackagesVersionsModelToJSON,
    SiteTaskByNameModelFromJSON,
    SiteTaskByNameModelToJSON,
    SiteTasksHistoryModelFromJSON,
    SiteTasksHistoryModelToJSON,
    SiteWatchByMaintainerModelFromJSON,
    SiteWatchByMaintainerModelToJSON,
} from '../models/index';

export interface GetRouteAllPackagesetArchsSiteAllPkgsetArchsRequest {
    branch: string;
}

export interface GetRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCountRequest {
    branch: string;
}

export interface GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerRequest {
    branch: string;
    maintainerNickname: string;
    byAcl?: GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum;
}

export interface GetRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghashRequest {
    pkghash: number;
}

export interface GetRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghashRequest {
    pkghash: number;
    branch: string;
    arch: string;
}

export interface GetRouteBinaryPackageLogSitePackageLogBinIntPkghashRequest {
    pkghash: number;
}

export interface GetRouteBriefPackageInfoSitePackageInfoBriefIntPkghashRequest {
    pkghash: number;
}

export interface GetRouteDeletedPackageInfoSiteDeletedPackageInfoRequest {
    branch: string;
    name: string;
    packageType?: GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum;
    arch?: string;
}

export interface GetRouteFindSourcePackageSiteFindSourcePackageRequest {
    branch: string;
    name: string;
}

export interface GetRouteLastBranchPackagesSiteLastPackagesByBranchRequest {
    branch: string;
    packagesLimit: number;
    packager?: string;
}

export interface GetRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixedRequest {
    branch: string;
}

export interface GetRouteLastTaskPackagesSiteLastPackagesRequest {
    branch: string;
    tasksLimit: number;
    taskOwner?: string;
}

export interface GetRouteLastTaskPackagesSiteLastPackagesByTasksRequest {
    branch: string;
    tasksLimit: number;
    taskOwner?: string;
}

export interface GetRouteMaintainerBranchesSiteMaintainerBranchesRequest {
    maintainerNickname: string;
}

export interface GetRouteMaintainerPackagesSiteMaintainerPackagesRequest {
    branch: string;
    maintainerNickname: string;
    byAcl?: GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum;
}

export interface GetRouteMaintainersAllRequest {
    branch: string;
}

export interface GetRouteMaintainersAllSiteAllMaintainersRequest {
    branch: string;
}

export interface GetRouteMaintainersInfoSiteMaintainerInfoRequest {
    branch: string;
    maintainerNickname: string;
}

export interface GetRoutePackageChangelogSitePackageChangelogIntPkghashRequest {
    pkghash: number;
    changelogLast?: number;
}

export interface GetRoutePackageDownloadLinksSitePackageDownloadsIntPkghashRequest {
    pkghash: number;
    branch: string;
}

export interface GetRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghashRequest {
    pkghash: number;
    branch: string;
}

export interface GetRoutePackageInfoSitePackageInfoIntPkghashRequest {
    pkghash: number;
    branch: string;
    changelogLast?: number;
    packageType?: GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum;
}

export interface GetRoutePackageMisconflictSitePackageMisconflictIntPkghashRequest {
    pkghash: number;
    branch: string;
}

export interface GetRoutePackageNameFromRepologySitePackageNameFromRepologyRequest {
    branch: string;
    name: string;
}

export interface GetRoutePackageNvrByHashSitePackageNvrByHashIntPkghashRequest {
    pkghash: number;
    name?: string;
}

export interface GetRoutePackageVersionsFromImagesSitePackageVersionsFromImagesRequest {
    name: string;
    branch: string;
    edition: string;
    type: string;
}

export interface GetRoutePackageVersionsFromTasksSitePackageVersionsFromTasksRequest {
    name: string;
    branch?: string;
}

export interface GetRoutePackageVersionsSitePackageVersionsRequest {
    name: string;
    packageType?: GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum;
    arch?: string;
}

export interface GetRoutePackagesBinaryListSiteBinaryPackageArchsAndVersionsRequest {
    branch: string;
    name: string;
}

export interface GetRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookupRequest {
    name: Array<string>;
    branch?: string;
}

export interface GetRoutePackagesetFindPackagesSiteFindPackagesRequest {
    name: Array<string>;
    branch?: string;
    arch?: string;
}

export interface GetRoutePackagesetPackageBinaryHashSitePkghashByBinaryNameRequest {
    branch: string;
    name: string;
    arch: string;
}

export interface GetRoutePackagesetPackageHashSitePkghashByNameRequest {
    branch: string;
    name: string;
}

export interface GetRoutePackagesetPackagesSiteRepositoryPackagesRequest {
    branch: string;
    packageType?: GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum;
    group?: string;
    buildtime?: number;
}

export interface GetRoutePackagesetPkghashByNvrSitePkghashByNvrRequest {
    name: string;
    branch: string;
    version: string;
    release: string;
}

export interface GetRoutePackagsetsByHashSitePackagesetsByHashIntPkghashRequest {
    pkghash: number;
}

export interface GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountRequest {
    branch: string;
    packageType?: GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum;
}

export interface GetRouteRepocopByMaintainerSiteRepocopByMaintainerRequest {
    branch: string;
    maintainerNickname: string;
    byAcl?: GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum;
}

export interface GetRouteSourcePackageVersionsSiteSourcePackageVersionsRequest {
    name: string;
}

export interface GetRouteTasksByMaintainerSiteTasksByMaintainerRequest {
    branch: string;
    maintainerNickname: string;
}

export interface GetRouteTasksByPackageSiteTasksByPackageRequest {
    name: string;
}

export interface GetRouteTasksHistorySiteTasksHistoryRequest {
    taskId?: number;
}

export interface GetRouteWatchByMaintainerSiteWatchByMaintainerRequest {
    maintainerNickname: string;
    byAcl?: GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum;
}

/**
 * 
 */
export class SiteApi extends runtime.BaseAPI {

    /**
     * Get binary package archs list
     */
    async getRouteAllPackagesetArchsSiteAllPkgsetArchsRaw(requestParameters: GetRouteAllPackagesetArchsSiteAllPkgsetArchsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteAllArchsModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteAllPackagesetArchsSiteAllPkgsetArchs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/all_pkgset_archs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteAllArchsModelFromJSON(jsonValue));
    }

    /**
     * Get binary package archs list
     */
    async getRouteAllPackagesetArchsSiteAllPkgsetArchs(requestParameters: GetRouteAllPackagesetArchsSiteAllPkgsetArchsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteAllArchsModel> {
        const response = await this.getRouteAllPackagesetArchsSiteAllPkgsetArchsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary package archs list with source packages count
     */
    async getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCountRaw(requestParameters: GetRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteAllArchsModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/all_pkgset_archs_with_src_count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteAllArchsModelFromJSON(jsonValue));
    }

    /**
     * Get binary package archs list with source packages count
     */
    async getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCount(requestParameters: GetRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteAllArchsModel> {
        const response = await this.getRouteAllPackagesetArchsSourceCountSiteAllPkgsetArchsWithSrcCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get package sets list
     */
    async getRouteAllPackagesetsSiteAllPkgsetsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteAllPackagasetsModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/all_pkgsets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteAllPackagasetsModelFromJSON(jsonValue));
    }

    /**
     * Get package sets list
     */
    async getRouteAllPackagesetsSiteAllPkgsets(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteAllPackagasetsModel> {
        const response = await this.getRouteAllPackagesetsSiteAllPkgsetsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get package sets list with source packages count
     */
    async getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCountRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteAllPackagasetsModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/all_pkgsets_with_src_count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteAllPackagasetsModelFromJSON(jsonValue));
    }

    /**
     * Get package sets list with source packages count
     */
    async getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCount(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteAllPackagasetsModel> {
        const response = await this.getRouteAllPackagesetsSourceCountSiteAllPkgsetsWithSrcCountRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get package sets list with source packages count
     */
    async getRouteAllPackagesetsSummarySiteAllPkgsetsSummaryRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteAllPackagesetsSummaryModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/all_pkgsets_summary`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteAllPackagesetsSummaryModelFromJSON(jsonValue));
    }

    /**
     * Get package sets list with source packages count
     */
    async getRouteAllPackagesetsSummarySiteAllPkgsetsSummary(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteAllPackagesetsSummaryModel> {
        const response = await this.getRouteAllPackagesetsSummarySiteAllPkgsetsSummaryRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get Beehive rebuild errors by the maintainer\'s nickname
     */
    async getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerRaw(requestParameters: GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SiteBeehiveByMaintainerModel>>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer().'
            );
        }

        if (requestParameters['maintainerNickname'] == null) {
            throw new runtime.RequiredError(
                'maintainerNickname',
                'Required parameter "maintainerNickname" was null or undefined when calling getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['maintainerNickname'] != null) {
            queryParameters['maintainer_nickname'] = requestParameters['maintainerNickname'];
        }

        if (requestParameters['byAcl'] != null) {
            queryParameters['by_acl'] = requestParameters['byAcl'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/beehive_errors_by_maintainer`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SiteBeehiveByMaintainerModelFromJSON));
    }

    /**
     * Get Beehive rebuild errors by the maintainer\'s nickname
     */
    async getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainer(requestParameters: GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SiteBeehiveByMaintainerModel>> {
        const response = await this.getRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary package scripts
     */
    async getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghashRaw(requestParameters: GetRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteBinPackageScriptsModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/binary_package_scripts/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteBinPackageScriptsModelFromJSON(jsonValue));
    }

    /**
     * Get binary package scripts
     */
    async getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghash(requestParameters: GetRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteBinPackageScriptsModel> {
        const response = await this.getRouteBinPackageScriptsSiteBinaryPackageScriptsIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary package download link
     */
    async getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghashRaw(requestParameters: GetRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesDownloadsModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash().'
            );
        }

        if (requestParameters['arch'] == null) {
            throw new runtime.RequiredError(
                'arch',
                'Required parameter "arch" was null or undefined when calling getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_downloads_bin/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesDownloadsModelFromJSON(jsonValue));
    }

    /**
     * Get binary package download link
     */
    async getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghash(requestParameters: GetRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesDownloadsModel> {
        const response = await this.getRouteBinaryPackageDownloadLinksSitePackageDownloadsBinIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary package build log link
     */
    async getRouteBinaryPackageLogSitePackageLogBinIntPkghashRaw(requestParameters: GetRouteBinaryPackageLogSitePackageLogBinIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BinPackageLogElementModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRouteBinaryPackageLogSitePackageLogBinIntPkghash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_log_bin/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BinPackageLogElementModelFromJSON(jsonValue));
    }

    /**
     * Get binary package build log link
     */
    async getRouteBinaryPackageLogSitePackageLogBinIntPkghash(requestParameters: GetRouteBinaryPackageLogSitePackageLogBinIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BinPackageLogElementModel> {
        const response = await this.getRouteBinaryPackageLogSitePackageLogBinIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get brief package info by hash
     */
    async getRouteBriefPackageInfoSitePackageInfoBriefIntPkghashRaw(requestParameters: GetRouteBriefPackageInfoSitePackageInfoBriefIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteBriefPackageInfoModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_info_brief/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteBriefPackageInfoModelFromJSON(jsonValue));
    }

    /**
     * Get brief package info by hash
     */
    async getRouteBriefPackageInfoSitePackageInfoBriefIntPkghash(requestParameters: GetRouteBriefPackageInfoSitePackageInfoBriefIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteBriefPackageInfoModel> {
        const response = await this.getRouteBriefPackageInfoSitePackageInfoBriefIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about package deleted from branch
     */
    async getRouteDeletedPackageInfoSiteDeletedPackageInfoRaw(requestParameters: GetRouteDeletedPackageInfoSiteDeletedPackageInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteDeletedPackageModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteDeletedPackageInfoSiteDeletedPackageInfo().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRouteDeletedPackageInfoSiteDeletedPackageInfo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['packageType'] != null) {
            queryParameters['package_type'] = requestParameters['packageType'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/deleted_package_info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteDeletedPackageModelFromJSON(jsonValue));
    }

    /**
     * Get information about package deleted from branch
     */
    async getRouteDeletedPackageInfoSiteDeletedPackageInfo(requestParameters: GetRouteDeletedPackageInfoSiteDeletedPackageInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteDeletedPackageModel> {
        const response = await this.getRouteDeletedPackageInfoSiteDeletedPackageInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find source package in branch by binary package name
     */
    async getRouteFindSourcePackageSiteFindSourcePackageRaw(requestParameters: GetRouteFindSourcePackageSiteFindSourcePackageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindSourcePackageInBranch>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteFindSourcePackageSiteFindSourcePackage().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRouteFindSourcePackageSiteFindSourcePackage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/find_source_package`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FindSourcePackageInBranchFromJSON(jsonValue));
    }

    /**
     * Find source package in branch by binary package name
     */
    async getRouteFindSourcePackageSiteFindSourcePackage(requestParameters: GetRouteFindSourcePackageSiteFindSourcePackageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindSourcePackageInBranch> {
        const response = await this.getRouteFindSourcePackageSiteFindSourcePackageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of last packages from branch for given parameters
     */
    async getRouteLastBranchPackagesSiteLastPackagesByBranchRaw(requestParameters: GetRouteLastBranchPackagesSiteLastPackagesByBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteLastBranchPackagesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteLastBranchPackagesSiteLastPackagesByBranch().'
            );
        }

        if (requestParameters['packagesLimit'] == null) {
            throw new runtime.RequiredError(
                'packagesLimit',
                'Required parameter "packagesLimit" was null or undefined when calling getRouteLastBranchPackagesSiteLastPackagesByBranch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['packagesLimit'] != null) {
            queryParameters['packages_limit'] = requestParameters['packagesLimit'];
        }

        if (requestParameters['packager'] != null) {
            queryParameters['packager'] = requestParameters['packager'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/last_packages_by_branch`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteLastBranchPackagesModelFromJSON(jsonValue));
    }

    /**
     * Get list of last packages from branch for given parameters
     */
    async getRouteLastBranchPackagesSiteLastPackagesByBranch(requestParameters: GetRouteLastBranchPackagesSiteLastPackagesByBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteLastBranchPackagesModel> {
        const response = await this.getRouteLastBranchPackagesSiteLastPackagesByBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about last packages with CVE fixes mentioned in changelog
     */
    async getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixedRaw(requestParameters: GetRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteLastPackagesWithCVEFixesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/last_packages_with_cve_fixed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteLastPackagesWithCVEFixesModelFromJSON(jsonValue));
    }

    /**
     * Get information about last packages with CVE fixes mentioned in changelog
     */
    async getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixed(requestParameters: GetRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteLastPackagesWithCVEFixesModel> {
        const response = await this.getRouteLastPackagesWithCveFixSiteLastPackagesWithCveFixedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of last packages from tasks for given parameters
     */
    async getRouteLastTaskPackagesSiteLastPackagesRaw(requestParameters: GetRouteLastTaskPackagesSiteLastPackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteLastPackagesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteLastTaskPackagesSiteLastPackages().'
            );
        }

        if (requestParameters['tasksLimit'] == null) {
            throw new runtime.RequiredError(
                'tasksLimit',
                'Required parameter "tasksLimit" was null or undefined when calling getRouteLastTaskPackagesSiteLastPackages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['tasksLimit'] != null) {
            queryParameters['tasks_limit'] = requestParameters['tasksLimit'];
        }

        if (requestParameters['taskOwner'] != null) {
            queryParameters['task_owner'] = requestParameters['taskOwner'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/last_packages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteLastPackagesModelFromJSON(jsonValue));
    }

    /**
     * Get list of last packages from tasks for given parameters
     */
    async getRouteLastTaskPackagesSiteLastPackages(requestParameters: GetRouteLastTaskPackagesSiteLastPackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteLastPackagesModel> {
        const response = await this.getRouteLastTaskPackagesSiteLastPackagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of last packages from tasks for given parameters
     */
    async getRouteLastTaskPackagesSiteLastPackagesByTasksRaw(requestParameters: GetRouteLastTaskPackagesSiteLastPackagesByTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteLastPackagesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteLastTaskPackagesSiteLastPackagesByTasks().'
            );
        }

        if (requestParameters['tasksLimit'] == null) {
            throw new runtime.RequiredError(
                'tasksLimit',
                'Required parameter "tasksLimit" was null or undefined when calling getRouteLastTaskPackagesSiteLastPackagesByTasks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['tasksLimit'] != null) {
            queryParameters['tasks_limit'] = requestParameters['tasksLimit'];
        }

        if (requestParameters['taskOwner'] != null) {
            queryParameters['task_owner'] = requestParameters['taskOwner'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/last_packages_by_tasks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteLastPackagesModelFromJSON(jsonValue));
    }

    /**
     * Get list of last packages from tasks for given parameters
     */
    async getRouteLastTaskPackagesSiteLastPackagesByTasks(requestParameters: GetRouteLastTaskPackagesSiteLastPackagesByTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteLastPackagesModel> {
        const response = await this.getRouteLastTaskPackagesSiteLastPackagesByTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Packages collected by the specified maintainer
     */
    async getRouteMaintainerBranchesSiteMaintainerBranchesRaw(requestParameters: GetRouteMaintainerBranchesSiteMaintainerBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MaintainerBranchesModel>>> {
        if (requestParameters['maintainerNickname'] == null) {
            throw new runtime.RequiredError(
                'maintainerNickname',
                'Required parameter "maintainerNickname" was null or undefined when calling getRouteMaintainerBranchesSiteMaintainerBranches().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['maintainerNickname'] != null) {
            queryParameters['maintainer_nickname'] = requestParameters['maintainerNickname'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/maintainer_branches`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MaintainerBranchesModelFromJSON));
    }

    /**
     * Packages collected by the specified maintainer
     */
    async getRouteMaintainerBranchesSiteMaintainerBranches(requestParameters: GetRouteMaintainerBranchesSiteMaintainerBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MaintainerBranchesModel>> {
        const response = await this.getRouteMaintainerBranchesSiteMaintainerBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Packages collected by the specified maintainer
     */
    async getRouteMaintainerPackagesSiteMaintainerPackagesRaw(requestParameters: GetRouteMaintainerPackagesSiteMaintainerPackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MaintainerPackagesModel>>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteMaintainerPackagesSiteMaintainerPackages().'
            );
        }

        if (requestParameters['maintainerNickname'] == null) {
            throw new runtime.RequiredError(
                'maintainerNickname',
                'Required parameter "maintainerNickname" was null or undefined when calling getRouteMaintainerPackagesSiteMaintainerPackages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['maintainerNickname'] != null) {
            queryParameters['maintainer_nickname'] = requestParameters['maintainerNickname'];
        }

        if (requestParameters['byAcl'] != null) {
            queryParameters['by_acl'] = requestParameters['byAcl'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/maintainer_packages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MaintainerPackagesModelFromJSON));
    }

    /**
     * Packages collected by the specified maintainer
     */
    async getRouteMaintainerPackagesSiteMaintainerPackages(requestParameters: GetRouteMaintainerPackagesSiteMaintainerPackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MaintainerPackagesModel>> {
        const response = await this.getRouteMaintainerPackagesSiteMaintainerPackagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List of maintainers in branch with nicknames and source packages count
     */
    async getRouteMaintainersAllRaw(requestParameters: GetRouteMaintainersAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AllMaintainersModel>>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteMaintainersAll().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/all_maintainers_with_nicknames`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AllMaintainersModelFromJSON));
    }

    /**
     * List of maintainers in branch with nicknames and source packages count
     */
    async getRouteMaintainersAll(requestParameters: GetRouteMaintainersAllRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AllMaintainersModel>> {
        const response = await this.getRouteMaintainersAllRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * alias for /all_maintainers_with_nicknames
     */
    async getRouteMaintainersAllSiteAllMaintainersRaw(requestParameters: GetRouteMaintainersAllSiteAllMaintainersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AllMaintainersModel>>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteMaintainersAllSiteAllMaintainers().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/all_maintainers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AllMaintainersModelFromJSON));
    }

    /**
     * alias for /all_maintainers_with_nicknames
     */
    async getRouteMaintainersAllSiteAllMaintainers(requestParameters: GetRouteMaintainersAllSiteAllMaintainersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AllMaintainersModel>> {
        const response = await this.getRouteMaintainersAllSiteAllMaintainersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Maintainer information
     */
    async getRouteMaintainersInfoSiteMaintainerInfoRaw(requestParameters: GetRouteMaintainersInfoSiteMaintainerInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MaintainerInfoModel>>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteMaintainersInfoSiteMaintainerInfo().'
            );
        }

        if (requestParameters['maintainerNickname'] == null) {
            throw new runtime.RequiredError(
                'maintainerNickname',
                'Required parameter "maintainerNickname" was null or undefined when calling getRouteMaintainersInfoSiteMaintainerInfo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['maintainerNickname'] != null) {
            queryParameters['maintainer_nickname'] = requestParameters['maintainerNickname'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/maintainer_info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MaintainerInfoModelFromJSON));
    }

    /**
     * Maintainer information
     */
    async getRouteMaintainersInfoSiteMaintainerInfo(requestParameters: GetRouteMaintainersInfoSiteMaintainerInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MaintainerInfoModel>> {
        const response = await this.getRouteMaintainersInfoSiteMaintainerInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get package changelog history by hash
     */
    async getRoutePackageChangelogSitePackageChangelogIntPkghashRaw(requestParameters: GetRoutePackageChangelogSitePackageChangelogIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteChangelogModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRoutePackageChangelogSitePackageChangelogIntPkghash().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['changelogLast'] != null) {
            queryParameters['changelog_last'] = requestParameters['changelogLast'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_changelog/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteChangelogModelFromJSON(jsonValue));
    }

    /**
     * Get package changelog history by hash
     */
    async getRoutePackageChangelogSitePackageChangelogIntPkghash(requestParameters: GetRoutePackageChangelogSitePackageChangelogIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteChangelogModel> {
        const response = await this.getRoutePackageChangelogSitePackageChangelogIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get package download links by source package hash
     */
    async getRoutePackageDownloadLinksSitePackageDownloadsIntPkghashRaw(requestParameters: GetRoutePackageDownloadLinksSitePackageDownloadsIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesDownloadsModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_downloads/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesDownloadsModelFromJSON(jsonValue));
    }

    /**
     * Get package download links by source package hash
     */
    async getRoutePackageDownloadLinksSitePackageDownloadsIntPkghash(requestParameters: GetRoutePackageDownloadLinksSitePackageDownloadsIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesDownloadsModel> {
        const response = await this.getRoutePackageDownloadLinksSitePackageDownloadsIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get package download links by source package hash
     */
    async getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghashRaw(requestParameters: GetRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesDownloadsModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_downloads_src/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesDownloadsModelFromJSON(jsonValue));
    }

    /**
     * Get package download links by source package hash
     */
    async getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghash(requestParameters: GetRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesDownloadsModel> {
        const response = await this.getRoutePackageDownloadLinksSitePackageDownloadsSrcIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get package info by hash
     */
    async getRoutePackageInfoSitePackageInfoIntPkghashRaw(requestParameters: GetRoutePackageInfoSitePackageInfoIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackageInfoModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRoutePackageInfoSitePackageInfoIntPkghash().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageInfoSitePackageInfoIntPkghash().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['changelogLast'] != null) {
            queryParameters['changelog_last'] = requestParameters['changelogLast'];
        }

        if (requestParameters['packageType'] != null) {
            queryParameters['package_type'] = requestParameters['packageType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_info/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackageInfoModelFromJSON(jsonValue));
    }

    /**
     * Get package info by hash
     */
    async getRoutePackageInfoSitePackageInfoIntPkghash(requestParameters: GetRoutePackageInfoSitePackageInfoIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackageInfoModel> {
        const response = await this.getRoutePackageInfoSitePackageInfoIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary packages file conflicts by source package.
     */
    async getRoutePackageMisconflictSitePackageMisconflictIntPkghashRaw(requestParameters: GetRoutePackageMisconflictSitePackageMisconflictIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageMisconflictBySrcModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRoutePackageMisconflictSitePackageMisconflictIntPkghash().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageMisconflictSitePackageMisconflictIntPkghash().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_misconflict/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageMisconflictBySrcModelFromJSON(jsonValue));
    }

    /**
     * Get binary packages file conflicts by source package.
     */
    async getRoutePackageMisconflictSitePackageMisconflictIntPkghash(requestParameters: GetRoutePackageMisconflictSitePackageMisconflictIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageMisconflictBySrcModel> {
        const response = await this.getRoutePackageMisconflictSitePackageMisconflictIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get source package name from repology.
     */
    async getRoutePackageNameFromRepologySitePackageNameFromRepologyRaw(requestParameters: GetRoutePackageNameFromRepologySitePackageNameFromRepologyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageNameFromRepologyModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageNameFromRepologySitePackageNameFromRepology().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackageNameFromRepologySitePackageNameFromRepology().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_name_from_repology`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageNameFromRepologyModelFromJSON(jsonValue));
    }

    /**
     * Get source package name from repology.
     */
    async getRoutePackageNameFromRepologySitePackageNameFromRepology(requestParameters: GetRoutePackageNameFromRepologySitePackageNameFromRepologyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageNameFromRepologyModel> {
        const response = await this.getRoutePackageNameFromRepologySitePackageNameFromRepologyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get package name, version, release and type by hash. Check package name matching if provided.
     */
    async getRoutePackageNvrByHashSitePackageNvrByHashIntPkghashRaw(requestParameters: GetRoutePackageNvrByHashSitePackageNvrByHashIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageNVRByHashModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_nvr_by_hash/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageNVRByHashModelFromJSON(jsonValue));
    }

    /**
     * Get package name, version, release and type by hash. Check package name matching if provided.
     */
    async getRoutePackageNvrByHashSitePackageNvrByHashIntPkghash(requestParameters: GetRoutePackageNvrByHashSitePackageNvrByHashIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageNVRByHashModel> {
        const response = await this.getRoutePackageNvrByHashSitePackageNvrByHashIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary packages versions from images
     */
    async getRoutePackageVersionsFromImagesSitePackageVersionsFromImagesRaw(requestParameters: GetRoutePackageVersionsFromImagesSitePackageVersionsFromImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteImagePackageVersionsModel>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackageVersionsFromImagesSitePackageVersionsFromImages().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageVersionsFromImagesSitePackageVersionsFromImages().'
            );
        }

        if (requestParameters['edition'] == null) {
            throw new runtime.RequiredError(
                'edition',
                'Required parameter "edition" was null or undefined when calling getRoutePackageVersionsFromImagesSitePackageVersionsFromImages().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling getRoutePackageVersionsFromImagesSitePackageVersionsFromImages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['edition'] != null) {
            queryParameters['edition'] = requestParameters['edition'];
        }

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_versions_from_images`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteImagePackageVersionsModelFromJSON(jsonValue));
    }

    /**
     * Get binary packages versions from images
     */
    async getRoutePackageVersionsFromImagesSitePackageVersionsFromImages(requestParameters: GetRoutePackageVersionsFromImagesSitePackageVersionsFromImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteImagePackageVersionsModel> {
        const response = await this.getRoutePackageVersionsFromImagesSitePackageVersionsFromImagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get source package versions from tasks
     */
    async getRoutePackageVersionsFromTasksSitePackageVersionsFromTasksRaw(requestParameters: GetRoutePackageVersionsFromTasksSitePackageVersionsFromTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SItePackagesVersionsFromTasksModel>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_versions_from_tasks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SItePackagesVersionsFromTasksModelFromJSON(jsonValue));
    }

    /**
     * Get source package versions from tasks
     */
    async getRoutePackageVersionsFromTasksSitePackageVersionsFromTasks(requestParameters: GetRoutePackageVersionsFromTasksSitePackageVersionsFromTasksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SItePackagesVersionsFromTasksModel> {
        const response = await this.getRoutePackageVersionsFromTasksSitePackageVersionsFromTasksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get source or binary package versions from last branches
     */
    async getRoutePackageVersionsSitePackageVersionsRaw(requestParameters: GetRoutePackageVersionsSitePackageVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteSourcePackagesVersionsModel>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackageVersionsSitePackageVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['packageType'] != null) {
            queryParameters['package_type'] = requestParameters['packageType'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/package_versions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteSourcePackagesVersionsModelFromJSON(jsonValue));
    }

    /**
     * Get source or binary package versions from last branches
     */
    async getRoutePackageVersionsSitePackageVersions(requestParameters: GetRoutePackageVersionsSitePackageVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteSourcePackagesVersionsModel> {
        const response = await this.getRoutePackageVersionsSitePackageVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary package archs and versions
     */
    async getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersionsRaw(requestParameters: GetRoutePackagesBinaryListSiteBinaryPackageArchsAndVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesBinaryListModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/binary_package_archs_and_versions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesBinaryListModelFromJSON(jsonValue));
    }

    /**
     * Get binary package archs and versions
     */
    async getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersions(requestParameters: GetRoutePackagesBinaryListSiteBinaryPackageArchsAndVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesBinaryListModel> {
        const response = await this.getRoutePackagesBinaryListSiteBinaryPackageArchsAndVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fast packages search by name
     */
    async getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookupRaw(requestParameters: GetRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteFastPackagesSearchModel>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/fast_packages_search_lookup`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteFastPackagesSearchModelFromJSON(jsonValue));
    }

    /**
     * Fast packages search by name
     */
    async getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookup(requestParameters: GetRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteFastPackagesSearchModel> {
        const response = await this.getRoutePackagesetFastPackagesSearchSiteFastPackagesSearchLookupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find packages by name
     */
    async getRoutePackagesetFindPackagesSiteFindPackagesRaw(requestParameters: GetRoutePackagesetFindPackagesSiteFindPackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteFingPackagesModel>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackagesetFindPackagesSiteFindPackages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/find_packages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteFingPackagesModelFromJSON(jsonValue));
    }

    /**
     * Find packages by name
     */
    async getRoutePackagesetFindPackagesSiteFindPackages(requestParameters: GetRoutePackagesetFindPackagesSiteFindPackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteFingPackagesModel> {
        const response = await this.getRoutePackagesetFindPackagesSiteFindPackagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get binary package hash by package name, arch and package set name
     */
    async getRoutePackagesetPackageBinaryHashSitePkghashByBinaryNameRaw(requestParameters: GetRoutePackagesetPackageBinaryHashSitePkghashByBinaryNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesetPackageHashModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName().'
            );
        }

        if (requestParameters['arch'] == null) {
            throw new runtime.RequiredError(
                'arch',
                'Required parameter "arch" was null or undefined when calling getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/pkghash_by_binary_name`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesetPackageHashModelFromJSON(jsonValue));
    }

    /**
     * Get binary package hash by package name, arch and package set name
     */
    async getRoutePackagesetPackageBinaryHashSitePkghashByBinaryName(requestParameters: GetRoutePackagesetPackageBinaryHashSitePkghashByBinaryNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesetPackageHashModel> {
        const response = await this.getRoutePackagesetPackageBinaryHashSitePkghashByBinaryNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get source package hash by package name and package set name
     */
    async getRoutePackagesetPackageHashSitePkghashByNameRaw(requestParameters: GetRoutePackagesetPackageHashSitePkghashByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesetPackageHashModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackagesetPackageHashSitePkghashByName().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackagesetPackageHashSitePkghashByName().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/pkghash_by_name`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesetPackageHashModelFromJSON(jsonValue));
    }

    /**
     * Get source package hash by package name and package set name
     */
    async getRoutePackagesetPackageHashSitePkghashByName(requestParameters: GetRoutePackagesetPackageHashSitePkghashByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesetPackageHashModel> {
        const response = await this.getRoutePackagesetPackageHashSitePkghashByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of packageset packages in accordance to given parameters
     */
    async getRoutePackagesetPackagesSiteRepositoryPackagesRaw(requestParameters: GetRoutePackagesetPackagesSiteRepositoryPackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackagesetPackagesSiteRepositoryPackages().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['packageType'] != null) {
            queryParameters['package_type'] = requestParameters['packageType'];
        }

        if (requestParameters['group'] != null) {
            queryParameters['group'] = requestParameters['group'];
        }

        if (requestParameters['buildtime'] != null) {
            queryParameters['buildtime'] = requestParameters['buildtime'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/repository_packages`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesModelFromJSON(jsonValue));
    }

    /**
     * Get list of packageset packages in accordance to given parameters
     */
    async getRoutePackagesetPackagesSiteRepositoryPackages(requestParameters: GetRoutePackagesetPackagesSiteRepositoryPackagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesModel> {
        const response = await this.getRoutePackagesetPackagesSiteRepositoryPackagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get source package hash by package name, version and release for specific branch
     */
    async getRoutePackagesetPkghashByNvrSitePkghashByNvrRaw(requestParameters: GetRoutePackagesetPkghashByNvrSitePkghashByNvrRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesetPackageHashByNameVersionRelease>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRoutePackagesetPkghashByNvrSitePkghashByNvr().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackagesetPkghashByNvrSitePkghashByNvr().'
            );
        }

        if (requestParameters['version'] == null) {
            throw new runtime.RequiredError(
                'version',
                'Required parameter "version" was null or undefined when calling getRoutePackagesetPkghashByNvrSitePkghashByNvr().'
            );
        }

        if (requestParameters['release'] == null) {
            throw new runtime.RequiredError(
                'release',
                'Required parameter "release" was null or undefined when calling getRoutePackagesetPkghashByNvrSitePkghashByNvr().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        if (requestParameters['release'] != null) {
            queryParameters['release'] = requestParameters['release'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/pkghash_by_nvr`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesetPackageHashByNameVersionReleaseFromJSON(jsonValue));
    }

    /**
     * Get source package hash by package name, version and release for specific branch
     */
    async getRoutePackagesetPkghashByNvrSitePkghashByNvr(requestParameters: GetRoutePackagesetPkghashByNvrSitePkghashByNvrRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesetPackageHashByNameVersionRelease> {
        const response = await this.getRoutePackagesetPkghashByNvrSitePkghashByNvrRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get package sets list with source packages count and status info
     */
    async getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesetsSummaryStatusModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/pkgsets_summary_status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesetsSummaryStatusModelFromJSON(jsonValue));
    }

    /**
     * Get package sets list with source packages count and status info
     */
    async getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesetsSummaryStatusModel> {
        const response = await this.getRoutePackagesetsSummaryStatusSitePkgsetsSummaryStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get package set list by package hash
     */
    async getRoutePackagsetsByHashSitePackagesetsByHashIntPkghashRaw(requestParameters: GetRoutePackagsetsByHashSitePackagesetsByHashIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesetsByHashModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/packagesets_by_hash/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesetsByHashModelFromJSON(jsonValue));
    }

    /**
     * Get package set list by package hash
     */
    async getRoutePackagsetsByHashSitePackagesetsByHashIntPkghash(requestParameters: GetRoutePackagsetsByHashSitePackagesetsByHashIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesetsByHashModel> {
        const response = await this.getRoutePackagsetsByHashSitePackagesetsByHashIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of package categories with count for given package set
     */
    async getRoutePkgsetCategoriesCountSitePkgsetCategoriesCountRaw(requestParameters: GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitePackagesetCategoriesModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['packageType'] != null) {
            queryParameters['package_type'] = requestParameters['packageType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/pkgset_categories_count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitePackagesetCategoriesModelFromJSON(jsonValue));
    }

    /**
     * Get list of package categories with count for given package set
     */
    async getRoutePkgsetCategoriesCountSitePkgsetCategoriesCount(requestParameters: GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitePackagesetCategoriesModel> {
        const response = await this.getRoutePkgsetCategoriesCountSitePkgsetCategoriesCountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get repocop results by the maintainers nickname
     */
    async getRouteRepocopByMaintainerSiteRepocopByMaintainerRaw(requestParameters: GetRouteRepocopByMaintainerSiteRepocopByMaintainerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RepocopByMaintainerModel>>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteRepocopByMaintainerSiteRepocopByMaintainer().'
            );
        }

        if (requestParameters['maintainerNickname'] == null) {
            throw new runtime.RequiredError(
                'maintainerNickname',
                'Required parameter "maintainerNickname" was null or undefined when calling getRouteRepocopByMaintainerSiteRepocopByMaintainer().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['maintainerNickname'] != null) {
            queryParameters['maintainer_nickname'] = requestParameters['maintainerNickname'];
        }

        if (requestParameters['byAcl'] != null) {
            queryParameters['by_acl'] = requestParameters['byAcl'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/repocop_by_maintainer`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RepocopByMaintainerModelFromJSON));
    }

    /**
     * Get repocop results by the maintainers nickname
     */
    async getRouteRepocopByMaintainerSiteRepocopByMaintainer(requestParameters: GetRouteRepocopByMaintainerSiteRepocopByMaintainerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RepocopByMaintainerModel>> {
        const response = await this.getRouteRepocopByMaintainerSiteRepocopByMaintainerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get source package versions from last branches
     */
    async getRouteSourcePackageVersionsSiteSourcePackageVersionsRaw(requestParameters: GetRouteSourcePackageVersionsSiteSourcePackageVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteSourcePackagesVersionsModel>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRouteSourcePackageVersionsSiteSourcePackageVersions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/source_package_versions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteSourcePackagesVersionsModelFromJSON(jsonValue));
    }

    /**
     * Get source package versions from last branches
     */
    async getRouteSourcePackageVersionsSiteSourcePackageVersions(requestParameters: GetRouteSourcePackageVersionsSiteSourcePackageVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteSourcePackagesVersionsModel> {
        const response = await this.getRouteSourcePackageVersionsSiteSourcePackageVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get tasks list by maintainer nickname
     * @deprecated
     */
    async getRouteTasksByMaintainerSiteTasksByMaintainerRaw(requestParameters: GetRouteTasksByMaintainerSiteTasksByMaintainerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SiteTaskByNameModel>>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteTasksByMaintainerSiteTasksByMaintainer().'
            );
        }

        if (requestParameters['maintainerNickname'] == null) {
            throw new runtime.RequiredError(
                'maintainerNickname',
                'Required parameter "maintainerNickname" was null or undefined when calling getRouteTasksByMaintainerSiteTasksByMaintainer().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['maintainerNickname'] != null) {
            queryParameters['maintainer_nickname'] = requestParameters['maintainerNickname'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/tasks_by_maintainer`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SiteTaskByNameModelFromJSON));
    }

    /**
     * Get tasks list by maintainer nickname
     * @deprecated
     */
    async getRouteTasksByMaintainerSiteTasksByMaintainer(requestParameters: GetRouteTasksByMaintainerSiteTasksByMaintainerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SiteTaskByNameModel>> {
        const response = await this.getRouteTasksByMaintainerSiteTasksByMaintainerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get tasks list by source package name
     * @deprecated
     */
    async getRouteTasksByPackageSiteTasksByPackageRaw(requestParameters: GetRouteTasksByPackageSiteTasksByPackageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteTaskByNameModel>> {
        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRouteTasksByPackageSiteTasksByPackage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/tasks_by_package`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteTaskByNameModelFromJSON(jsonValue));
    }

    /**
     * Get tasks list by source package name
     * @deprecated
     */
    async getRouteTasksByPackageSiteTasksByPackage(requestParameters: GetRouteTasksByPackageSiteTasksByPackageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteTaskByNameModel> {
        const response = await this.getRouteTasksByPackageSiteTasksByPackageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get history of done tasks for an active branches
     */
    async getRouteTasksHistorySiteTasksHistoryRaw(requestParameters: GetRouteTasksHistorySiteTasksHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SiteTasksHistoryModel>> {
        const queryParameters: any = {};

        if (requestParameters['taskId'] != null) {
            queryParameters['task_id'] = requestParameters['taskId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/tasks_history`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SiteTasksHistoryModelFromJSON(jsonValue));
    }

    /**
     * Get history of done tasks for an active branches
     */
    async getRouteTasksHistorySiteTasksHistory(requestParameters: GetRouteTasksHistorySiteTasksHistoryRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SiteTasksHistoryModel> {
        const response = await this.getRouteTasksHistorySiteTasksHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get watch packages by the maintainer\'s nickname
     */
    async getRouteWatchByMaintainerSiteWatchByMaintainerRaw(requestParameters: GetRouteWatchByMaintainerSiteWatchByMaintainerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SiteWatchByMaintainerModel>>> {
        if (requestParameters['maintainerNickname'] == null) {
            throw new runtime.RequiredError(
                'maintainerNickname',
                'Required parameter "maintainerNickname" was null or undefined when calling getRouteWatchByMaintainerSiteWatchByMaintainer().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['maintainerNickname'] != null) {
            queryParameters['maintainer_nickname'] = requestParameters['maintainerNickname'];
        }

        if (requestParameters['byAcl'] != null) {
            queryParameters['by_acl'] = requestParameters['byAcl'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/site/watch_by_maintainer`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SiteWatchByMaintainerModelFromJSON));
    }

    /**
     * Get watch packages by the maintainer\'s nickname
     */
    async getRouteWatchByMaintainerSiteWatchByMaintainer(requestParameters: GetRouteWatchByMaintainerSiteWatchByMaintainerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SiteWatchByMaintainerModel>> {
        const response = await this.getRouteWatchByMaintainerSiteWatchByMaintainerRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum = typeof GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum[keyof typeof GetRouteBeehiveByMaintainerSiteBeehiveErrorsByMaintainerByAclEnum];
/**
 * @export
 */
export const GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum = typeof GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum[keyof typeof GetRouteDeletedPackageInfoSiteDeletedPackageInfoPackageTypeEnum];
/**
 * @export
 */
export const GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum = typeof GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum[keyof typeof GetRouteMaintainerPackagesSiteMaintainerPackagesByAclEnum];
/**
 * @export
 */
export const GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum = typeof GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum[keyof typeof GetRoutePackageInfoSitePackageInfoIntPkghashPackageTypeEnum];
/**
 * @export
 */
export const GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum = typeof GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum[keyof typeof GetRoutePackageVersionsSitePackageVersionsPackageTypeEnum];
/**
 * @export
 */
export const GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum = {
    All: 'all',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum = typeof GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum[keyof typeof GetRoutePackagesetPackagesSiteRepositoryPackagesPackageTypeEnum];
/**
 * @export
 */
export const GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum = {
    All: 'all',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum = typeof GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum[keyof typeof GetRoutePkgsetCategoriesCountSitePkgsetCategoriesCountPackageTypeEnum];
/**
 * @export
 */
export const GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum = typeof GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum[keyof typeof GetRouteRepocopByMaintainerSiteRepocopByMaintainerByAclEnum];
/**
 * @export
 */
export const GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum = {
    None: 'none',
    ByNick: 'by_nick',
    ByNickLeader: 'by_nick_leader',
    ByNickOrGroup: 'by_nick_or_group',
    ByNickLeaderAndGroup: 'by_nick_leader_and_group'
} as const;
export type GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum = typeof GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum[keyof typeof GetRouteWatchByMaintainerSiteWatchByMaintainerByAclEnum];
