/* tslint:disable */
/* eslint-disable */
/**
 * ALTRepo API
 * altrepo API v1
 *
 * The version of the OpenAPI document: 1.19.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BranchTreeModel,
  PackagesetPackagesExportModel,
  RepologyExportModel,
  SitemapPackagesExportModel,
} from '../models/index';
import {
    BranchTreeModelFromJSON,
    BranchTreeModelToJSON,
    PackagesetPackagesExportModelFromJSON,
    PackagesetPackagesExportModelToJSON,
    RepologyExportModelFromJSON,
    RepologyExportModelToJSON,
    SitemapPackagesExportModelFromJSON,
    SitemapPackagesExportModelToJSON,
} from '../models/index';

export interface GetRoutePackageInfoExportRepologyStringBranchRequest {
    branch: string;
}

export interface GetRoutePackageSetBinariesExportBranchBinaryPackagesStringBranchRequest {
    branch: string;
    arch?: string;
}

export interface GetRouteSitemapPackagesExportSitemapPackagesStringBranchRequest {
    branch: string;
}

export interface GetRouteTranslationExportExportTranslationPackagesPoFilesRequest {
    branches: Array<string>;
    fromDate?: Date;
}

/**
 * 
 */
export class ExportApi extends runtime.BaseAPI {

    /**
     * Branch tree info export
     */
    async getRouteBranchTreeExportExportBranchTreeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BranchTreeModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/export/branch_tree`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BranchTreeModelFromJSON(jsonValue));
    }

    /**
     * Branch tree info export
     */
    async getRouteBranchTreeExportExportBranchTree(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BranchTreeModel> {
        const response = await this.getRouteBranchTreeExportExportBranchTreeRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get branch info export for Repology
     */
    async getRoutePackageInfoExportRepologyStringBranchRaw(requestParameters: GetRoutePackageInfoExportRepologyStringBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RepologyExportModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageInfoExportRepologyStringBranch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/export/repology/{branch}`.replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters['branch']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepologyExportModelFromJSON(jsonValue));
    }

    /**
     * Get branch info export for Repology
     */
    async getRoutePackageInfoExportRepologyStringBranch(requestParameters: GetRoutePackageInfoExportRepologyStringBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RepologyExportModel> {
        const response = await this.getRoutePackageInfoExportRepologyStringBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get branch binary packages info
     */
    async getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranchRaw(requestParameters: GetRoutePackageSetBinariesExportBranchBinaryPackagesStringBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackagesetPackagesExportModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/export/branch_binary_packages/{branch}`.replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters['branch']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackagesetPackagesExportModelFromJSON(jsonValue));
    }

    /**
     * Get branch binary packages info
     */
    async getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranch(requestParameters: GetRoutePackageSetBinariesExportBranchBinaryPackagesStringBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackagesetPackagesExportModel> {
        const response = await this.getRoutePackageSetBinariesExportBranchBinaryPackagesStringBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get branch source packages for sitemap
     */
    async getRouteSitemapPackagesExportSitemapPackagesStringBranchRaw(requestParameters: GetRouteSitemapPackagesExportSitemapPackagesStringBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SitemapPackagesExportModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteSitemapPackagesExportSitemapPackagesStringBranch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/export/sitemap_packages/{branch}`.replace(`{${"branch"}}`, encodeURIComponent(String(requestParameters['branch']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SitemapPackagesExportModelFromJSON(jsonValue));
    }

    /**
     * Get branch source packages for sitemap
     */
    async getRouteSitemapPackagesExportSitemapPackagesStringBranch(requestParameters: GetRouteSitemapPackagesExportSitemapPackagesStringBranchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SitemapPackagesExportModel> {
        const response = await this.getRouteSitemapPackagesExportSitemapPackagesStringBranchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get an archive of PO files with package\'s summary and description for translation purpose
     */
    async getRouteTranslationExportExportTranslationPackagesPoFilesRaw(requestParameters: GetRouteTranslationExportExportTranslationPackagesPoFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['branches'] == null) {
            throw new runtime.RequiredError(
                'branches',
                'Required parameter "branches" was null or undefined when calling getRouteTranslationExportExportTranslationPackagesPoFiles().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branches'] != null) {
            queryParameters['branches'] = requestParameters['branches']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['fromDate'] != null) {
            queryParameters['from_date'] = (requestParameters['fromDate'] as any).toISOString().substring(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/export/translation/packages_po_files`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get an archive of PO files with package\'s summary and description for translation purpose
     */
    async getRouteTranslationExportExportTranslationPackagesPoFiles(requestParameters: GetRouteTranslationExportExportTranslationPackagesPoFilesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getRouteTranslationExportExportTranslationPackagesPoFilesRaw(requestParameters, initOverrides);
    }

}
