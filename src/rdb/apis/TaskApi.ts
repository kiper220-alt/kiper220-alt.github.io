/* tslint:disable */
/* eslint-disable */
/**
 * ALTRepo API
 * altrepo API v1
 *
 * The version of the OpenAPI document: 1.19.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BuildDependencySetModel,
  CheckImagesInputModel,
  CheckImagesOutputModel,
  FindImagesByTaskModel,
  NeedsApprovalModel,
  TaskBuildDependencyModel,
  TaskDiffModel,
  TaskFindPackagesetModel,
  TaskHistoryModel,
  TaskInfoModel,
  TaskMisconflictPackagesModel,
  TaskPackagesModel,
  TaskRepoModel,
} from '../models/index';
import {
    BuildDependencySetModelFromJSON,
    BuildDependencySetModelToJSON,
    CheckImagesInputModelFromJSON,
    CheckImagesInputModelToJSON,
    CheckImagesOutputModelFromJSON,
    CheckImagesOutputModelToJSON,
    FindImagesByTaskModelFromJSON,
    FindImagesByTaskModelToJSON,
    NeedsApprovalModelFromJSON,
    NeedsApprovalModelToJSON,
    TaskBuildDependencyModelFromJSON,
    TaskBuildDependencyModelToJSON,
    TaskDiffModelFromJSON,
    TaskDiffModelToJSON,
    TaskFindPackagesetModelFromJSON,
    TaskFindPackagesetModelToJSON,
    TaskHistoryModelFromJSON,
    TaskHistoryModelToJSON,
    TaskInfoModelFromJSON,
    TaskInfoModelToJSON,
    TaskMisconflictPackagesModelFromJSON,
    TaskMisconflictPackagesModelToJSON,
    TaskPackagesModelFromJSON,
    TaskPackagesModelToJSON,
    TaskRepoModelFromJSON,
    TaskRepoModelToJSON,
} from '../models/index';

export interface GetRouteFindImagesTaskFindImagesIntIdRequest {
    id: number;
}

export interface GetRouteNeedsApprovalTaskNeedsApprovalRequest {
    aclGroup: GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum;
    branches?: Array<string>;
    before?: string;
}

export interface GetRouteTaskBuildDependencySetTaskBuildDependencySetIntIdRequest {
    id: number;
    arch?: string;
}

export interface GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdRequest {
    id: number;
    depth?: number;
    dptype?: GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum;
    archs?: Array<string>;
    leaf?: string;
    finitePackage?: boolean;
    filterByPackage?: Array<string>;
    filterBySource?: string;
    oneandhalf?: boolean;
    noCache?: string;
}

export interface GetRouteTaskDiffTaskTaskDiffIntIdRequest {
    id: number;
}

export interface GetRouteTaskFindPackagesetTaskFindPackagesetIntIdRequest {
    id: number;
    branches?: Array<string>;
}

export interface GetRouteTaskHistoryTaskTaskHistoryRequest {
    branch: string;
    startTask?: number;
    endTask?: number;
    startDate?: Date;
    endDate?: Date;
}

export interface GetRouteTaskInfoTaskTaskInfoIntIdRequest {
    id: number;
    _try?: number;
    iteration?: number;
    noCache?: string;
    states?: Array<string>;
}

export interface GetRouteTaskMisconflictPackagesTaskMisconflictIntIdRequest {
    id: number;
    archs?: Array<string>;
    noCache?: string;
}

export interface GetRouteTaskPackagesTaskPackagesIntIdRequest {
    id: number;
}

export interface GetRouteTaskRepoTaskTaskRepoIntIdRequest {
    id: number;
    includeTaskPackages?: boolean;
}

export interface PostRouteCheckImagesTaskCheckImagesRequest {
    payload: CheckImagesInputModel;
}

/**
 * 
 */
export class TaskApi extends runtime.BaseAPI {

    /**
     * Get the newest images which contain binary packages with the same names as binaries from a task with one of the following states: EPERM, TESTED or DONE. Listed only active images for task\'s branch.
     */
    async getRouteFindImagesTaskFindImagesIntIdRaw(requestParameters: GetRouteFindImagesTaskFindImagesIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindImagesByTaskModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteFindImagesTaskFindImagesIntId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/find_images/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FindImagesByTaskModelFromJSON(jsonValue));
    }

    /**
     * Get the newest images which contain binary packages with the same names as binaries from a task with one of the following states: EPERM, TESTED or DONE. Listed only active images for task\'s branch.
     */
    async getRouteFindImagesTaskFindImagesIntId(requestParameters: GetRouteFindImagesTaskFindImagesIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindImagesByTaskModel> {
        const response = await this.getRouteFindImagesTaskFindImagesIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get EPERM tasks which require approval
     */
    async getRouteNeedsApprovalTaskNeedsApprovalRaw(requestParameters: GetRouteNeedsApprovalTaskNeedsApprovalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NeedsApprovalModel>> {
        if (requestParameters['aclGroup'] == null) {
            throw new runtime.RequiredError(
                'aclGroup',
                'Required parameter "aclGroup" was null or undefined when calling getRouteNeedsApprovalTaskNeedsApproval().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['aclGroup'] != null) {
            queryParameters['acl_group'] = requestParameters['aclGroup'];
        }

        if (requestParameters['branches'] != null) {
            queryParameters['branches'] = requestParameters['branches']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['before'] != null) {
            queryParameters['before'] = requestParameters['before'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/needs_approval`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NeedsApprovalModelFromJSON(jsonValue));
    }

    /**
     * Get EPERM tasks which require approval
     */
    async getRouteNeedsApprovalTaskNeedsApproval(requestParameters: GetRouteNeedsApprovalTaskNeedsApprovalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NeedsApprovalModel> {
        const response = await this.getRouteNeedsApprovalTaskNeedsApprovalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of packages required for build by source packages from task recursively
     */
    async getRouteTaskBuildDependencySetTaskBuildDependencySetIntIdRaw(requestParameters: GetRouteTaskBuildDependencySetTaskBuildDependencySetIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildDependencySetModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteTaskBuildDependencySetTaskBuildDependencySetIntId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/build_dependency_set/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BuildDependencySetModelFromJSON(jsonValue));
    }

    /**
     * Get list of packages required for build by source packages from task recursively
     */
    async getRouteTaskBuildDependencySetTaskBuildDependencySetIntId(requestParameters: GetRouteTaskBuildDependencySetTaskBuildDependencySetIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildDependencySetModel> {
        const response = await this.getRouteTaskBuildDependencySetTaskBuildDependencySetIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get packages build dependencies
     */
    async getRouteTaskBuildDependencyTaskWhatDependsSrcIntIdRaw(requestParameters: GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskBuildDependencyModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteTaskBuildDependencyTaskWhatDependsSrcIntId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['depth'] != null) {
            queryParameters['depth'] = requestParameters['depth'];
        }

        if (requestParameters['dptype'] != null) {
            queryParameters['dptype'] = requestParameters['dptype'];
        }

        if (requestParameters['archs'] != null) {
            queryParameters['archs'] = requestParameters['archs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['leaf'] != null) {
            queryParameters['leaf'] = requestParameters['leaf'];
        }

        if (requestParameters['finitePackage'] != null) {
            queryParameters['finite_package'] = requestParameters['finitePackage'];
        }

        if (requestParameters['filterByPackage'] != null) {
            queryParameters['filter_by_package'] = requestParameters['filterByPackage']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['filterBySource'] != null) {
            queryParameters['filter_by_source'] = requestParameters['filterBySource'];
        }

        if (requestParameters['oneandhalf'] != null) {
            queryParameters['oneandhalf'] = requestParameters['oneandhalf'];
        }

        if (requestParameters['noCache'] != null) {
            queryParameters['no_cache'] = requestParameters['noCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/what_depends_src/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskBuildDependencyModelFromJSON(jsonValue));
    }

    /**
     * Get packages build dependencies
     */
    async getRouteTaskBuildDependencyTaskWhatDependsSrcIntId(requestParameters: GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskBuildDependencyModel> {
        const response = await this.getRouteTaskBuildDependencyTaskWhatDependsSrcIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get task difference by ID
     */
    async getRouteTaskDiffTaskTaskDiffIntIdRaw(requestParameters: GetRouteTaskDiffTaskTaskDiffIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskDiffModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteTaskDiffTaskTaskDiffIntId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/task_diff/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskDiffModelFromJSON(jsonValue));
    }

    /**
     * Get task difference by ID
     */
    async getRouteTaskDiffTaskTaskDiffIntId(requestParameters: GetRouteTaskDiffTaskTaskDiffIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskDiffModel> {
        const response = await this.getRouteTaskDiffTaskTaskDiffIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about packages from package sets by list of source packages from task
     */
    async getRouteTaskFindPackagesetTaskFindPackagesetIntIdRaw(requestParameters: GetRouteTaskFindPackagesetTaskFindPackagesetIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskFindPackagesetModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteTaskFindPackagesetTaskFindPackagesetIntId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branches'] != null) {
            queryParameters['branches'] = requestParameters['branches']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/find_packageset/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskFindPackagesetModelFromJSON(jsonValue));
    }

    /**
     * Get information about packages from package sets by list of source packages from task
     */
    async getRouteTaskFindPackagesetTaskFindPackagesetIntId(requestParameters: GetRouteTaskFindPackagesetTaskFindPackagesetIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskFindPackagesetModel> {
        const response = await this.getRouteTaskFindPackagesetTaskFindPackagesetIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get done tasks history for branch
     */
    async getRouteTaskHistoryTaskTaskHistoryRaw(requestParameters: GetRouteTaskHistoryTaskTaskHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskHistoryModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteTaskHistoryTaskTaskHistory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['startTask'] != null) {
            queryParameters['start_task'] = requestParameters['startTask'];
        }

        if (requestParameters['endTask'] != null) {
            queryParameters['end_task'] = requestParameters['endTask'];
        }

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = (requestParameters['startDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = (requestParameters['endDate'] as any).toISOString().substring(0,10);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/task_history`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskHistoryModelFromJSON(jsonValue));
    }

    /**
     * Get done tasks history for branch
     */
    async getRouteTaskHistoryTaskTaskHistory(requestParameters: GetRouteTaskHistoryTaskTaskHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskHistoryModel> {
        const response = await this.getRouteTaskHistoryTaskTaskHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information for task by ID
     */
    async getRouteTaskInfoTaskTaskInfoIntIdRaw(requestParameters: GetRouteTaskInfoTaskTaskInfoIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskInfoModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteTaskInfoTaskTaskInfoIntId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['_try'] != null) {
            queryParameters['try'] = requestParameters['_try'];
        }

        if (requestParameters['iteration'] != null) {
            queryParameters['iteration'] = requestParameters['iteration'];
        }

        if (requestParameters['noCache'] != null) {
            queryParameters['no_cache'] = requestParameters['noCache'];
        }

        if (requestParameters['states'] != null) {
            queryParameters['states'] = requestParameters['states']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/task_info/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskInfoModelFromJSON(jsonValue));
    }

    /**
     * Get information for task by ID
     */
    async getRouteTaskInfoTaskTaskInfoIntId(requestParameters: GetRouteTaskInfoTaskTaskInfoIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskInfoModel> {
        const response = await this.getRouteTaskInfoTaskTaskInfoIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get packages with conflicting files in packages from task that do not have a conflict in dependencies
     */
    async getRouteTaskMisconflictPackagesTaskMisconflictIntIdRaw(requestParameters: GetRouteTaskMisconflictPackagesTaskMisconflictIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskMisconflictPackagesModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteTaskMisconflictPackagesTaskMisconflictIntId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['archs'] != null) {
            queryParameters['archs'] = requestParameters['archs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['noCache'] != null) {
            queryParameters['no_cache'] = requestParameters['noCache'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/misconflict/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskMisconflictPackagesModelFromJSON(jsonValue));
    }

    /**
     * Get packages with conflicting files in packages from task that do not have a conflict in dependencies
     */
    async getRouteTaskMisconflictPackagesTaskMisconflictIntId(requestParameters: GetRouteTaskMisconflictPackagesTaskMisconflictIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskMisconflictPackagesModel> {
        const response = await this.getRouteTaskMisconflictPackagesTaskMisconflictIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about packages from task
     */
    async getRouteTaskPackagesTaskPackagesIntIdRaw(requestParameters: GetRouteTaskPackagesTaskPackagesIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskPackagesModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteTaskPackagesTaskPackagesIntId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/packages/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskPackagesModelFromJSON(jsonValue));
    }

    /**
     * Get information about packages from task
     */
    async getRouteTaskPackagesTaskPackagesIntId(requestParameters: GetRouteTaskPackagesTaskPackagesIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskPackagesModel> {
        const response = await this.getRouteTaskPackagesTaskPackagesIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get repository state by ID
     */
    async getRouteTaskRepoTaskTaskRepoIntIdRaw(requestParameters: GetRouteTaskRepoTaskTaskRepoIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskRepoModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getRouteTaskRepoTaskTaskRepoIntId().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['includeTaskPackages'] != null) {
            queryParameters['include_task_packages'] = requestParameters['includeTaskPackages'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/task/task_repo/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskRepoModelFromJSON(jsonValue));
    }

    /**
     * Get repository state by ID
     */
    async getRouteTaskRepoTaskTaskRepoIntId(requestParameters: GetRouteTaskRepoTaskTaskRepoIntIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskRepoModel> {
        const response = await this.getRouteTaskRepoTaskTaskRepoIntIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * ## Description Get relation between images and binary packages: - if some packages from a task are in images, they will be in **in_images** list. - if some packages from a task aren\'t in any image, they will be in **not_in_images** list.  ## Arguments - Allowed task\'s states: **EPERM**, **TESTED** or **DONE**. - If parameter **packages_names** (list of binary packages names) is set, it will show only specified binary packages. - You can provide multiple filters for images. If an image matches at least one filter, it will be shown.  ## Examples Show information about all of the binary packages inside images: ```json {     \"task_id\": 327143 } ``` Show information about all of the binary packages inside images which edition is \'alt-kworkstation\', type is \'iso\' and version is \'10.1.*\': ```json {     \"task_id\": 327143,     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"types\": [\"iso\"],             \"versions\": [\"10.1\"]         }     ] } ``` Show information about **liblash** binary package inside images which edition is \'alt-kworkstation\' with version \'10.1.*\' or edition \'slinux\' with version \'10.2.*\'. ```json {     \"task_id\": 312990,     \"packages_names\": [         \"liblash\"     ],     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"versions\": [\"10.1\"]         },         {             \"editions\": [\"slinux\"],             \"versions\": [\"10.2\"]         }     ] } ```
     */
    async postRouteCheckImagesTaskCheckImagesRaw(requestParameters: PostRouteCheckImagesTaskCheckImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckImagesOutputModel>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling postRouteCheckImagesTaskCheckImages().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/task/check_images`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CheckImagesInputModelToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckImagesOutputModelFromJSON(jsonValue));
    }

    /**
     * ## Description Get relation between images and binary packages: - if some packages from a task are in images, they will be in **in_images** list. - if some packages from a task aren\'t in any image, they will be in **not_in_images** list.  ## Arguments - Allowed task\'s states: **EPERM**, **TESTED** or **DONE**. - If parameter **packages_names** (list of binary packages names) is set, it will show only specified binary packages. - You can provide multiple filters for images. If an image matches at least one filter, it will be shown.  ## Examples Show information about all of the binary packages inside images: ```json {     \"task_id\": 327143 } ``` Show information about all of the binary packages inside images which edition is \'alt-kworkstation\', type is \'iso\' and version is \'10.1.*\': ```json {     \"task_id\": 327143,     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"types\": [\"iso\"],             \"versions\": [\"10.1\"]         }     ] } ``` Show information about **liblash** binary package inside images which edition is \'alt-kworkstation\' with version \'10.1.*\' or edition \'slinux\' with version \'10.2.*\'. ```json {     \"task_id\": 312990,     \"packages_names\": [         \"liblash\"     ],     \"filters\": [         {             \"editions\": [\"alt-kworkstation\"],             \"versions\": [\"10.1\"]         },         {             \"editions\": [\"slinux\"],             \"versions\": [\"10.2\"]         }     ] } ```
     */
    async postRouteCheckImagesTaskCheckImages(requestParameters: PostRouteCheckImagesTaskCheckImagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckImagesOutputModel> {
        const response = await this.postRouteCheckImagesTaskCheckImagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum = {
    Maint: 'maint',
    Tester: 'tester'
} as const;
export type GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum = typeof GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum[keyof typeof GetRouteNeedsApprovalTaskNeedsApprovalAclGroupEnum];
/**
 * @export
 */
export const GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum = {
    Both: 'both',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum = typeof GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum[keyof typeof GetRouteTaskBuildDependencyTaskWhatDependsSrcIntIdDptypeEnum];
