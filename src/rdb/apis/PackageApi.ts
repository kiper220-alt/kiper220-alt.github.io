/* tslint:disable */
/* eslint-disable */
/**
 * ALTRepo API
 * altrepo API v1
 *
 * The version of the OpenAPI document: 1.19.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BuildDependencySetModel,
  PackageBuildDependencyModel,
  PackageByFileNameModel,
  PackageFilesModel,
  PackageFindPackagesetModel,
  PackageInfoModel,
  PackageMisconflictPackagesModel,
  PackageSpecfileModel,
  PackagesByFileNamesJsonModel,
  RepocopJsonGetListModel,
  RepocopJsonPostListModel,
  UnpackagedDirsModel,
} from '../models/index';
import {
    BuildDependencySetModelFromJSON,
    BuildDependencySetModelToJSON,
    PackageBuildDependencyModelFromJSON,
    PackageBuildDependencyModelToJSON,
    PackageByFileNameModelFromJSON,
    PackageByFileNameModelToJSON,
    PackageFilesModelFromJSON,
    PackageFilesModelToJSON,
    PackageFindPackagesetModelFromJSON,
    PackageFindPackagesetModelToJSON,
    PackageInfoModelFromJSON,
    PackageInfoModelToJSON,
    PackageMisconflictPackagesModelFromJSON,
    PackageMisconflictPackagesModelToJSON,
    PackageSpecfileModelFromJSON,
    PackageSpecfileModelToJSON,
    PackagesByFileNamesJsonModelFromJSON,
    PackagesByFileNamesJsonModelToJSON,
    RepocopJsonGetListModelFromJSON,
    RepocopJsonGetListModelToJSON,
    RepocopJsonPostListModelFromJSON,
    RepocopJsonPostListModelToJSON,
    UnpackagedDirsModelFromJSON,
    UnpackagedDirsModelToJSON,
} from '../models/index';

export interface GetRouteBinPackageFilesPackagePackageFilesIntPkghashRequest {
    pkghash: number;
}

export interface GetRouteFindPackagesetPackageFindPackagesetRequest {
    packages: Array<string>;
    branches?: Array<string>;
}

export interface GetRoutePackageBuildDependencyPackageWhatDependsSrcRequest {
    packages: Array<string>;
    branch: string;
    depth?: number;
    dptype?: GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum;
    archs?: Array<string>;
    leaf?: string;
    finitePackage?: boolean;
    filterByPackage?: Array<string>;
    filterBySource?: string;
    oneandhalf?: boolean;
    useLastTasks?: boolean;
}

export interface GetRoutePackageBuildDependencySetPackageBuildDependencySetRequest {
    branch: string;
    packages: Array<string>;
    arch?: string;
}

export interface GetRoutePackageByFileMd5PackagePackageByFileMd5Request {
    branch: string;
    md5: string;
    arch?: string;
}

export interface GetRoutePackageByFileNamePackagePackageByFileNameRequest {
    file: string;
    branch: string;
    arch?: string;
}

export interface GetRoutePackageInfoPackagePackageInfoRequest {
    name?: string;
    version?: string;
    release?: string;
    arch?: string;
    source?: boolean;
    branch?: string;
    disttag?: string;
    sha1?: string;
    packager?: string;
    packagerEmail?: string;
    full?: boolean;
}

export interface GetRoutePackageMisconflictPackagesPackageMisconflictRequest {
    packages: Array<string>;
    branch: string;
    archs?: Array<string>;
}

export interface GetRoutePackageRepocopRequest {
    branch: string;
    packageName: string;
    packageVersion?: string;
    packageRelease?: string;
    binPackageArch?: string;
    packageType?: GetRoutePackageRepocopPackageTypeEnum;
}

export interface GetRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghashRequest {
    pkghash: number;
}

export interface GetRouteSpecfileByPackageNamePackageSpecfileByNameRequest {
    branch: string;
    name: string;
}

export interface GetRouteUnpackagedDirsPackageUnpackagedDirsRequest {
    branch: string;
    packager: string;
    archs?: Array<string>;
}

export interface PostRoutePackageRepocopRequest {
    payload: RepocopJsonPostListModel;
}

export interface PostRoutePackagesByFileNamesPackagePackagesByFileNamesRequest {
    payload: PackagesByFileNamesJsonModel;
}

/**
 * 
 */
export class PackageApi extends runtime.BaseAPI {

    /**
     * Get package files by hash
     */
    async getRouteBinPackageFilesPackagePackageFilesIntPkghashRaw(requestParameters: GetRouteBinPackageFilesPackagePackageFilesIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageFilesModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRouteBinPackageFilesPackagePackageFilesIntPkghash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/package_files/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageFilesModelFromJSON(jsonValue));
    }

    /**
     * Get package files by hash
     */
    async getRouteBinPackageFilesPackagePackageFilesIntPkghash(requestParameters: GetRouteBinPackageFilesPackagePackageFilesIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageFilesModel> {
        const response = await this.getRouteBinPackageFilesPackagePackageFilesIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about packages from package sets by given source packages list
     */
    async getRouteFindPackagesetPackageFindPackagesetRaw(requestParameters: GetRouteFindPackagesetPackageFindPackagesetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageFindPackagesetModel>> {
        if (requestParameters['packages'] == null) {
            throw new runtime.RequiredError(
                'packages',
                'Required parameter "packages" was null or undefined when calling getRouteFindPackagesetPackageFindPackageset().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['packages'] != null) {
            queryParameters['packages'] = requestParameters['packages']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['branches'] != null) {
            queryParameters['branches'] = requestParameters['branches']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/find_packageset`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageFindPackagesetModelFromJSON(jsonValue));
    }

    /**
     * Get information about packages from package sets by given source packages list
     */
    async getRouteFindPackagesetPackageFindPackageset(requestParameters: GetRouteFindPackagesetPackageFindPackagesetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageFindPackagesetModel> {
        const response = await this.getRouteFindPackagesetPackageFindPackagesetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get packages build dependencies by set of parameters
     */
    async getRoutePackageBuildDependencyPackageWhatDependsSrcRaw(requestParameters: GetRoutePackageBuildDependencyPackageWhatDependsSrcRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageBuildDependencyModel>> {
        if (requestParameters['packages'] == null) {
            throw new runtime.RequiredError(
                'packages',
                'Required parameter "packages" was null or undefined when calling getRoutePackageBuildDependencyPackageWhatDependsSrc().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageBuildDependencyPackageWhatDependsSrc().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['packages'] != null) {
            queryParameters['packages'] = requestParameters['packages']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['depth'] != null) {
            queryParameters['depth'] = requestParameters['depth'];
        }

        if (requestParameters['dptype'] != null) {
            queryParameters['dptype'] = requestParameters['dptype'];
        }

        if (requestParameters['archs'] != null) {
            queryParameters['archs'] = requestParameters['archs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['leaf'] != null) {
            queryParameters['leaf'] = requestParameters['leaf'];
        }

        if (requestParameters['finitePackage'] != null) {
            queryParameters['finite_package'] = requestParameters['finitePackage'];
        }

        if (requestParameters['filterByPackage'] != null) {
            queryParameters['filter_by_package'] = requestParameters['filterByPackage']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['filterBySource'] != null) {
            queryParameters['filter_by_source'] = requestParameters['filterBySource'];
        }

        if (requestParameters['oneandhalf'] != null) {
            queryParameters['oneandhalf'] = requestParameters['oneandhalf'];
        }

        if (requestParameters['useLastTasks'] != null) {
            queryParameters['use_last_tasks'] = requestParameters['useLastTasks'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/what_depends_src`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageBuildDependencyModelFromJSON(jsonValue));
    }

    /**
     * Get packages build dependencies by set of parameters
     */
    async getRoutePackageBuildDependencyPackageWhatDependsSrc(requestParameters: GetRoutePackageBuildDependencyPackageWhatDependsSrcRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageBuildDependencyModel> {
        const response = await this.getRoutePackageBuildDependencyPackageWhatDependsSrcRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of packages required for build by given source packages list recursively
     */
    async getRoutePackageBuildDependencySetPackageBuildDependencySetRaw(requestParameters: GetRoutePackageBuildDependencySetPackageBuildDependencySetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildDependencySetModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageBuildDependencySetPackageBuildDependencySet().'
            );
        }

        if (requestParameters['packages'] == null) {
            throw new runtime.RequiredError(
                'packages',
                'Required parameter "packages" was null or undefined when calling getRoutePackageBuildDependencySetPackageBuildDependencySet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['packages'] != null) {
            queryParameters['packages'] = requestParameters['packages']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/build_dependency_set`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BuildDependencySetModelFromJSON(jsonValue));
    }

    /**
     * Get list of packages required for build by given source packages list recursively
     */
    async getRoutePackageBuildDependencySetPackageBuildDependencySet(requestParameters: GetRoutePackageBuildDependencySetPackageBuildDependencySetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildDependencySetModel> {
        const response = await this.getRoutePackageBuildDependencySetPackageBuildDependencySetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about binary packages from  last package sets by given file MD5 checksum and package set name
     */
    async getRoutePackageByFileMd5PackagePackageByFileMd5Raw(requestParameters: GetRoutePackageByFileMd5PackagePackageByFileMd5Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageByFileNameModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageByFileMd5PackagePackageByFileMd5().'
            );
        }

        if (requestParameters['md5'] == null) {
            throw new runtime.RequiredError(
                'md5',
                'Required parameter "md5" was null or undefined when calling getRoutePackageByFileMd5PackagePackageByFileMd5().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['md5'] != null) {
            queryParameters['md5'] = requestParameters['md5'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/package_by_file_md5`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageByFileNameModelFromJSON(jsonValue));
    }

    /**
     * Get information about binary packages from  last package sets by given file MD5 checksum and package set name
     */
    async getRoutePackageByFileMd5PackagePackageByFileMd5(requestParameters: GetRoutePackageByFileMd5PackagePackageByFileMd5Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageByFileNameModel> {
        const response = await this.getRoutePackageByFileMd5PackagePackageByFileMd5Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about binary packages from  last package sets by given file name and package set name. File name wildcars \'*\' is allowed.
     */
    async getRoutePackageByFileNamePackagePackageByFileNameRaw(requestParameters: GetRoutePackageByFileNamePackagePackageByFileNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageByFileNameModel>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling getRoutePackageByFileNamePackagePackageByFileName().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageByFileNamePackagePackageByFileName().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['file'] != null) {
            queryParameters['file'] = requestParameters['file'];
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/package_by_file_name`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageByFileNameModelFromJSON(jsonValue));
    }

    /**
     * Get information about binary packages from  last package sets by given file name and package set name. File name wildcars \'*\' is allowed.
     */
    async getRoutePackageByFileNamePackagePackageByFileName(requestParameters: GetRoutePackageByFileNamePackagePackageByFileNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageByFileNameModel> {
        const response = await this.getRoutePackageByFileNamePackagePackageByFileNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information for package by parameters from last packages
     */
    async getRoutePackageInfoPackagePackageInfoRaw(requestParameters: GetRoutePackageInfoPackagePackageInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageInfoModel>> {
        const queryParameters: any = {};

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        if (requestParameters['release'] != null) {
            queryParameters['release'] = requestParameters['release'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        if (requestParameters['source'] != null) {
            queryParameters['source'] = requestParameters['source'];
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['disttag'] != null) {
            queryParameters['disttag'] = requestParameters['disttag'];
        }

        if (requestParameters['sha1'] != null) {
            queryParameters['sha1'] = requestParameters['sha1'];
        }

        if (requestParameters['packager'] != null) {
            queryParameters['packager'] = requestParameters['packager'];
        }

        if (requestParameters['packagerEmail'] != null) {
            queryParameters['packager_email'] = requestParameters['packagerEmail'];
        }

        if (requestParameters['full'] != null) {
            queryParameters['full'] = requestParameters['full'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/package_info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageInfoModelFromJSON(jsonValue));
    }

    /**
     * Get information for package by parameters from last packages
     */
    async getRoutePackageInfoPackagePackageInfo(requestParameters: GetRoutePackageInfoPackagePackageInfoRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageInfoModel> {
        const response = await this.getRoutePackageInfoPackagePackageInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get packages with conflicting files in packages that don\'t have a conflict in dependencies
     */
    async getRoutePackageMisconflictPackagesPackageMisconflictRaw(requestParameters: GetRoutePackageMisconflictPackagesPackageMisconflictRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageMisconflictPackagesModel>> {
        if (requestParameters['packages'] == null) {
            throw new runtime.RequiredError(
                'packages',
                'Required parameter "packages" was null or undefined when calling getRoutePackageMisconflictPackagesPackageMisconflict().'
            );
        }

        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageMisconflictPackagesPackageMisconflict().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['packages'] != null) {
            queryParameters['packages'] = requestParameters['packages']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['archs'] != null) {
            queryParameters['archs'] = requestParameters['archs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/misconflict`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageMisconflictPackagesModelFromJSON(jsonValue));
    }

    /**
     * Get packages with conflicting files in packages that don\'t have a conflict in dependencies
     */
    async getRoutePackageMisconflictPackagesPackageMisconflict(requestParameters: GetRoutePackageMisconflictPackagesPackageMisconflictRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageMisconflictPackagesModel> {
        const response = await this.getRoutePackageMisconflictPackagesPackageMisconflictRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get repocop data by name, version and release
     */
    async getRoutePackageRepocopRaw(requestParameters: GetRoutePackageRepocopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RepocopJsonGetListModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRoutePackageRepocop().'
            );
        }

        if (requestParameters['packageName'] == null) {
            throw new runtime.RequiredError(
                'packageName',
                'Required parameter "packageName" was null or undefined when calling getRoutePackageRepocop().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['packageName'] != null) {
            queryParameters['package_name'] = requestParameters['packageName'];
        }

        if (requestParameters['packageVersion'] != null) {
            queryParameters['package_version'] = requestParameters['packageVersion'];
        }

        if (requestParameters['packageRelease'] != null) {
            queryParameters['package_release'] = requestParameters['packageRelease'];
        }

        if (requestParameters['binPackageArch'] != null) {
            queryParameters['bin_package_arch'] = requestParameters['binPackageArch'];
        }

        if (requestParameters['packageType'] != null) {
            queryParameters['package_type'] = requestParameters['packageType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/repocop`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RepocopJsonGetListModelFromJSON(jsonValue));
    }

    /**
     * Get repocop data by name, version and release
     */
    async getRoutePackageRepocop(requestParameters: GetRoutePackageRepocopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RepocopJsonGetListModel> {
        const response = await this.getRoutePackageRepocopRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get spec file by source package hash
     */
    async getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghashRaw(requestParameters: GetRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageSpecfileModel>> {
        if (requestParameters['pkghash'] == null) {
            throw new runtime.RequiredError(
                'pkghash',
                'Required parameter "pkghash" was null or undefined when calling getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/specfile_by_hash/{pkghash}`.replace(`{${"pkghash"}}`, encodeURIComponent(String(requestParameters['pkghash']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageSpecfileModelFromJSON(jsonValue));
    }

    /**
     * Get spec file by source package hash
     */
    async getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghash(requestParameters: GetRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghashRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageSpecfileModel> {
        const response = await this.getRouteSpecfileByPackageHashPackageSpecfileByHashIntPkghashRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get spec file by source package name and branch
     */
    async getRouteSpecfileByPackageNamePackageSpecfileByNameRaw(requestParameters: GetRouteSpecfileByPackageNamePackageSpecfileByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageSpecfileModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteSpecfileByPackageNamePackageSpecfileByName().'
            );
        }

        if (requestParameters['name'] == null) {
            throw new runtime.RequiredError(
                'name',
                'Required parameter "name" was null or undefined when calling getRouteSpecfileByPackageNamePackageSpecfileByName().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/specfile_by_name`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageSpecfileModelFromJSON(jsonValue));
    }

    /**
     * Get spec file by source package name and branch
     */
    async getRouteSpecfileByPackageNamePackageSpecfileByName(requestParameters: GetRouteSpecfileByPackageNamePackageSpecfileByNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageSpecfileModel> {
        const response = await this.getRouteSpecfileByPackageNamePackageSpecfileByNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about unpackaged directories by maintainer nickname
     */
    async getRouteUnpackagedDirsPackageUnpackagedDirsRaw(requestParameters: GetRouteUnpackagedDirsPackageUnpackagedDirsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UnpackagedDirsModel>> {
        if (requestParameters['branch'] == null) {
            throw new runtime.RequiredError(
                'branch',
                'Required parameter "branch" was null or undefined when calling getRouteUnpackagedDirsPackageUnpackagedDirs().'
            );
        }

        if (requestParameters['packager'] == null) {
            throw new runtime.RequiredError(
                'packager',
                'Required parameter "packager" was null or undefined when calling getRouteUnpackagedDirsPackageUnpackagedDirs().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['branch'] != null) {
            queryParameters['branch'] = requestParameters['branch'];
        }

        if (requestParameters['packager'] != null) {
            queryParameters['packager'] = requestParameters['packager'];
        }

        if (requestParameters['archs'] != null) {
            queryParameters['archs'] = requestParameters['archs']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/package/unpackaged_dirs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UnpackagedDirsModelFromJSON(jsonValue));
    }

    /**
     * Get information about unpackaged directories by maintainer nickname
     */
    async getRouteUnpackagedDirsPackageUnpackagedDirs(requestParameters: GetRouteUnpackagedDirsPackageUnpackagedDirsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UnpackagedDirsModel> {
        const response = await this.getRouteUnpackagedDirsPackageUnpackagedDirsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Load repocop data into database
     */
    async postRoutePackageRepocopRaw(requestParameters: PostRoutePackageRepocopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling postRoutePackageRepocop().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/package/repocop`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RepocopJsonPostListModelToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Load repocop data into database
     */
    async postRoutePackageRepocop(requestParameters: PostRoutePackageRepocopRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.postRoutePackageRepocopRaw(requestParameters, initOverrides);
    }

    /**
     * Get information about binary packages from  last package sets by given file names array and package set name. File name wildcars \'*\' is not allowed.
     */
    async postRoutePackagesByFileNamesPackagePackagesByFileNamesRaw(requestParameters: PostRoutePackagesByFileNamesPackagePackagesByFileNamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PackageByFileNameModel>> {
        if (requestParameters['payload'] == null) {
            throw new runtime.RequiredError(
                'payload',
                'Required parameter "payload" was null or undefined when calling postRoutePackagesByFileNamesPackagePackagesByFileNames().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/package/packages_by_file_names`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PackagesByFileNamesJsonModelToJSON(requestParameters['payload']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PackageByFileNameModelFromJSON(jsonValue));
    }

    /**
     * Get information about binary packages from  last package sets by given file names array and package set name. File name wildcars \'*\' is not allowed.
     */
    async postRoutePackagesByFileNamesPackagePackagesByFileNames(requestParameters: PostRoutePackagesByFileNamesPackagePackagesByFileNamesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PackageByFileNameModel> {
        const response = await this.postRoutePackagesByFileNamesPackagePackagesByFileNamesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum = {
    Both: 'both',
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum = typeof GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum[keyof typeof GetRoutePackageBuildDependencyPackageWhatDependsSrcDptypeEnum];
/**
 * @export
 */
export const GetRoutePackageRepocopPackageTypeEnum = {
    Source: 'source',
    Binary: 'binary'
} as const;
export type GetRoutePackageRepocopPackageTypeEnum = typeof GetRoutePackageRepocopPackageTypeEnum[keyof typeof GetRoutePackageRepocopPackageTypeEnum];
